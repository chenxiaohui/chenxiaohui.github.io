<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-10-11T14:34:16+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Shawn Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自动生成ifdef标记和作者信息的插件]]></title>
    <link href="http://cxh.me/2014/10/11/ifdef-generator/"/>
    <updated>2014-10-11T14:28:00+08:00</updated>
    <id>http://cxh.me/2014/10/11/ifdef-generator</id>
    <content type="html"><![CDATA[<p>  针对团队开发为了统一代码风格往往有比较严格的代码规范。为了自动化的生成一些不变的内容，写了如下两个插件（有的是改动）：</p>

<blockquote><ol>
<li>ifdef.vim 生成ifndef标记，防止重复包含。</li>
<li>author_info.vim 生成更新作者信息版权声明</li>
</ol>
</blockquote>

<p>  详见<a href="https://github.com/chenxiaohui/ifdef_generator">https://github.com/chenxiaohui/ifdef_generator</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夜景几张]]></title>
    <link href="http://cxh.me/2014/09/08/ffc-pictures/"/>
    <updated>2014-09-08T21:25:00+08:00</updated>
    <id>http://cxh.me/2014/09/08/ffc-pictures</id>
    <content type="html"><![CDATA[<p>  实在是镜头决定了成败，套头拍月亮基本是对不上焦的节奏，只能拍拍旁边的楼了。财富金融中心，应该是北京最高的写字楼了。貌似有跑焦。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/ffc_dark.jpg" title="FFC" alt="FFC"><p class="align-center">FFC</p></p>

<!--more-->


<p>  再贴一张曝光长一点的。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/ffc_light.jpg" title="FFC" alt="FFC"><p class="align-center">FFC</p></p>

<p>  以及裤衩沐浴在月光中的&hellip;</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/moon.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[永不分开，世界的爱]]></title>
    <link href="http://cxh.me/2014/09/08/the-love-of-the-world/"/>
    <updated>2014-09-08T20:03:00+08:00</updated>
    <id>http://cxh.me/2014/09/08/the-love-of-the-world</id>
    <content type="html"><![CDATA[<p>  这应该算是很古老很古老的一首歌了，当时赵薇还是个青涩的小燕子。2000年的时候还在上初中，实在不理解新千年的意义。现在回想起来，新千年的到来，对人类来说，实在是个有着难以名状的意义。20世纪前半叶的多灾多难，后半叶的冷战阴云，没有哪个世纪会产生如此重大的人类群体性灾难。旧的秩序被打破，核战争的阴云，武器发展到批量化的收割人命，20世纪可能是人类历史上绝无仅有一个世纪。</p>

<p>  从这个角度想，这首歌真是充满了感慨。停留在20世纪的末尾，回首这一个多灾多难的世纪，看人类从错误中反省，最终一起站在新千年的入口展望未来。某种意义上说，人类第一次站在一起迎接和平，憧憬未来。这其中的意味可能只有经历过苦难的人才体会的出来，虽然2000年的时候局部战争依然在进行着。</p>

<p>  一首歌的意味只有联想到背景才体会得到啊，不知道有多少人还记得这首歌了。不妨回味。</p>

<p>  <embed src="http://player.yinyuetai.com/video/player/438643/v_0.swf" quality="high" width="480" height="334" align="middle"  allowScriptAccess="sameDomain" allowfullscreen="true" type="application/x-shockwave-flash"></embed></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用google来验证一下Maclaurin展开式]]></title>
    <link href="http://cxh.me/2014/09/07/using-google-verify-maclaurin-series/"/>
    <updated>2014-09-07T15:35:00+08:00</updated>
    <id>http://cxh.me/2014/09/07/using-google-verify-maclaurin-series</id>
    <content type="html"><![CDATA[<p>  偶然发现google可以直接画出函数图像来，精准度极高，于是想起来用这个功能来看一下Maclaurin展开是如何随精度增加而逼近展开式的。从某种角度上讲，这是一个极好的拟合过程，相对于梯度下降的逐步拟合来讲，泰勒公式或者麦克劳林展开直接推导出了每一个拟合因子。</p>

<p>  泰勒级数的定义如下：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/taylor.png" title="Taylor公式" alt="Taylor公式"><p class="align-center">Taylor公式</p></p>

<p>  不过这是带拉格朗日余项的形式。让基准值=0可以得到 Maclaurin 展开式，当然这也就意味着Maclaurin展开式在0附近的拟合是最精确的。定义如下：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/Maclaurin.png" title="Maclaurin展开式" alt="Maclaurin展开式"><p class="align-center">Maclaurin展开式</p></p>

<!--more-->


<p>  几个重要的Maclaurin展开如下：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/sinx.png">
  <img class="center" src="http://cxh.me/images/2014/cosx.png" title="几个重要的Maclaurin展开" alt="几个重要的Maclaurin展开"><p class="align-center">几个重要的Maclaurin展开</p></p>

<p>  这里我们验证一下sinx的逼近随着级数的增加而增加的情况。这也对应于拟合过程拟合维度的增加，相对于一元的拟合，二元或者多元就是会精确一些，但是会带来过拟合的风险。</p>

<p>  首先是sinx的图像</p>

<p>  <img class="center" src="http://cxh.me/images/2014/sin_x.png"></p>

<p>  一元函数拟合的时候，y=x</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_1.png"></p>

<p>  二元拟合的时候，y=x-x<sup>3</sup>/3!</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_2.png"></p>

<p>  三元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_3.png"></p>

<p>  四元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!-x<sup>7</sup>/7!</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_4.png"></p>

<p>  合并起来的图像大致如此：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/combine.png"></p>

<p>  再高阶的图像就不画了，上面基本保证了坐标系缩放比例是一致的(sinx的图像由于y轴比例没有跟其他的x轴保持一样的缩放比例），可以看到随着拟合维度的升高，拟合曲线越来越逼近sinx，这也直观体现了Maclaurin展开式的意义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《改善C++程序的150个建议》勘误]]></title>
    <link href="http://cxh.me/2014/09/06/error-in-cpp-150-notes/"/>
    <updated>2014-09-06T11:41:00+08:00</updated>
    <id>http://cxh.me/2014/09/06/error-in-cpp-150-notes</id>
    <content type="html"><![CDATA[<p>  翻了一下编写高质量代码：改善C++程序的150个建议，感觉一般，主要是能下到pdf。看到两个错误。</p>

<p>  第一个错误是内存池的那里，内部类使用了外部类的成员变量，这是C++啊，不是java，内部类默认不持有外部类指针。</p>

<pre><code>class MemPool
{
  public:
    MemPool (int nItemSize, int nMemBlockSize = 2048):
      m_nItemSize(nItemSize),
      m_nMemBlockSize(nMemBlockSize),
      m_pMemBlockHeader(NULL),
      m_pFreeNodeHeader(NULL)
    {}
    virtual ~MemPool (){}
    void * Alloc();
    void Free();
  private:
    /* data */
    const int m_nMemBlockSize;
    const int m_nItemSize;
    struct _FreeNode
    {
      _FreeNode* pPrev;
      char data[m_nItemSize - sizeof(_FreeNode*)];
    };
    struct _MemBlock
    {
      _MemBlock * pPrev;
      _FreeNode data[m_nMemBlockSize/m_nItemSize];
    };
    _MemBlock* m_pMemBlockHeader;
    _FreeNode* m_pFreeNodeHeader;
};
</code></pre>

<p>  第二个错误是作者强调nocopyable基类是需要私有继承的，其实不需要，public继承足够了，public继承又不会把基类的private成员继承下来。</p>

<pre><code>class nocopyable
{
  public:
    nocopyable (){}
    virtual ~nocopyable (){}

  private:
    /* data */
    nocopyable (const nocopyable&amp;);
    nocopyable&amp; operator=(const nocopyable&amp;);
};
class Base : public nocopyable
</code></pre>

<p>  太tm不严谨了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paxos算法学习]]></title>
    <link href="http://cxh.me/2014/08/26/paxos-study/"/>
    <updated>2014-08-26T20:53:00+08:00</updated>
    <id>http://cxh.me/2014/08/26/paxos-study</id>
    <content type="html"><![CDATA[<p>  本来想写点东西，后来觉得都是一知半解。这里转载一点学习资料吧。</p>

<p>  一个是知行学社的分布式系统与Paxos算法视频课程，循序渐进，讲解地比较浅显易懂。</p>

<p>  <embed src="http://www.tudou.com/v/e8zM8dAL6hM/&bid=05&rpid=51943457&resourceId=51943457_05_05_99/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"></embed></p>

<p>  另一个是百度刘杰<a href="http://www.valleytalk.org/2012/07/12/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%8B-%E3%80%82%E7%99%BE%E5%BA%A6-%E3%80%82%E5%88%98%E6%9D%B0/" title="《分布式系统原理介绍》">《分布式系统原理介绍》</a>。当然Lamport的几篇论文是不能不看的，虽然都不太好懂。</p>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" title="The Part-Time Parliament">The Part-Time Parliament</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" title="paxos made simple">Paxos Made Simple</a></li>
<li><a href="https://www.andrew.cmu.edu/course/15-749/READINGS/required/resilience/lamport82.pdf" title="The Byzantine Generals Problem">The Byzantine Generals Problem</a></li>
</ul>


<p>  相比较而言，<a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)" title="Paxos (computer science)">paxos的wiki</a>可能更好懂一些。有余力的同学可以做一下<a href="http://css.csail.mit.edu/6.824/2014/" title="MIT Distributed Systems Labs">MIT Distributed Systems Labs</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++的限制拷贝]]></title>
    <link href="http://cxh.me/2014/08/24/no-copy-restrict/"/>
    <updated>2014-08-24T12:44:00+08:00</updated>
    <id>http://cxh.me/2014/08/24/no-copy-restrict</id>
    <content type="html"><![CDATA[<p>  如果需要禁止一个类的拷贝（多鉴于RAII的资源类），按习惯我们会把拷贝构造函数和赋值运算符重载设置为私有的。比如：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base (){}

  private:
    Base(const Base&amp; b)
    Base &amp; operator=(const Base&amp; b)
};

int main(int argc, const char *argv[])
{
  Base b(1);//ok
  Base c=1;//error[1]
  Base d=c;//error
  c = d;//error
  return 0;
}
</code></pre>

<p>  但是问题在于[1]这里没有道理被屏蔽掉，应该会被优化成Base c(1)。如下代码可以证明：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base ()
    {
    }
    Base(const Base&amp; b)
    {
      cout&lt;&lt;"copy consturct" &lt;&lt;endl;
    }
};

int main(int argc, const char *argv[])
{
  Base c=1;
  return 0;
}
</code></pre>

<p>  运行结果：</p>

<pre><code>construct
</code></pre>

<p>  后来我试了一下才发现，首先这个优化是编译器层面的，所以不同的编译器处理应该是不一样的，虽然我们见到的编译器应该都支持。其次这个优化不是语法检查前做的，也就意味着，在<strong>构造函数没有被声明为explicit的时候</strong>，语法检查会把这个认为是先做了类型转换，然后调用拷贝构造函数，也就是如下：</p>

<pre><code>Base c = Base(1);
</code></pre>

<p>  这就在编译的时候报错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[暴力街区13]]></title>
    <link href="http://cxh.me/2014/08/17/brick-mansions/"/>
    <updated>2014-08-17T20:39:00+08:00</updated>
    <id>http://cxh.me/2014/08/17/brick-mansions</id>
    <content type="html"><![CDATA[<p>   <img class="img-polaroid center" src="http://cxh.me/images/2014/brick_mansions.jpg"></p>

<p>   虽说是翻拍，但是也不能一模一样啊，这剧情的相似度不是一般的高啊&hellip;.</p>

<p>   而且第二部的时候我就不理解，如果要引爆一个炸弹，直接倒计时爆炸就行了，干嘛要派一个人进去再输入一个引爆密码？剧情可从来没说炸弹送进去的时候就知道会被发射回来。</p>

<p>   还有，不要黑我大底特律&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[沉默地与这个世界对抗]]></title>
    <link href="http://cxh.me/2014/07/26/against-the-world-in-silence/"/>
    <updated>2014-07-26T18:59:00+08:00</updated>
    <id>http://cxh.me/2014/07/26/against-the-world-in-silence</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="http://cxh.me/images/2014/road.jpg"></p>

<p>  去看了《后会无期》。是我心里的样子。</p>

<p>  踏上旅途，遇到形形色色的人，停留而又离开，坚持或者放弃，很真实，不是么？都说小孩才看对错，成年人只看利弊，其实成年人也不是只看利弊，但是成年人的世界的确不能只用对错衡量了。</p>

<p>  When I was a little boy，当我还是一个小男孩的时候，我想，这个世界该是什么样子的呢？是西游记那样，哆啦a梦那样，还是圣斗士星矢那样呢？后来才发现，都不是。当我们经历了一些事情，我们知道了付出并不一定有回报，正义并不一定能战胜邪恶，甚至大部分情况下看，邪恶总比正义强大一点的时候，是否还相信对错呢？不知道。</p>

<p>  电影其实一直在问这个问题，当你还在东极岛的时候，对错是直接的，是非是明确的，每个人活的像胡生一样简单。但是家乡不在了，你被迫上路，被骗，被偷，看到大部分人活的不如意，小部分人似乎如意，内心里承受坚持与放弃的碰撞，最后连胡生也丢了。老师讲的那些东西已经不足以解释这些问题，但是内心里又有一个声音告诉你不能沉沦。生活不就是这样么。</p>

<p>  我们中大部分人是不会很成功，也不会很顺利的。所以这是个十分现实的问题，如果几十年后再问我们这些人的当初的理想，那么情况应该惨烈过台风后的海南。所以理想破灭似乎是跟更年期一样普遍的问题，以至于我们要考虑考虑如何平静度过这段时间。对中国人这样一个没有信仰的民族，我觉得这尤其重要了。</p>

<p>  那么问题就在于，现实如此，该去向哪里。步入这个年纪，已经不会有人指导你该做什么，也明白了抱怨其实没什么用。平凡是常态，希望仍渺茫，青春已逝，认输之前。</p>

<p>  但是理想还在路上，只不过孤独前行着罢了。人生总有那么几年，甚至几十年是默默无闻的。有一个意义支撑着，是很好的事情。淡出焦点之外，才是行路的最好状态。迷失了，就找另外的路，跌倒了，就爬起来继续沉默前行。理想破灭，就沉默着与这个世界对抗。纵使没有改变什么，至少给自己一个意义，让所有的前行都变得值得。</p>

<blockquote><ul>
<li>我曾经毁了我的一切 只想永远地离开</li>
<li>我曾经堕入无边黑暗 想挣扎无法自拔</li>
<li>我曾经象你象他象那野草野花</li>
<li>绝望着 渴望着 哭着笑着平凡着</li>
</ul>
</blockquote>

<p>  于是你可以说，嗯，是我心里的样子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[平凡之路]]></title>
    <link href="http://cxh.me/2014/07/20/normal-roads/"/>
    <updated>2014-07-20T10:06:00+08:00</updated>
    <id>http://cxh.me/2014/07/20/normal-roads</id>
    <content type="html"><![CDATA[<p>  朴树的《后会无期》主题曲：平凡之路</p>

<p><embed src="http://player.youku.com/player.php/sid/XNzQxMjU2ODI0/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<ul>
<li>我曾经跨过山和大海</li>
<li>也穿过人山人海</li>
<li>我曾经拥有着一切</li>
<li>转眼都飘散如烟</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[后会无期]]></title>
    <link href="http://cxh.me/2014/07/19/continent/"/>
    <updated>2014-07-19T14:34:00+08:00</updated>
    <id>http://cxh.me/2014/07/19/continent</id>
    <content type="html"><![CDATA[<p><embed src="http://player.video.qiyi.com/df60feaccd8d18df45ae5f84d10fd39e/0/0/w_19rsfwiyk1.swf-albumId=2338708509-tvId=2338708509-isPurchase=0-cnId=5" allowFullScreen="true" quality="high" width="480" height="350" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<ul>
<li>当一艘船沉入海底</li>
<li>当一个人成了谜</li>
<li>你不知道</li>
<li>他们为何离去</li>
<li>那声再见竟是他最后的一句</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c/c++的不定参数]]></title>
    <link href="http://cxh.me/2014/07/17/c-variable-argument/"/>
    <updated>2014-07-17T14:42:00+08:00</updated>
    <id>http://cxh.me/2014/07/17/c-variable-argument</id>
    <content type="html"><![CDATA[<p>  c/c++可以通过va_arg等宏实现不定参数。一个例子如下(c++)：</p>

<pre><code>void ar_cnt(int cnt,...);
int main(int argc, char* argv[])
{
    ar_cnt(4,1,2,3,4);
    return 0; 
}
void ar_cnt(int cnt,...)
{
    int arg_cnt = cnt;
    va_list arg_ptr;
    va_start(arg_ptr, cnt);
    for(int i=0; i &lt; cnt;i++)
    {
        int value=va_arg(arg_ptr,int);
        printf("posation %d=%d\n", value, i+1);
    }
    va_end(arg_ptr);
}
</code></pre>

<p>  其实原理是比较简单的，依赖于编译器对函数调用的压栈顺序，但是目测现有的调用方式压栈都是从右向左，所以va_start定位第一个参数的位置，va_arg每次在之前的位置上加一个偏移值，从而得到每个传入参数。这就是说va_start要求传入不定参数的函数不能只传入一个&hellip;，至少要有一个固定的参数，用来获取栈指针位置。</p>

<!--more-->


<p>  调用方式这个东西好像只有在VC里才探讨，不太清楚gcc这里的处理是怎么样的，vc下主要分了如下几种：</p>

<ul>
<li><p>STDCALL/PASCAL/WINAPI/CALLBACK</p>

<ol>
<li>参数从右向左压入堆栈</li>
<li>函数自身修改堆栈</li>
<li>函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li>
</ol>
</li>
<li><p>CDECL</p>

<ol>
<li>调用约定的参数压栈顺序是和stdcall是一样的，参数由右向左压入堆栈。</li>
<li>调用者负责清理堆栈。</li>
<li>由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。</li>
</ol>
</li>
<li><p>FASTCALL</p>

<ol>
<li>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</li>
<li>被调用函数清理堆栈</li>
<li>函数名修改规则同stdcall</li>
</ol>
</li>
<li><p>THISCALL</p>

<ol>
<li>参数从右向左入栈</li>
<li>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li>
</ol>
</li>
<li><p>NAKEDCALL</p>

<ol>
<li>这是一个很少见的调用约定，一般程序设计者建议不要使用。</li>
<li>编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果</li>
<li>这一般用于实模式驱动程序设计</li>
</ol>
</li>
</ul>


<h3>参考文献:</h3>

<blockquote><p>[1] cdecl、stdcall、fastcall函数调用约定区别 , <a href="http://blog.csdn.net/fly2k5/article/details/544112">http://blog.csdn.net/fly2k5/article/details/544112</a></p>

<p>[2] 函数调用的区别：<em>cdecl以及</em>stdcall, <a href="http://www.cppblog.com/kenny/archive/2011/04/19/144539.html">http://www.cppblog.com/kenny/archive/2011/04/19/144539.html</a></p>

<p>[3] 透析C语言可变参数问题, <a href="http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html">http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java/c++变量作用域的一点小区别]]></title>
    <link href="http://cxh.me/2014/07/17/java-c-plus-plus-variable-scope-diff/"/>
    <updated>2014-07-17T11:16:00+08:00</updated>
    <id>http://cxh.me/2014/07/17/java-c-plus-plus-variable-scope-diff</id>
    <content type="html"><![CDATA[<p>  偶然遇到一个问题，java里面这么写是有问题的</p>

<pre><code>int x = 1;
    {
        int x = 2;
    }
</code></pre>

<p>  作为一个写了多年C++的人，不能忍啊。java子域里的变量看样子不会覆盖父域。但是这样是没问题的，可见子域的生命周期还是局限于子域里面。</p>

<pre><code>    {
        int x = 2;
    }
int x = 1;
</code></pre>

<p>  C++里面这样是没问题的</p>

<pre><code>  int x = 1 ;
  {
    int x  = 2;
  }
</code></pre>

<p>  相对于脚本语言，这种限制似乎就宽多了。这样都可以。</p>

<pre><code>for i in range(1,10):
    pass
print i
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ich war noch niemals in New York]]></title>
    <link href="http://cxh.me/2014/07/16/ich-war-noch-niemals-in-new-york/"/>
    <updated>2014-07-16T20:27:00+08:00</updated>
    <id>http://cxh.me/2014/07/16/ich-war-noch-niemals-in-new-york</id>
    <content type="html"><![CDATA[<p><embed src="http://player.youku.com/player.php/Type/Folder/Fid/22542683/Ob/1/sid/XMTgzNjkyMzA0/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"></embed></p>

<hr />

<ul>
<li>我从来没有去过纽约</li>
<li>从没有到过夏威夷</li>
<li>从未穿过牛仔衣淋着旧金山的雨</li>
<li>我从来没有去过纽约</li>
<li>我要感受那远方的空气</li>
<li>我想要挣脱过去释放我自己</li>
</ul>


<!--more-->


<p>  还有老男孩翻唱版的</p>

<p><embed src="http://player.youku.com/player.php/Type/Folder/Fid/22542683/Ob/1/sid/XNzQxNTIyNDk2/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"></embed></p>

<hr />

<p>  人生很搞，梦想不老</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[命名空间和友元冲突]]></title>
    <link href="http://cxh.me/2014/07/10/namespace-conflicts-with-friend/"/>
    <updated>2014-07-10T19:09:00+08:00</updated>
    <id>http://cxh.me/2014/07/10/namespace-conflicts-with-friend</id>
    <content type="html"><![CDATA[<p>  今天遇到一个问题，需要跨namespace定义友元，这种情况比较常见的是测试类需要访问源码类，gtest据说有个FRIEND_TEST宏，以前用过好像有问题。这里我们直接用友元:</p>

<pre><code>namespace oceanbase
{
    namespace election
    {
        class ObElectionServer : public ObSingleServer
        {
            friend class ObElectionTester;
            ...
        }
    }
}
namespace oceanbase
{
  namespace tests
  {
    namespace election
    {
        class ObElectionTester : public ObElectionServer
        {
            ...
        }
    }
}
</code></pre>

<p>  这样是肯定不行的，这等于告诉ObElectionServer在自己的namespace下找ObElectionTester。改成如下：</p>

<!--more-->


<pre><code>namespace oceanbase
{
    namespace election
    {
        class ObElectionServer : public ObSingleServer
        {
            friend class oceanbase::tests::election::ObElectionTester;
            ...
        }
    }
}
</code></pre>

<p>  这样也不行，ObElectionServer不知道ObElectionTester是个包含namespace的类名。所以我们需要前向声明一下类。</p>

<pre><code>namespace oceanbase
{
  namespace tests
  {
    namespace election
    {
      class ObElectionTester;
    }
  }
  namespace election
  {
    class ObElectionServer : public ObSingleServer
    {
        friend class oceanbase::tests::election::ObElectionTester;
        ....
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[呵呵呵呵以至于我不得不开篇博客说这个事情]]></title>
    <link href="http://cxh.me/2014/07/08/im/"/>
    <updated>2014-07-08T09:55:00+08:00</updated>
    <id>http://cxh.me/2014/07/08/im</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="http://cxh.me/images/2014/smartisan.png"></p>

<p>  话说变形金刚四中国版里面植入广告已经超越春晚了，就是没找到周黑鸭哪里去了&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两阶段提交协议的异常处理]]></title>
    <link href="http://cxh.me/2014/07/07/two-process-commit-exceptions/"/>
    <updated>2014-07-07T11:57:00+08:00</updated>
    <id>http://cxh.me/2014/07/07/two-process-commit-exceptions</id>
    <content type="html"><![CDATA[<p>  两阶段提交的协议大家都比较熟悉了，解释一下每个阶段的异常处理。首先，我们需要持久化协议过程中的状态，这样如果server宕机，那么恢复的时候还能通过日志知道宕机前处于那个阶段。同时，所有对数据的修改都会先写write ahead log，保证宕机重启的之后数据也不会丢失。写日志的顺序假定为:写write ahead log-修改缓冲区-写commit/abort log。</p>

<p>  在这个前提下，我们根据如下的时序图来讨论异常情况和处理方法。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/2pc.png" title="两阶段提交协议时序" alt="两阶段提交协议时序"><p class="align-center">两阶段提交协议时序</p></p>

<ol>
<li><p> 过程a没有成功，即协调者没有收到部分参与者的回应。超时后，协调者发送abort消息给参与者取消事务。参与者存在两种情况：</p>

<ul>
<li>过程1失败，网络问题导致参与者没有收到vote request消息或者此时参与者宕机。参与者重启恢复后无需做任何事。</li>
<li>过程2失败，参与者收到了vote request，网络问题协调者没有收到回复或此时参与者宕机。参与者宕机恢复或等待超时后广播DECISION_REQUEST消息向其他参与者询问是否收到commit/abort消息。</li>
</ul>
</li>
<li><p> 过程b没有成功，即协调者发送commit消息之后没有收到部分参与者的回应。协调者需要重试，确认参与者的提交完毕消息，如果多次尝试不能联系上，则等待参与者上线之后解决。参与者存在两种情况：</p>

<ul>
<li>过程3失败，网络问题导致参与者没有收到commit消息或此时参与者宕机。参与者上线发现在本地日志中发现尚未提交成功，因为到达这里，可以肯定本地已做好提交准备，但是不知道协调者是决定提交，所以向协调者询问，按协调者的回复来进行提交或回滚。如果无法联系上协调者，则向其他参与者询问事务状态，如果有某一个节点已经做了提交或异常终止(说明协调者已发送了相关消息)，则做同样的操作。</li>
<li>过程4失败，参与者完成了commit/rollback，但是网络问题协调者没有收到回应或者此时参与者宕机。参与者在本地日志中发现已完成本地提交，所以可能由于网络故障导致提交完成消息没有到达协调者。所以直接忽略。这时可能协调者在等待该参与者的提交完成回应消息，所以参与者主动联系协调者告知事务状态。</li>
</ul>
</li>
<li><p> 过程c没有成功，即参与者发送vote回应消息之后没有等到协调者的commit/rollback消息。这个过程参与者的异常处理已经讨论过了，这里讨论协调者的异常处理。存在两种情况：</p>

<ul>
<li>过程2失败，网络问题导致协调者没有收到回复或此时协调者宕机。协调者恢复重启后，发现并未做提交操作，保险操作(因为不知道它是否发送过准备消息，或其他参与者是否做好提交准备)，直接发送abort消息给所有参与者，终止事务</li>
<li>过程3失败，网络问题导致参与者没有收到commit/rollback消息或者此时协调者宕机。协调者恢复重启后，不能保证所有参与者都已收到了提交消息，所以给所有的参与者发送commit消息，保证事务的正常提交。</li>
</ul>
</li>
</ol>


<!--more-->


<p>  算法的伪代码可以参考如下代码，摘自《Distributed Systems: Principles and Paradigms》。</p>

<p>  <strong>Actions of Coordinator</strong></p>

<pre><code>write("START_2PC tolocal log");
multicast("VOTE_REQUESTto all participants");
while(not all votes have been collected)
{
  waitfor("any incoming vote");
  if(timeout)
  {
    write("GLOBAL_ABORT to local host");
    multicast("GLOBAL_ABORT to all participants");
    exit();
  }
  record(vote);
}
if(all participants send VOTE_COMMIT and coordinatorvotes COMMIT)
{
  write("GLOBAL_COMMIT to local log");
  multicast("GLOBAL_COMMIT to all participants");
}
else
{
  write("GLOBAL_ABORT to local log");
  multicast("GLOBAL_ABORT to all participants");
}

**Actions of Participants**

write("INIT to locallog");
waitfor("VOTE_REQUESTfrom coordinator");
if(timeout)
{
  write("VOTE_ABORT to local log");
  exit();
}
if("participantvotes COMMIT")
{
  write("VOTE_COMMIT to local log");
  send("VOTE_COMMIT to coordinator");
  waitfor("DESCISION from coordinator");
  if(timeout)
  {
    multicast("DECISION_REQUEST to other participants");
    waituntil("DECISION is received"); /// remain blocked
    write("DECISION to local log");
  }
  if(DECISION == "GLOBAL_COMMIT")
  {
    write("GLOBAL_COMMIT to local log");
  }
  else if(DECISION== "GLOBAL_ABORT")
  {
    write("GLOBAL_ABORT to local log");
  }
}
else
{
    write("GLOBAL_ABORT to local log");
    send("GLOBAL_ABORT to coordinator");
}
</code></pre>

<h3>参考文献:</h3>

<blockquote><p>[1] 两阶段提交(2PC)协议, <a href="http://blog.chinaunix.net/uid-20761674-id-75164.html">http://blog.chinaunix.net/uid-20761674-id-75164.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发一张喵星人的照片]]></title>
    <link href="http://cxh.me/2014/07/06/photo-of-cat/"/>
    <updated>2014-07-06T18:18:00+08:00</updated>
    <id>http://cxh.me/2014/07/06/photo-of-cat</id>
    <content type="html"><![CDATA[<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/cat.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[undo 日志和redo 日志]]></title>
    <link href="http://cxh.me/2014/07/05/redo-undo-log/"/>
    <updated>2014-07-05T21:20:00+08:00</updated>
    <id>http://cxh.me/2014/07/05/redo-undo-log</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="http://cxh.me/images/2014/interesting.gif" title="贴张图" alt="贴张图"><p class="align-center">贴张图</p></p>

<p>  具体的可以看<a href="http://blog.csdn.net/ggxxkkll/article/details/7616739" title="数据库日志文件-- undo log 、redo log、 undo/redo log">这里</a>，解释几个作者没解释清楚的问题：</p>

<ol>
<li><p>只用REDO日志为什么数据修改要每次修改刷盘</p>

<p> 如果不刷盘，不会导致数据不一致，但是数据修改过程相当于写redo日志-修改内存-写commit日志（修改内存的顺序也无所谓了），这个过程结束已经应答用户了，但是修改没有刷下去断电恢复的话也无法通过redolog恢复到当前状态，所以会丢失修改。</p></li>
<li><p>修改数据和写redo/undo log/commit log之间的关系是什么</p>

<p> 任何对磁盘的数据修改落实之前都需要先写log，无论是redo还是undo。undo保证了一旦数据写了一半（脏数据）能够回滚，redo保证了写了日志的事务能够回放出来。</p>

<p> 只使用undo的时候commit日志要等待刷盘成功，写了commit的事务不会再回滚。</p>

<p> 只使用redo的时候需要先写commit日志再修改缓冲区，因为数据有刷盘和不刷盘的可能，写完commit日志意味着修改已经完整记录下来了不会丢失。否则，没有commit的日志不会回放，如果之前修改数据并刷盘了，系统不知道处于哪个阶段：写了一半的log？写成功log?修改了一半数据？成功修改全部数据？。<del>如果修改不刷盘，那么如果在修改数据阶段宕机，就丢失了此条本来可以写成功的数据，好在这时候也没有回复用户。</del>确保数据不刷盘的情况下，是可以先修改缓冲区再写commit日志的。</p>

<p> <del>其实redo log + commit log写成功就可以回复用户了啊，异步修改数据好了。至少能保证不丢失。不过万一修改失败了或者这时候有读取怎么办&hellip;</del></p></li>
<li><p>只使用redo日志的时候checkpoint为什么不能直接刷盘</p>

<p> 如果只使用redo日志，而且修改顺序是写redo日志-写commit日志-修改缓冲区，那么缓冲区是可以在checkpoint的时候刷下去的，因为下次回放的时候已经有了redo日志和commit标记，可以回放覆盖之前的脏数据，问题在于如果这个事务被回滚了，只有redo日志是不能做回滚操作的。如果使用redo-undo log那么可以直接把脏数据刷盘。</p></li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] 数据库日志文件&mdash; undo log 、redo log、 undo/redo log, <a href="http://blog.csdn.net/ggxxkkll/article/details/7616739">http://blog.csdn.net/ggxxkkll/article/details/7616739</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发两张静物]]></title>
    <link href="http://cxh.me/2014/07/05/two-photo-of-still-life/"/>
    <updated>2014-07-05T19:49:00+08:00</updated>
    <id>http://cxh.me/2014/07/05/two-photo-of-still-life</id>
    <content type="html"><![CDATA[<p>  发两张静物，镜头宾得 SMC FA 50mm F1.4</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/grass.jpg"></p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/windmill.jpg"></p>

<p>  转一张网上的图，我觉得拍的极好（当然模特漂亮是主要的）：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/fromweb.jpg"></p>
]]></content>
  </entry>
  
</feed>
