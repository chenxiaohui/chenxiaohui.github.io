<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-08-28T18:04:41+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[paxos的一些case分析]]></title>
    <link href="http://cxh.me/2015/08/28/paxos-case-analysis/"/>
    <updated>2015-08-28T11:34:00+08:00</updated>
    <id>http://cxh.me/2015/08/28/paxos-case-analysis</id>
    <content type="html"><![CDATA[<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gitbook使用指导]]></title>
    <link href="http://cxh.me/2015/08/23/gitbook-guide/"/>
    <updated>2015-08-23T16:23:00+08:00</updated>
    <id>http://cxh.me/2015/08/23/gitbook-guide</id>
    <content type="html"><![CDATA[<p>  gitbook是nodejs实现的用来帮助书写电子书的，很多开源的书籍项目是基于gitbook的。gitbook的编写语言是markdown，书籍遵循一定的格式完成之后可以通过gitbook发布为各种版本，比如pdf，mobi等电子书格式，或者发布为静态的website，挂到github pages上，对于一些开源项目来说，这是很方便的书写帮助文档的方式。gitbook同样有一个<a href="https://www.gitbook.com/" title="A modern publishing toolchain. Simply taking you from ideas to finished, polished books.">paas的平台</a>，可以允许多人协作在线完成一部电子书</p>

<p>  首先安装gitbook</p>

<pre><code>npm -g install gitbook
npm -g install gitbook-cli
npm -g install ebook-convert
</code></pre>

<p>  第三个是安装生成电子书的插件，但是这里并不会安装bin文件，需要手动安装<a href="http://calibre-ebook.com/" title="calibre: The one stop solution for all your e-book needs. Comprehensive e-book software.">Calibre</a>。Mac下可以安装Calibre的app然后链接一下bin：</p>

<pre><code>ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin
</code></pre>

<p>  这样就可以生成pdf/mobi等格式的电子书了。</p>

<p>  使用方式可以通过gitbook help来查看。主要是如下几个：</p>

<pre><code>gitbook build [book] [output]   生成电子书，通过--format指定输出格式，默认输出为website
gitbook pdf [book] [output]     生成pdf电子书
gitbook epub [book] [output]    生成epub电子书
gitbook mobi [book] [output]    生成mobi电子书
serve [book]                    生成并开启http server预览
init [directory]                根据summary建立基本目录结构
install [book]                  安装依赖和插件
</code></pre>

<p>  Summary的基本样子见这里：</p>

<pre><code># Summary
* [Introduction](README.md)
* [入门](getting_started/README.md)
   * [初识](getting_started/what_is_it.md)
   * [安装](getting_started/installing_es.md)
   * [API](getting_started/api.md)
   * [文档](getting_started/document.md)
   * [索引](getting_started/tutorial_indexing.md)
   * [搜索](getting_started/tutorial_search.md)
   * [汇总](getting_started/tutorial_aggregations.md)
   * [小结](getting_started/tutorial_conclusion.md)
   * [分布式](getting_started/distributed.md)
   * [本章总结](getting_started/conclusion.md)
* [分布式集群](distributed_cluster/README.md)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工作周年总结]]></title>
    <link href="http://cxh.me/2015/08/07/work-anniversary-note/"/>
    <updated>2015-08-07T15:50:00+08:00</updated>
    <id>http://cxh.me/2015/08/07/work-anniversary-note</id>
    <content type="html"><![CDATA[<p>  工作两周年了，感觉这两年走了不少弯路，也学到不少东西，最近看到日照的<a href="http://www.nosqlnotes.net/archives/128" title="2010年度总结">周年总结</a>，觉得也应该写写。而且看看日照当时的情况，觉得跟我现在也差不多，同样处在职业的选择期，一个明确的规划还是很重要的。</p>

<h3>总结</h3>

<p>  2013年进入支付宝Oceanbase组，待了一年半的时间吧，第一年主要在0.5上修修改改，第二年换到了UPS组，参与1.0的设计。从第一年的情况看，基本是完成了一个不错的职业素养培训，有了分布式的基本概念，处于了解熟悉的阶段。第二年开始对分布式协议有了一些认识，算是入门了吧。总结两年还是学到了一些东西，但是也算是付出了一些代价。出来之后看之前的组，觉得对应届生还是个不错的选择，ob有点像一个学校，闲的时候有不错的学习机会，就是加班太多了。</p>

<p>  后来身体原因离职，来搜狐大数据中心，开始做推荐系统相关的东西。从那个时候想做算法，搞了半年多吧，有些了解，不算入门，大概处于这样一个状态。对我来说，兴趣总归是第一位的，然而在一个方向上有所积累更重要。这样容易过了几年发现什么都会点什么都不精通。互联网发展这么快，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log4cxx安装]]></title>
    <link href="http://cxh.me/2015/07/30/log4cxx-setup/"/>
    <updated>2015-07-30T15:55:00+08:00</updated>
    <id>http://cxh.me/2015/07/30/log4cxx-setup</id>
    <content type="html"><![CDATA[<p>  log4cxx是apache基金会的log开源项目，log4j的c++实现，安装的时候遇到一个小问题：</p>

<p>  首先正常安装：</p>

<pre><code>wget http://mirrors.cnnic.cn/apache/logging/log4cxx/0.10.0/apache-log4cxx-0.10.0.tar.gz
tar zxvf apache-log4cxx-0.10.0.tar.gz
cd apache-log4cxx-0.10.0
./configure
make
</code></pre>

<p>   报错libdb-4.3.so 格式错误。开始以为是文件损坏了，查了一下这个文件</p>

<pre><code>yum provides */libdb-4.3.so
</code></pre>

<p>   提示在db4里面，重新安装db4</p>

<pre><code>yum reinstall db4
</code></pre>

<p>   回去还是报错。后来看了一下格式，貌似链接到了32位版本。修改软连接：</p>

<pre><code>cd /usr/lib/
rm libdb-4.3.so
ln -s ../../lib64/libdb-4.3.so .
</code></pre>

<p>   同样处理另外一个库</p>

<pre><code>rm libexpat.so
ln -s ../../lib64/libexpat.so.0.5.0 libexpat.so
</code></pre>

<p>   应该就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于group commit]]></title>
    <link href="http://cxh.me/2015/07/29/group-commit/"/>
    <updated>2015-07-29T17:25:00+08:00</updated>
    <id>http://cxh.me/2015/07/29/group-commit</id>
    <content type="html"><![CDATA[<p>  最近突然想到这个东西，以前Oceanbase的UpdateServer提交的时候是做了group commit的。基本思路如下：</p>

<ol>
<li> 并发小的时候，超过一个时间窗口就直接提交</li>
<li> 并发大的时候，等请求填满一个buffer再一起提交。</li>
</ol>


<p>  实现上可以考虑如下伪代码：</p>

<pre><code>while true:
    start timer
    if buffer full or timer reach limit:
        commit
        reset timer
    else
        wait and receive
</code></pre>

<p>  广泛运用在一些需要组合请求的地方，比如一些rpc因为历史原因（嗯）一直单条请求，不能改协议的情况下，可以考虑转发一下，做个缓冲。当然这种情况下一般是通过队列来缓冲请求压力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[带小团队的一点思考]]></title>
    <link href="http://cxh.me/2015/07/28/something-about-guide-a-team/"/>
    <updated>2015-07-28T13:56:00+08:00</updated>
    <id>http://cxh.me/2015/07/28/something-about-guide-a-team</id>
    <content type="html"><![CDATA[<p>  事实上我也只是带实习生而已。但是感觉上之前更多的是把自己的任务分出去，而现在是开始跟一些人一起完成一个任务。主要的不同是之前做的事情是在个人工作量里面，自己做也只是慢一点，有时候甚至自己做反倒比分出去更快。现在做的事情已经超过一个人工作量了，必须发挥团队的能动性了，而且之前也只是对自己的工作负责，现在你要负责的是一个团队的KPI了。</p>

<p>  主要有几点感觉：</p>

<ol>
<li> 分配好工作。需要能力的，需要经验的，需要稳定细心的，每个人的风格不一样，应该做的工作也不一样。</li>
<li> 规范流程。大部分加班或者事故都是能从流程上避免的，在设计开发测试上省下来的时间最终都会在上线修bug处理问题的过程中补回来。</li>
<li> 做好计划和项目管理。做一个包含不确定性和风险的事情最重要的是路线图。实现的过程就是把抽象的东西一点点具象化的过程。所以计划上要能够自顶向下，逐步求精。把写程序的思路用进来。</li>
<li> 最后就是能力的问题了。统筹考虑是种需要一点点培养的能力。这个也就只能慢慢来了。何况只要不是纯做管理，你就一定有自己的工作，自己的KPI，协调好自己工作和他人工作安排的关系，还是非常重要的。</li>
</ol>


<p>  最后补一个我理解的开发流程图：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/dev-flow.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过父子关系构建话题树]]></title>
    <link href="http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation/"/>
    <updated>2015-07-18T11:35:00+08:00</updated>
    <id>http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation</id>
    <content type="html"><![CDATA[<p>  一道题目，本来觉得挺简单的，后来卡在一个小问题上。mark一下：</p>

<p>  给定一个数据库表，存了所有话题的关系，形式是：parent->child，表示前面是后面话题的父话题。根据这个关系构建出话题树并打印。</p>

<pre><code>eg:
输入：
    a b
    c a
    d e
    e f
    r c
    r d
输出：
     r
       c
         a
           b
       d
         e
           f
题目隐含：
    1. DAG：有向无环
    2. 节点不重复
</code></pre>

<p>  直观看类似于Graphviz的算法，只不过保证了是棵树。C++实现上可以直接通过树来做，这里用了Python。</p>

<!--more-->


<p>  思路上先找到父节点，再找到子节点，如果都找到，那么移动子节点到父节点下形成一个新的成员，如果父节点没找到，让其成为root节点（加一个叫root的dummynode，反正是话题，我们保证这个话题是保留字）的子节点，如果子节点没找到，让其形成一个新的空节点。</p>

<p>  Python下数据结构类似于：</p>

<pre><code>ret = {
    "root": {
        "r": {
            "c": {
                "a":{
                    "b":{}
                    },
            },
            "d":{
                "e":{
                    "f":{}
                }
            }
        }
    }
}
</code></pre>

<p>  叶节点都保留了一个空的子节点集合。</p>

<p>  代码如下：</p>

<pre><code>default_indent = 2
filename='topic'

def print_result(tree, indent):
    """"""
    for key, value in tree.items():
       if key:
           print ' ' * indent, key
       if value:
           print_result(value, indent + default_indent)


def find_node(tree, element):
    """"""
    for key, value in tree.items():
        if key == element:
            return tree, tree[key]
        elif value:
            parent, child = find_node(value, element)
            if parent:
                return parent, child
    return None, None

def parse_file(ret, fp):
    """"""
    for pair in fp:
        pair = pair.strip("\n")
        if pair:
            parent, child = pair.split()
            _, parent_element = find_node(ret, parent)
            child_parent, child_element = find_node(ret, child)

            if parent_element == None:
                ret["root"][parent] = {}
                parent_element = ret["root"][parent]
            if child_element == None:
                child_element = {}

            parent_element[child] = child_element
            if child_parent:
                del child_parent[child]

if __name__ == '__main__':
    ret = {"root":{}}
    try:
        with open(filename, 'r') as fp:
            parse_file(ret, fp)
    except Exception:
        raise

    print_result(ret['root'], 0)
</code></pre>

<p>  之前出的错误是：</p>

<ol>
<li>python毕竟是引用计数，把一个节点变成另外一个节点的子节点的时候忘了remove旧的节点</li>
<li>深度优先搜索找节点的时候直接return find_node(xxx)了，这样的话深度完一个子节点，不会再继续本层循环了。这个也是大意了，随手一测这个find_node函数就没再看。</li>
</ol>


<p>  性能提升的办法主要是：</p>

<ol>
<li>hash一下所有的节点。把遍历查找的复杂度降下来</li>
<li>先排序（按照parent)，然后把reduce，这样会先把相同的部分生成一个集合，比如a:[b,c,d]这种。</li>
</ol>


<p><strong>事实上，这个题目可以直接用邻接表表示数据结构，然后DFS来打印就好了&hellip;</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phibricator搭建过程总结]]></title>
    <link href="http://cxh.me/2015/07/07/phibricator-setup/"/>
    <updated>2015-07-07T17:45:00+08:00</updated>
    <id>http://cxh.me/2015/07/07/phibricator-setup</id>
    <content type="html"><![CDATA[<p>  <a href="http://phabricator.org/" title="Phibricator官网">Phibricator</a>是Facebook开源的一体化项目管理、代码review工具，主要特点是集成度高、界面漂亮。根据搭建的经验看，确实做的非常完善，各种细节用起来像是商业产品，不会像其他的开源产品那么难以配置。这里把配置过程根据回忆写一下：</p>

<p>  官方给出过一个一键安装的脚本，但是下载的时候感觉有点问题吧，下载完不是sh而是网页，而且我只有一台机器，环境都已经预先有了，也不想再搭一套LAMP。这里我们以centos5为例：</p>

<p>  首先安装httpd + mysql + php，由于centos5的版本太低，yum源里的mysql和php均低于phibricator要求的版本，我们需要先升级yum源，参见<a href="http://zengrong.net/post/1595.htm" title="升级CentOS 5.x中的PHP 5.1到5.3">参考文献</a>， 不过好像安装的时候没有php53u，而是直接php53</p>

<p>  之后把对应的扩展也装了:</p>

<pre><code>yum install php53-mbstring
yum install php53-mysql
</code></pre>

<!--more-->


<p>  升级mysql到mysql5.5，参见<a href="http://www.ha97.com/4145.html" title="RHEL/CentOS 5.x使用yum快速安装MySQL 5.5.x">参考文献</a>。中间遇到两个问题:</p>

<ol>
<li><p>mysql 启动失败，提示没有权限创建pid。su到mysql用户下发现/var/run目录mysql用户没有execute的权限：</p>

<p> usermod +x /var/run</p>

<p> 给目录加execute的权限</p></li>
<li><p>mysql_upgrade失败，直接提示FATAL ERROR:Upgrade failed，发现用户名密码的问题，root@localhost密码没变，root@127.0.0.1在升级之后好像没有密码了</p>

<p> SET PASSWORD FOR &lsquo;root&rsquo;@&lsquo;127.0.0.1&rsquo; = PASSWORD(&lsquo;newpass&rsquo;);</p>

<p> 重新设置密码。</p></li>
</ol>


<p>  之后去/var/www/html安装源码:</p>

<pre><code>$ git clone https://github.com/phacility/libphutil.git
$ git clone https://github.com/phacility/arcanist.git
$ git clone https://github.com/phacility/phabricator.git
</code></pre>

<p>  顺便装上一些别的php扩展：</p>

<pre><code>sudo yum install pcre-devel
sudo yum install php-pear
sudo yum install php53-process
sudo pecl install apc
</code></pre>

<p>  主要是提升性能的。然后配置httpd.conf</p>

<pre><code>&lt;VirtualHost *&gt;
  # Change this to the domain which points to your host.
  ServerName phabricator.example.com

  # Change this to the path where you put 'phabricator' when you checked it
  # out from GitHub when following the Installation Guide.
  #
  # Make sure you include "/webroot" at the end!
  DocumentRoot /path/to/phabricator/webroot

  RewriteEngine on
  RewriteRule ^/rsrc/(.*)     -                       [L,QSA]
  RewriteRule ^/favicon.ico   -                       [L,QSA]
  RewriteRule ^(.*)$          /index.php?__path__=$1  [B,L,QSA]
&lt;/VirtualHost&gt;
</code></pre>

<p>  最后一个Rule的B在我的httpd下不识别，所以直接去掉了，貌似没什么影响&hellip;重启之后到phibricator的源码目录执行：</p>

<pre><code>phabricator/ $ ./bin/storage upgrade
</code></pre>

<p>  按照提示可以配置mysql 用户名密码，之后可以看到建立了数据库结构。这时候访问host就能看到界面了。先注册管理员进去，能够看到一系列的TIPs，说明需要配置的地方。Phibricator在这方面非常人性化，按照提示一点点配置就可以了。直到解决大部分的warning。剩下的问题就是注册用户和邮件了。</p>

<p>  首先在auth上开启认证方式，这里我们还是比较传统，选择了用户名密码的方式，你也可以选择其他账号体系打通的方式。一个用户注册之后，管理员需要批准用户，这个用户才能登陆。我找了好久，才发现原来批准在这位置：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/approval-queue.png"></p>

<p>  最后是配置邮件服务器。首先你需要有个本地的或者其他提供商提供的邮件服务器。可以参考<a href="http://blog.csdn.net/lihongxun945/article/details/9030753" title="phabricator 邮件服务配置 备忘">这里</a>，PHP Mailer设置：</p>

<pre><code>phpmailer.mailer: set to "smtp".
phpmailer.smtp-host: smtp.xxx.com
phpmailer.smtp-port: 25
phpmailer.smtp-user: xxxx
phpmailer.smtp-password: xxxx
</code></pre>

<p>  之后重启daemon应该就能发送邮件了。删除用户非常有意思，ph只允许从命令行删除</p>

<pre><code>phabricator/ $ ./bin/remove destroy @harrychen
</code></pre>

<p>  之后会有一个有意思的界面：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/delete-user.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简历生成器（基于moderncv+latex）]]></title>
    <link href="http://cxh.me/2015/06/26/resume-generator-using-latex-and-moderncv/"/>
    <updated>2015-06-26T15:47:00+08:00</updated>
    <id>http://cxh.me/2015/06/26/resume-generator-using-latex-and-moderncv</id>
    <content type="html"><![CDATA[<p>项目地址: <a href="https://github.com/chenxiaohui/resume">https://github.com/chenxiaohui/resume</a></p>

<h3>说明</h3>

<p>  通过文本文件生成简历tex的generator。最终生成pdf还是要靠Latex+Moderncv，环境请自行配置。</p>

<ul>
<li>windows下：<a href="http://www.ctex.org/HomePage">http://www.ctex.org/HomePage</a></li>
<li>Linux下：<a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></li>
<li><p>Mac下：<a href="https://tug.org/mactex/">https://tug.org/mactex/</a></p>

<p>需要的包都通过sudo tlmgr install package来安装。字体主要使用了Times New Roman（西文）和 Kaiti SC（中文）。可根据喜好换。</p></li>
</ul>


<h3>模板配置</h3>

<p>  config.tex 定义了公共头文件，包括包含的宏包，版面的布置和字体语言。</p>

<p>  xxtemplate.tex定义了模板。模板语法比较简单，不给出严谨的语法定义了，主要如下两点：</p>

<ol>
<li>%xxx% 表示一个变量，将来会从cv文件中查找对应名字的变量，找到之后替换这个%xxx%</li>
<li><p>%for=>xx% %endfor%表示一个循环，xx是section的name，将来会从cv文件中找到对应的section，然后parse section下的每个单独的项目，用结果替换for循环中的内容</p>

<ol>
<li>for循环中{0}{1}..表示一个for循环变量，cv中section下的条目会被分割成多个变量，顺序依次是0，1，2..，渲染的时候会对应的替换上述{0}{1}变量。如果数量不匹配会报错。</li>
</ol>
</li>
<li><p>如上语法部分关键字可以配置，在config.py中。可以酌情修改。</p></li>
</ol>


<p>  xx.cv包含了简历内容，格式上参考了ini文件格式，但是略有不同。</p>

<ol>
<li>[section name]顶一个了一个section，对应简历中一个部分。section name的显示名称是在template里面写好的。这里的name只是给程序使用的，可以跟显示名称一致也可以不同。</li>
<li>不包含在某个section下的条目通过 key = value的方式定义。不能跨行，程序parse的时候只找第一个等号，后面有空格等符号都不影响。</li>
<li>section下的条目每条可以包含多个字段，字段之间默认用竖线（|）分割（可修改）。字段的数量需要跟模板中对应section下for循环体中变量的数量一致。</li>
</ol>


<p>  程序中给出了几个实例，分别是英文、中文简历的template和cv文件，供参考。</p>

<h3>使用</h3>

<p>  写好对应的cv和模板之后，make就行。open命令可能在mac之外的系统不能使用，建议注掉。</p>

<p>  make distclean清空所有文件包括pdf</p>

<p>  make again 是为了生成页码，xelatex跑第一遍的时候页码是乱码。</p>

<p>  gen.py 文件格式如下：</p>

<pre><code>./gen.py &lt;template-file&gt; &lt;cvfile&gt; &lt;output-file&gt;
</code></pre>

<h3>参考文献:</h3>

<p>  [1] http moderncv 的笔记（支持中文）, <a href="http://www.xiangsun.org/tex/notes-on-moderncv">http://www.xiangsun.org/tex/notes-on-moderncv</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于zookeeper的配置管理客户端]]></title>
    <link href="http://cxh.me/2015/06/16/sohu-zk-client-document/"/>
    <updated>2015-06-16T16:28:00+08:00</updated>
    <id>http://cxh.me/2015/06/16/sohu-zk-client-document</id>
    <content type="html"><![CDATA[<h3>名词解释：</h3>

<p>  SeviceConfig:</p>

<pre><code>一个服务的所有配置存在一个目录下
</code></pre>

<p>  BucketConfig:</p>

<pre><code> Bucket的配置存在一个单独的子目录中
</code></pre>

<h3>配置项类型：</h3>

<ul>
<li>Integer</li>
<li>Long</li>
<li>Short</li>
<li>Float</li>
<li>Double</li>
<li>Byte[]</li>
<li>Boolean</li>
<li>String</li>
<li>自定义配置项 ConfigObject</li>
</ul>


<h3>使用说明：</h3>

<h4>POM：</h4>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.sohu.adrd&lt;/groupId&gt;
  &lt;artifactId&gt;sohu-zk-client&lt;/artifactId&gt;
  &lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h4>初始化</h4>

<p>  ServiceConfig.Instance().init(&ldquo;ConnectString&rdquo;, &ldquo;serviceName&rdquo;);//如果做测试可以用10.16.3.61:2181</p>

<p>  ServiceConfig.Instance().init(&ldquo;serviceName&rdquo;); 默认使用肖永磊的zk地址</p>

<h4>配置项使用</h4>

<p>  先给默认值</p>

<pre><code>private static long exploitDiscardTimespan = 7 * 86400L;
</code></pre>

<p>  可以保存个Instance()的引用</p>

<pre><code>private ServiceConfig serviceConfig = ServiceConfig.Instance();
</code></pre>

<p>  所有引用到的地方，通过如下方式取配置项（这是默认config）：</p>

<p>   serviceConfig.getLong(&ldquo;exploitDiscardTimespan&rdquo;, exploitDiscardTimespan)</p>

<p>  如果是BucketConfig(bucketConfig会在zookeeper上根目录下再增加一个Node，名字是bucket的名字，在此之下存储config)</p>

<p>   serviceConfig.Bucket(&ldquo;bucketName&rdquo;).getLong(&ldquo;exploitDiscardTimespan&rdquo;, exploitDiscardTimespan)</p>

<p>  这样server端更新配置的时候，serviceConfig会根据通知刷新自己的配置缓存，下次使用getLong的时候就得到了新的配置。</p>

<p>  上述getLong的过程包含了：</p>

<ol>
<li><p> 如果是Bucket配置，从Bucket中获取，如果找不到，从Service的配置获取，如果还是没有，返回默认值。</p></li>
<li><p> 对于返回默认值的情况，写回Zookeeper。</p></li>
<li><p> 如果Zookeeper端有修改，Zkclient会收到消息，重新update本地配置项的缓存。</p></li>
<li><p> 如果定义了handler调用handler，如下所述：</p></li>
</ol>


<p>  如果需要根据配置修改的通知来做出响应（这是默认事件，node_data_change)：</p>

<pre><code>ServiceConfig.Instance().addEventListener("task_period", new IEventHandler() {
  @Override
  public void process(ZkEvent event) {
    logger.info("update task period.");
    setDeclaredField(TimerTask.class, ServerTasks.this, "period", ServiceConfig.Instance().getLong("task_period", period));  
  }
});
</code></pre>

<p>  如果需要删除的通知：</p>

<pre><code>  ServiceConfig.Instance().addEventListener("task_period", EventType.NodeDeleted, new IEventHandler() {
  @Override
  public void process(ZkEvent event) {
    logger.info("update task period.");
    setDeclaredField(TimerTask.class, ServerTasks.this, "period", ServiceConfig.Instance().getLong("task_period", period));  
  }
});
</code></pre>

<h4>结合SpringFramework：</h4>

<pre><code>基本不变，只不过SpringFramework会先填充InitializingBean的域，这些值只有在出默认值的时候才会被采用。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些python小技巧]]></title>
    <link href="http://cxh.me/2015/05/27/python-tricks/"/>
    <updated>2015-05-27T10:54:00+08:00</updated>
    <id>http://cxh.me/2015/05/27/python-tricks</id>
    <content type="html"><![CDATA[<ol>
<li><p>生成一个重复列表可以通过如下语句:</p>

<pre><code> [i] * n #这比[ i for _ in range(0,n) ]简洁太多
 同样可以"i" * n来生成字符串
</code></pre></li>
<li><p>map函数。</p>

<p> 可以用来分类函数和其调用参数，对于线程池比较有用。比如</p>

<pre><code> import urllib2 
 from multiprocessing.dummy import Pool as ThreadPool 

 urls = [
         'http://www.python.org', 
         # etc.. 
         ]

 pool = ThreadPool(4) 
 results = pool.map(urllib2.urlopen, urls)
 pool.close() 
 pool.join() 
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git远程分支不存在的问题]]></title>
    <link href="http://cxh.me/2015/05/11/git-remote-branch-not-exists/"/>
    <updated>2015-05-11T12:11:00+08:00</updated>
    <id>http://cxh.me/2015/05/11/git-remote-branch-not-exists</id>
    <content type="html"><![CDATA[<p>  建立了一个远程分支，提交到origin上之后，发现之前有一个同样的远程Repository存在，而且名字一样，这就比较D疼了，git branch -a 显示的分支里面的分支提交到了另一个Repository，但是这个Repository已经改名字了，虽然地址一样。</p>

<p>  搞来搞去之后发现git checkout远程分支的时候报不存在的问题，删除这个分支的时候同样有这个问题：</p>

<pre><code>unable to delete 'refactor': remote ref does not exist
</code></pre>

<p>  导致这个分支就这么存在着删不掉了。查stackoverflow有人给出<a href="http://stackoverflow.com/questions/10292480/when-deleting-remote-git-branch-error-unable-to-push-to-unqualified-destinatio" title="When deleting remote git branch “error: unable to push to unqualified destination”">如下的方案</a>：</p>

<pre><code>git fetch -p origin
</code></pre>

<p>  问题是能解决了，但是不太理解为什么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac下多屏幕移动窗口的快捷键]]></title>
    <link href="http://cxh.me/2015/05/10/mac-multi-screen-shortcut/"/>
    <updated>2015-05-10T15:50:00+08:00</updated>
    <id>http://cxh.me/2015/05/10/mac-multi-screen-shortcut</id>
    <content type="html"><![CDATA[<p>  mac下使用多屏幕的话，经常需要把一个窗口移动到另一个窗口，windows下有快捷键win+shift+左右，linux下貌似可以通过xdotool实现，绑定一个快捷键，xdotool帮助你移动窗口到一个绝对位置。如下：</p>

<pre><code>xdotool getactivewindow windowmove 0 y windowactivate windowfocus
xdotool getactivewindow windowmove 1280 y windowactivate windowfocus
</code></pre>

<p>  mac下没有找到对应的系统快捷键，虽然可以设定一个zoom键来完成窗口最适化，但是没有快捷键来完成窗口的移动。这里我们通过<a href="http://manytricks.com/moom/" title="Moom">Moom</a>实现。</p>

<p>  Moom是一个窗口管理工具，安装之后只有一个配置页面，但是你会发现鼠标移动到左上角窗口最适化的按钮上的时候会弹出一个窗口管理的提示框。如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_tooltip.png"></p>

<p>  然后我们配置窗口移动的功能，首先需要一个全局快捷键：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_shortcut.png"></p>

<p>  之后可以设置按下全局快捷键之后上下左右键的功能。有移动窗口，半最大化窗口，缩小放大和移动窗口到一个屏幕。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_config.png"></p>

<p>  这样就可以先按下全局快捷键，如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_press_shortcut.png"></p>

<p>  再通过你定义的快捷键来移动窗口了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins 安装配置]]></title>
    <link href="http://cxh.me/2015/04/23/jenkins-setup/"/>
    <updated>2015-04-23T13:57:00+08:00</updated>
    <id>http://cxh.me/2015/04/23/jenkins-setup</id>
    <content type="html"><![CDATA[<p>  首先介绍一下Jenkins，如果你熟悉自动化构建的话，那么肯定听说过hudson。Jenkins是hudson的开发者跟Oracle撕bi之后，另立门户的一个hudson分支。当然这么说似乎不太靠谱，目前hudson已经不维护了毕竟，而Jenkins的开发社区还是很活跃的，各种插件层出不穷。总的来说，如果你不是已经习惯了hudson并且有一个能用的副本，都应该迁移到Jenkins。</p>

<p>  下面说一下如何配置。</p>

<p>  Jenkins的安装非常简单，只需要从Jenkins的<a href="https://jenkins-ci.org/" title="Jenkins">主页</a>上下载最新的jenkins.war文件然后运行 java -jar jenkins.war。如果需要配置运行参数可以如下设置一些环境变量。</p>

<pre><code>JENKINS_ROOT=/home/harrychen/share/jenkins
export JENKINS_HOME=$JENKINS_ROOT/jenkins_home
java -jar $JENKINS_ROOT/jenkins.war --httpPort=8080 &gt;&gt;output.log 2&gt;&amp;1 &amp;
</code></pre>

<p>  打开对应url可以看到如下界面</p>

<!--more-->


<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins.png"></p>

<p>  系统管理里面有一些需要配置的项，比如JDK：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_jdk.png"></p>

<p>  GIT</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_git.png"></p>

<p>  MAVEN</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_maven.png"></p>

<p>  ssh-key</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_sshkey.png"></p>

<p>  ssh-server</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_sshserver.png"></p>

<p>  装一下slack的插件可以配置slack</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_slack.png"></p>

<p>  然后是建立项目的配置，Jenkins把每个自动发布的项目作为一个单独的配置，主要是如下几个：</p>

<p>  指定代码路径：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_gitclone.png"></p>

<p>  部署前事件：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_deploy_pre.png"></p>

<p>  部署后事件:</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_after_deploy.png"></p>

<p>  最后保证这些事件是在之前配置的ssh-server上执行的。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_enent_server.png"></p>

<p>  细节请看<a href="http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf" title="Jenkins 入门">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些瞬间]]></title>
    <link href="http://cxh.me/2015/04/22/some-moments/"/>
    <updated>2015-04-22T22:08:00+08:00</updated>
    <id>http://cxh.me/2015/04/22/some-moments</id>
    <content type="html"><![CDATA[<p>  回想一些事情的时候感觉印象最深刻的往往不是一段时间，而是一些瞬间。比如大学毕业晚会的那个晚上，大家喝的一塌糊涂，早晨醒来，看依然灿烂的阳光，那种孤独感是能镌刻很久的。再比如在北航的时候，那时候习惯晚上看书，安静，一个人在三号楼前的空地走走，听学院路上的川流不息的车声。事情已经远去，感觉依然清晰。每个片段好像人生路上的benchmark，只不过留下最深印象的，往往不是所得，而是所感。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review编码问题]]></title>
    <link href="http://cxh.me/2015/04/22/post-review-encoding-problem/"/>
    <updated>2015-04-22T16:08:00+08:00</updated>
    <id>http://cxh.me/2015/04/22/post-review-encoding-problem</id>
    <content type="html"><![CDATA[<p>  windows下post-review遇到一个问题（不是我，不用windows）。python会报错：</p>

<pre><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position xxx: ordinal not in range(128)     
</code></pre>

<p>  又是编码的问题啊，我不想去看post-review的源码，所以还是改默认环境的源码好了。找到rbtools\utils\process.py，import sys后面加两行：</p>

<pre><code>reload(sys)
sys.setdefaultencoding("utf-8") 
</code></pre>

<p>  Ok.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[partition算法的落点讨论]]></title>
    <link href="http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis/"/>
    <updated>2015-04-20T21:27:00+08:00</updated>
    <id>http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis</id>
    <content type="html"><![CDATA[<p>  首先这里的partition算法指的是快速排序中把数据分区的算法，算法接受一个数列和一个值，返回一个位置，这个位置之前的元素都小于等于输入值，之后的元素都大于等于输入值。</p>

<p>  算法如下：</p>

<p>  还有一种常见的形式：</p>

<p>  这里我们讨论下落点的情况，如果partition算法可以传入任何的value，而不是快排中那样从序列中随机获得一个值，那么结果就会有多重情况了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven download dependency挂住的问题]]></title>
    <link href="http://cxh.me/2015/04/19/maven-download-stuck/"/>
    <updated>2015-04-19T22:08:00+08:00</updated>
    <id>http://cxh.me/2015/04/19/maven-download-stuck</id>
    <content type="html"><![CDATA[<p>  今天迁移工程到mac上，准备以后用mac作为主开发工具。迁移maven的时候发现，maven download会停在那里，如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/maven_error.jpg"></p>

<p>   解决如下：</p>

<ol>
<li>怀疑http_proxy问题，去掉系统环境变量。无效</li>
<li>怀疑shadowsocks问题，关掉，无效。</li>
<li>maven配置问题，对比了默认配置，没什么错误的地方。</li>
<li>怀疑服务器问题，换成开源中国的maven源，ok，就是慢点。</li>
<li>继续等待，几分钟后报错： java.net.SocketException: Malformed reply from SOCKS server，似乎还是代理的问题。</li>
<li>查阅发现java还有自己的代理配置，见<a href="https://www.java.com/en/download/help/proxy_setup.xml" title="How do I configure proxy settings for Java?">参考文献</a>，去掉代理。貌似还是无效。</li>
<li>索性重启，搞定。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于sendmail邮件服务器的搭建]]></title>
    <link href="http://cxh.me/2015/04/01/something-about-sendmail-setup/"/>
    <updated>2015-04-01T20:14:00+08:00</updated>
    <id>http://cxh.me/2015/04/01/something-about-sendmail-setup</id>
    <content type="html"><![CDATA[<p>  还是reviewboard的事情，我们需要一个自己的邮件服务器来发通知邮件。sendmail是一个比较好的选择，搭建的方式很简单，安装sendmail，修改配置文件，修改local_host_name就行。如果不需要登陆验证，这样也就直接能用了。现在的问题是reviewboard是必须登陆验证的。至少看报错上是这样。</p>

<pre><code>SMTPException: SMTP AUTH extension not supported by server. reviewboard
</code></pre>

<p>  具体代码没细看，但是应该默认都有认证，只是认证方式不一样。我们telnet到25端口，执行</p>

<pre><code>ehlo localhost
</code></pre>

<p>  发现250 AUTH没有支持。所以需要配置邮件服务器的身份认证。详见<a href="http://blog.sina.com.cn/s/blog_6b61ec070101e161.html" title="CentOS sendmail安装及邮件域名配置">参考文献1</a><a href="http://ju.outofmemory.cn/entry/12533" title="testsaslauthd “authentication failed” 解决办法">参考文献2</a>。最后测试一下用户是否能通过验证和邮件能否正常发送：</p>

<pre><code>/usr/sbin/testsaslauthd -u username -p sohutest

mail -s "test" xxx@xxx.com &lt;content.txt
</code></pre>

<!--more-->


<p>  如果邮件不能正常发送可以通过如下方式debug：</p>

<pre><code>1. 查看/var/log/messages
2. 查看用户mail
3. 通过telnet模拟一下登陆发邮件的过程：

        HELO localhost
        AUTH LOGIN 
        aGFycnljaGVu
        c29odXRlc3Q=
        MAIL FROM:&lt;test@xxx.com&gt;
        RCPT TO:&lt;username@xxx.com&gt;
        DATA
        To: username@xxx.com
        From:test@xxx.com
        Subject:test mail
        From:test@xxx.com
        test body
        .
        quit
</code></pre>

<p>  安装reviewboard的过程还发现一个问题，邮件服务器已经可以正常发邮件了，reviewboard还是失败，看到如下报错：</p>

<pre><code>- Error sending e-mail notification with subject 'Review Request 2: [retrieval-ad][master][NewFeature] Readme' on behalf of '"UserName" &lt;xxx@xxx.com&gt;' to '"UserName" &lt;xxx@xxx.com&gt;,xxx@xxx.com'
Traceback (most recent call last):
  File "/opt/xxx/rb/lib/python2.7/site-packages/ReviewBoard-2.0.15-py2.7.egg/reviewboard/notifications/email.py", line 294, in send_review_mail
    message.send()
  File "/opt/xxx/rb/lib/python2.7/site-packages/Django-1.6.11-py2.7.egg/django/core/mail/message.py", line 276, in send
    return self.get_connection(fail_silently).send_messages([self])
  File "/opt/xxx/rb/lib/python2.7/site-packages/Django-1.6.11-py2.7.egg/django/core/mail/backends/smtp.py", line 87, in send_messages
    new_conn_created = self.open()
  File "/opt/xxx/rb/lib/python2.7/site-packages/Django-1.6.11-py2.7.egg/django/core/mail/backends/smtp.py", line 54, in open
    self.connection.login(self.username, self.password)
  File "/usr/local/lib/python2.7/smtplib.py", line 613, in login
    raise SMTPAuthenticationError(code, resp)
SMTPAuthenticationError: (535, '5.7.0 authentication failed')
</code></pre>

<p>  跟到如下smtplib.py里面看验证方法，调整了顺序（我这支持AUTH LOGIN PLAIN，没支持PAM)，然后保证用户名密码正确就基本可以使用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ps grep不显示grep自己本身的方法]]></title>
    <link href="http://cxh.me/2015/03/31/ps-do-not-grep-self/"/>
    <updated>2015-03-31T15:45:00+08:00</updated>
    <id>http://cxh.me/2015/03/31/ps-do-not-grep-self</id>
    <content type="html"><![CDATA[<p>  主要两种方式：</p>

<ol>
<li><p>不grep自己。</p>

<pre><code> -v, --invert-match
     Invert the sense of matching, to select non-matching lines.
 所以：
     ps xuf|grep python|grep -v grep
</code></pre></li>
<li><p>awk 略去最后一行。</p>

<pre><code> ps xuf|grep python|awk 'NR&gt;1{print p}{p=$2}'
</code></pre>

<p> 解释下：第一行的时候，NR=1不打印，但是把pid存在p中，下一行打印，最后一行的时候，打印的是上一行的pid。</p>

<p> awk博大精深&hellip;</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
