<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-11-17T22:03:05+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于日志的比对]]></title>
    <link href="http://cxh.me/2013/11/17/method-to-diff-log/"/>
    <updated>2013-11-17T22:00:00+08:00</updated>
    <id>http://cxh.me/2013/11/17/method-to-diff-log</id>
    <content type="html"><![CDATA[<p>  有时候我们其实会遇到这种情况，本地修改了一点东西，然后发现跑跟预期结果不一致，这时候去看日志发现各种日志里面有各种ERROR，但是这些ERROR实际上并不是这个问题导致的，因为你回滚修改之后发现这些ERROR依然存在。如果有core文件当然最好，但是如果没有或者core里面并看不出问题就比较纠结了。前面一篇文章我们探讨了如何<a href="http://qianjigui.iteye.com/blog/368449" title="Vim日志定位解决方案">写个插件通过log来定位源码行</a>，这篇日志我们讨论一下如何快速定位自己的错误日志。</p>

<p>  首先，前面的状况至少可以保证一点，你check一份新的代码或者回滚本地修改然后运行，得到的错误日志和你当前的错误日志是可比较的。也就是说，你的错误至少不会导致错误日志之中有巨大的变化。这样的话我们可以采取如下的策略比较错误日志。</p>

<ol>
<li> 得到当前的错误日志，假使命名为log.core</li>
<li> check一份新的代码或者回滚本地修改，得到之前的错误日志，假使命名为log.ok</li>
<li> 比较log.ok和log.core，分析日志的差别，得到本地修改导致的真实错误日志。</li>
</ol>


<p>  想法是很简单的，唯一的问题是OB日志里面是有时间戳的，这就导致没一行都有差异，那就太纠结了。我们可以用如下vim命令来去掉所有的时间戳。vim正则的转义规则见<a href="http://qianjigui.iteye.com/blog/368449" title="Vim 中的正则表达式">参考文献</a>。</p>

<pre><code>map :lg :%s/\(^\[.\{-}\]\)\\|\(\[\d\+\]\)//g
</code></pre>

<p>  这里面唯一的风险是比如我们在中括号里面写的数字也会被剔除，好在我们只是比较日志差异，想要看原始日志大不了根据行号到完整版里面找去，而且这个概率不大。</p>

<p>  <!-- more --></p>

<p>  实际的效果是这样的。我在考虑要不要把所有的tsi错误都去掉。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-11/logdiff.png" title="日志比较" alt="日志比较"><p class="align-center">日志比较</p></p>

<h3>参考文献:</h3>

<blockquote><p>[1] Vim 中的正则表达式, <a href="http://qianjigui.iteye.com/blog/368449">http://qianjigui.iteye.com/blog/368449</a></p>

<p>[2] Vim日志定位解决方案, <a href="http://qianjigui.iteye.com/blog/368449">http://qianjigui.iteye.com/blog/368449</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim日志定位解决方案]]></title>
    <link href="http://cxh.me/2013/11/08/solution-to-locate-log-in-src/"/>
    <updated>2013-11-08T21:31:00+08:00</updated>
    <id>http://cxh.me/2013/11/08/solution-to-locate-log-in-src</id>
    <content type="html"><![CDATA[<p>  做分布式系统看日志解决问题是基本功了，毕竟多个server跑在不同的机器上，即使用gdb能attach到某个进程上，或者<a href="http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob/" title="用gdb调试分布式系统（OB中的应用）">用非daemon模式启动并调试</a>但是case往往很复杂，难以用测试环境完全模拟case，所以大部分情况下还是需要看日志解决问题的。</p>

<p>  不过日志多了之后往往容易跟丢，在浩如烟海的日志里面定位到发生错误的地方也不是见容易的事情。这周大部分时间就费在这上面了（不过还是不熟）。期间写了一个简单的vim插件实现日志的定位。想法如下：</p>

<!-- more -->


<p>  偶然发现通过deploy.py ob1.rs0.less打开less窗口之后按v键可以转到vim窗口，这就解决很多问题了，毕竟我可不想在less下实现什么功能。vim script就熟悉多了。</p>

<p>  ob的log格式是这样的</p>

<pre><code>[2013-11-08 20:02:23.698586] WARN  get_schema (ob_root_schema_service.cpp:296) [139800896067328] local schema not inited 
</code></pre>

<p>  可以看出关键的地方是打印日志的文件和行数，所以我们用正则\w+.c(pp)*:\d+（vim里需要转义）来匹配日志行，得到所在文件和行数之后用执行ssh命令去开发机的项目下find对应的文件，把找到的结果写入某个特定文件（~/.session)里面，之后写一个插件根据文件中的记录打开对应的文件并标红对应的行即可。</p>

<p>  定位log的vim脚本实现如下：</p>

<pre><code>if !exists('g:project_base_dir')
    let g:project_base_dir = '$HOME/dev $HOME/src'
endif

if !exists('g:user_name')
    let g:user_name = 'xxxx'
endif

if !exists('g:server_ip')
    let g:server_ip = 'xx.xx.xx.xx'
endif

function! LogSession() range
    let filearr = []
    for linenum in range(a:firstline, a:lastline)
        let curr_line = getline(linenum)
        let pos_str = matchstr(curr_line,'\(\w\+\)\.c\(pp\)*:\(\d\+\)')
        let pos_arr = split(pos_str, ":")
        if !empty(pos_arr)
            let filename = pos_arr[0]
            let linenum = pos_arr[1]
            if index(filearr, filename) == -1
                "generate file list
                let session_cmd = "find ". g:project_base_dir ." -name ". filename .' -exec echo "{}"":'.linenum.'" &gt;&gt;~/.session \;'
                let ssh_cmd = "!ssh ".g:user_name.'@'.g:server_ip." \'".session_cmd."\'"
                echo ssh_cmd
                execute ssh_cmd
                execute ':call Vm_toggle_sign()'
                call add(filearr, filename)
            endif
        endif
    endfor
endfunction
</code></pre>

<p>  解释几点</p>

<ul>
<li>g:project_base_dir定义源码所在目录，如果源码引用了其他的库，最好把其他库的源码目录一并指定。</li>
<li>g:user_name 开发机用户名，这是你源码所在机器的用户名</li>
<li>g:server_ip 开发机IP，这是你的源码所在机器的IP，保证能够无密码登录。</li>
</ul>


<p>  这样在测试机看log的less窗口里面按v进入vim（vim脚本需要部署到开发机和测试机各一份），然后在对应的行（或者多行）执行LogSession，对应的文件位置信息就被写入开发机的~/.session文件里面（这个应该可以配置，忘了做了）。</p>

<p>  另开一个窗口ssh到开发及，打开.session，应该类似于如下：</p>

<pre><code>/home/xxx.xx/dev/src/rootserver/ob_root_server.cpp:584
/home/xxx.xx/dev/src/rootserver/ob_root_server.cpp:2183
/home/xxx.xx/dev/src/rootserver/ob_root_inner_table_task.cpp:175
</code></pre>

<p>  定位到某一行调用插件打开代码就行，这就涉及到[前文所说的插件了][2]。按照快捷键打开对应的行就行。</p>

<p>  之后在vimrc里面映射键就行了</p>

<pre><code>map &lt;leader&gt;ss :call LogSession()&lt;cr&gt;
nnoremap &lt;leader&gt;co :call OpenFileWithDefApp()&lt;cr&gt;
let g:applist={
        \'pdf':'evince',
        \'png,gif,jpg':'eog',
        \'rmvb,mkv,flv,avi,mp4,m4v':'mplayer',
        \'rar':'!unrar l %',
        \'epub':'!calibre %',
        \'zip':'!unzip -O CP936 -l %',
        \'pwd':'nautilus',
        \'docx,xlsx,pptx,ppt':'libreoffice',
        \'default':':e %'
        \}
</code></pre>

<p>  截图如下：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-11/three-log.png" title="log文件" alt="log文件"><p class="align-center">log文件</p></p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-11/one-line.png" title="定位到对应的源码行c" alt="定位到对应的源码行"><p class="align-center">定位到对应的源码行</p></p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-11/two-line.png" title="定位到对应的源码行cpp" alt="定位到对应的源码行"><p class="align-center">定位到对应的源码行</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己写的一个根据路径打开文件的插件]]></title>
    <link href="http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list/"/>
    <updated>2013-11-08T21:26:00+08:00</updated>
    <id>http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list</id>
    <content type="html"><![CDATA[<p>这个其实修改了很多次，最初的目的是在linux下嘛，找电影不方便，只能用locate打印出一个电影列表来，但是每次复制路径到命令行多不方便啊，最好能在vim里面操作，于是想想干脆做成通用的好了，就有了这个filelist.vim</p>

<!-- more -->


<pre><code>"=============================================================================
"     FileName: filelist.vim
"         Desc:
"       Author: ChenXiaohui
"        Email: sdqxcxh@gmail.com
"     HomePage: http://www.cxh.me
"      Version: 0.0.1
"   LastChange: 2013-11-06 20:31:23
"      History:
"=============================================================================
function! GetCmd(type,line)
    let cmd=get(g:applist,a:type)
    if empty(cmd)
        let cmd=get(g:applist,'default')
    endif
    "no %
    if cmd[0] != '!' &amp;&amp; cmd[0] != ':'
        let cmd='!nohup '.cmd.' '.Trans(a:line).' &gt;/dev/null 2&gt;&amp;1 &amp;'
    else
        let cmd=substitute(cmd,'%',Trans(Trans(a:line)),'g')
    endif

    "let cmd=substitute(cmd,'%&lt;',a:line,'g')
    return cmd
endfunction

function! OpenFileWithDefApp()
    let cmd=''
    let origin_line = Trim(Trim(getline("."),'\\'), ' ')

    let idx = stridx(origin_line,':')
    echo idx
    if idx &gt; -1
        let line = strpart(origin_line, 0, idx)
        let linenum = strpart(origin_line, idx)
    else
        let line = origin_line
    endif

    if !filereadable(line)
        "Directory
        let cmd=GetCmd('pwd',line)
    else
        let idx=strridx(line,".")
        "has no ext
        if idx==-1
            let cmd=GetCmd('default',line)
        else
            let fileExt = tolower(matchstr(line,'\.\w\+'))
            let fileExt=tolower(strpart(fileExt,1))
            for [exts,app] in items(g:applist)
                let supportExt=split(exts,',')
                if index(supportExt,fileExt)&gt;=0
                    let cmd=GetCmd(exts,line)
                endif
            endfor
        endif
    endif

    if empty(cmd)
        let cmd=GetCmd('default',line)
    endif
    execute cmd
    if exists('linenum')
        execute linenum
        execute ':call Vm_toggle_sign()'
        "execute ':set cursorline'
        "normal V
    endif
endf

function! DelFile ()
    let line=getline(".")
    if !filereadable(line)
        "echo "!rm -ri ".Trans(getline("."))
        :execute "!rm -ri ".Trans(getline("."))
    else
        "echo "!rm -i ".Trans(getline("."))
        :execute "!rm -i ".Trans(getline("."))
    endif
    :del
endf

function! CopyFile()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd='!cp -a'.Trans(line).' '.Trans(g:dst_dir)
    else
        let cmd='!cp '.Trans(line).' '.Trans(g:dst_dir)
    endif
    :execute cmd
endf

function! ChDir()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd=':cd '.Trans(line)
    else
        let cmd=':cd '.Trans(DirName(line))
    endif
    :execute cmd
    ":echo cmd
    :sh
endf

function! DirName(line)
    let idx=strridx(a:line,'/')
    return strpart(a:line,0,idx)
endf

function! Trans(line)
    let line=Trim(a:line, ' ')
    let line=substitute(line,"'","\\\\'","g")
    let line=substitute(line,' ','\\ ','g')
    let line=substitute(line,'!','\\!','g')
    let line=substitute(line,'#','\\#','g')
    let line=substitute(line,'&amp;','\\&amp;','g')
    let line=substitute(line,'(','\\(','g')
    let line=substitute(line,')','\\)','g')
    return line
    "return "'".line."'"
    "return "'".substitute(a:line,"'","'\\\\''","g")."'"
endf
</code></pre>

<p>  原理还是很简单的，分析当前行，得到文件路径，根据类型找到关联命令，然后替换关联命令得到最后的shell命令并执行。就是一堆转义比较罗嗦，在vimrc里面定义关联程序信息：</p>

<pre><code>" plugin- deal with filelist
nnoremap &lt;leader&gt;co :call OpenFileWithDefApp()&lt;cr&gt;
nnoremap &lt;leader&gt;rm :call DelFile()&lt;cr&gt;
nnoremap &lt;leader&gt;cd :call ChDir()&lt;cr&gt;
nnoremap &lt;leader&gt;to :call CopyFile()&lt;cr&gt;
let g:dst_dir="/media/cxh/MY MP3/"
let g:applist={
            \'pdf':'evince',
            \'png,gif,jpg':'eog',
            \'rmvb,mkv,flv,avi,mp4,m4v':'mplayer',
            \'rar':'!unrar l %',
            \'epub':'!calibre %',
            \'zip':'!unzip -O CP936 -l %',
            \'pwd':'nautilus',
            \'docx,xlsx,pptx,ppt':'libreoffice',
            \'default':':e %'
            \}
</code></pre>

<p>  需要特别说明的是：</p>

<ol>
<li> 几个函数的作用分别是调用执行程序打开当前文件，删除，到当前文件所在路径下，和copy当前文件到制定的dst_dir（这个我主要用在替代windows下的发动到移动存储介质用了）</li>
<li> applist是类型-程序关联数组，说明一下，%会被替换成当前行所指定的文件路径。如果applist里面的命令既不是!开头（shell执行）也不是:开头（vim内部命令），就会被转换成类似于：!nohup mplayer /media/xx.rmvb >/dev/null 2>&amp;1 &amp;的命令，相当于windows的调用默认程序打开。</li>
<li> 支持这种形式的行号调用 xxx.cpp:123 默认用:e 打开之后会定位到对应行，然后标红，标红使用三种方式：<strong>visualmark</strong>, <strong>cursorline</strong>和<strong>normal V</strong>，第一种需要<a href="http://www.vim.org/scripts/script.php?script_id=1026" title="Visual Mark : Visual mark, similar to UltraEdit's bookmark">安装插件</a></li>
</ol>


<p>  钦此。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Visual Mark : Visual mark, similar to UltraEdit&rsquo;s bookmark, <a href="http://www.vim.org/scripts/script.php?script_id=1026">http://www.vim.org/scripts/script.php?script_id=1026</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何构建按高可用系统（分享的笔记）]]></title>
    <link href="http://cxh.me/2013/11/01/how-to-build-high-available-system/"/>
    <updated>2013-11-01T18:42:00+08:00</updated>
    <id>http://cxh.me/2013/11/01/how-to-build-high-available-system</id>
    <content type="html"><![CDATA[<p>版权所有：<a href="">解伦师兄</a></p>

<h3>介绍篇</h3>

<p><strong>可用性vs可靠性</strong></p>

<p>  可用性主要是从时间的角度看，可靠的时间。可靠性主要是看不可用的频率。如果一个系统1小时宕机1ms，可用性非常高，可靠性非常低。</p>

<p>  可用性可靠性是系统的工程，设计开发，管理，运维等等。</p>

<p>  宕机几大因素：软件-硬件-网络-人为</p>

<p>  data loss的最大因素：drop table, 所以要做好充分的容错。</p>

<!-- more -->


<h3>设计篇</h3>

<p><strong>减少故障发生的可能</strong></p>

<p>  避免单点故障，防止扩散，有效的监控运维配合</p>

<p>  常见的<strong>冗余</strong>设计。</p>

<ul>
<li>RAID,Replica,Erasure Code</li>
<li>BackUp, Reassign,Retry</li>
<li>Master-Slave,Mirror,RAC..</li>
</ul>


<p>  减少对外部系统强依赖</p>

<ul>
<li>缓存</li>
<li>异步替代同步</li>
</ul>


<p>  对外部依赖不信任</p>

<ul>
<li>结果进行</li>
<li>失败情况下failover（重试时间次数需要控制）</li>
</ul>


<p>  有效的内部监控</p>

<p><strong>减少故障恢复时间</strong></p>

<p>  无状态最好</p>

<ul>
<li>有状态定期做持久化（checkpoint/commitlog)</li>
</ul>


<p>  有效的故障隔离</p>

<ul>
<li>故障检测，黑白名单，流量分配</li>
<li>黑名单要有恢复机制</li>
</ul>


<p><strong>减少损失</strong></p>

<p>  过载保护</p>

<ul>
<li>发现故障，并限制资源</li>
</ul>


<p>  应用降级</p>

<ul>
<li>关闭部分不重要的功能(某些情况下用户也感觉不出来)</li>
</ul>


<p>  有个故事：二战的时候（好背景），坦克设计的时候每次发射炮弹，都会有电磁波导致所有软件挂掉，所以故障恢复就很重要。</p>

<h3>案例篇</h3>

<p><strong>Twitter</strong></p>

<p>  世界杯额时候twitter经常会时常挂掉</p>

<ul>
<li>memcache规划的问题</li>
<li>cache也要注意设计</li>
</ul>


<p><strong>Foursquare</strong></p>

<p>  数据不均，mongodb数据量超过内存之后性能非常差(mmap的问题)</p>

<ul>
<li>数据迁走之后有空洞，页不释放</li>
<li>还好毕设的时候数据量不大</li>
</ul>


<p><strong>Amazon</strong></p>

<p>  EBS主网络走数据，备网络走控制，操作失误，主网络切到备网络</p>

<ul>
<li>相应超时，认为丢失副本</li>
<li>副本复制，继续加剧网络问题</li>
</ul>


<p><strong>Weibo</strong></p>

<p>  热点存在，cache失效，一瞬间所有访问db</p>

<ul>
<li>加锁，一个人获取内容回填cache之后就不会有人去访问db了</li>
</ul>


<p><strong>Facebook</strong></p>

<p>  cache没取到就删除了原cache</p>

<p><strong>OB</strong></p>

<p>  客户端要做分流，业务高峰，超时严重，把cluster都加入黑名单，重试风暴</p>

<h3>总结篇</h3>

<p><strong>可用性</strong></p>

<ul>
<li>BASE:基本可用</li>
<li>CAP:No CAP, No CP, A是很重要的</li>
<li><a href="">20 Key High Availability Design Principles</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用gdb调试分布式系统（OB中的应用）]]></title>
    <link href="http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob/"/>
    <updated>2013-10-29T13:40:00+08:00</updated>
    <id>http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob</id>
    <content type="html"><![CDATA[<p>  分布式系统开发的时候我们最经常遇到的问题就是，从一个server发送了一条报文之后怎么在另一个server查看这条报文的处理逻辑是否正确，单机的debug都不是问题，但是多机debug怎么做呢？</p>

<p>  在ob团队里面，正常情况下我们有如下三种方式处理这些问题：</p>

<ol>
<li> 做mock，写单测，隔离开集群环境</li>
<li> 加调试日志，部署集群环境，看日志。</li>
<li> 非daemon模式下通过gdb调试。</li>
</ol>


<p>  这里我们详细说一下第三种。这也是最有效果的一种。</p>

<!-- more -->


<p>  需要强调的是，正常情况下ob启动之后各个server会以守护进程方式运行，这时候如果用gdb启动server的话，gdb不知道在fork之后跟哪个进程，而在我测试下，<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/" title="使用 GDB 调试多进程程序">set follow-fork-mode</a>貌似也没成功过。</p>

<p>  所以最好的方法是直接不要通过守护进程启动，我们在部署ob到home目录下，集群名用ob1，.gdbinit里面写入：</p>

<pre><code>cd ~/ob1
file bin/rootserver
set args -r 10.235.162.8:3500 -R 10.235.162.8:3500 -i eth0 -C 1 -N
break "/home/xiaohui.cpc/roottable_dev/src/rootserver/ob_root_worker.cpp:2053"
break "/home/xiaohui.cpc/roottable_dev/src/rootserver/ob_root_worker.cpp:941"
</code></pre>

<p>  参数里面加-N表示不以daemon方式启动。</p>

<p>  这样通过gdb可以启动rootserver，然后同样启动其他需要的server，就可以调试在gdb里面看到程序执行后停在断点的位置。启动脚本如下，这里我们只启动了chunkserver。</p>

<pre><code>#!/bin/bash
rs_ip=10.235.162.8
rs_port=3500
cs_port=3501
ups_port=3502
ms_port=3503
freeze_port=3504
mysql_port=3505
net=bond0
appname=ob1.xiaohui.cpc
no_daemon=-N

#bin/rootserver -r $rs_ip:$rs_port -R $rs_ip:$rs_port -i $net -C 1 $no_daemon
bin/chunkserver -r $rs_ip:$rs_port -p $cs_port -n $appname -i $net $no_daemon

#bin/updateserver -r $rs_ip:$rs_port -p $ups_port -m $freeze_port -i $net $no_daemon
#bin/mergeserver -r $rs_ip:$rs_port -p $ms_port -z $mysql_port -i $net $no_daemon

#bin/rs_admin -r $rs_ip -p $rs_port set_obi_role -o OBI_MASTER
#bin/rs_admin -r $rs_ip -p $rs_port -t 60000000 boot_strap $no
</code></pre>

<p>  断点命中的情况如图1所示：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-10/gdb_multi_server.png" title="图1：断点命中的情况" alt="图1：断点命中的情况"><p class="align-center">图1：断点命中的情况</p></p>

<p>  唯一的问题是gdb有时候会退出，如图2。感觉上是rpc超时了？</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-10/gdb_quit.png" title="图2：gdb退出" alt="图2：gdb退出"><p class="align-center">图2：gdb退出</p></p>

<p>  感谢玩大数据的<a href="http://weibo.com/hanfooo" title="韩富晟 支付宝颜然，玩大数据的，OceanBase工程师">颜然师兄</a>提供非daemon方式启动的方法。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 使用 GDB 调试多进程程序, <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/">http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/</a></p>

<p>[2] 韩富晟 支付宝颜然，玩大数据的，OceanBase工程师, <a href="http://weibo.com/hanfooo">http://weibo.com/hanfooo</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夜空中最亮的星]]></title>
    <link href="http://cxh.me/2013/10/27/brightest-star-in-the-sky/"/>
    <updated>2013-10-27T10:41:00+08:00</updated>
    <id>http://cxh.me/2013/10/27/brightest-star-in-the-sky</id>
    <content type="html"><![CDATA[<!-- more -->


<p><embed src="http://player.yinyuetai.com/video/player/617278/v_0.swf" quality="high" width="480" height="334" align="middle"  allowScriptAccess="sameDomain" allowfullscreen="true" type="application/x-shockwave-flash"></embed></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转)天朝六十年编年史]]></title>
    <link href="http://cxh.me/2013/10/25/history-of-tian-chao/"/>
    <updated>2013-10-25T21:26:00+08:00</updated>
    <id>http://cxh.me/2013/10/25/history-of-tian-chao</id>
    <content type="html"><![CDATA[<p>作者： 李舒扬</p>

<ul>
<li><p>高祖武帝开国元年 49</p>

<p>二月，王师入京，吏民欣喜。北土悉平。帝遣六军征南朝，号百万。
四月，六军涉江，灭南朝。南酋蒋氏遁，入海，据澎湖以抗圣化。迁九鼎于京。江南诸道初定。
十月，帝登基于天丨安门。入太庙，誓，立政，改元“开国“。周文正公相。封六辅政亲王。
王曰：“华夏诸民今日立也！“
十一月，大将军刘，西路招抚使邓统王师十万入蜀，前朝余孽星散，蜀，滇，黔传徼而定。
邓平公封西南节度使，坐镇西南以图吐蕃。
是年，帝下《别了，司徒雷登》等三诏，用赐西夷美利坚使，夷使惭去。史称“三诏去西夷”。</p></li>
</ul>


<!-- more -->


<ul>
<li><p>高祖武帝开国二年 50</p>

<p>二月，北狄俄罗斯遣使来朝，盟，世世代代约为兄弟之邦。
六月，高丽内乱。帝诏命停战，不听。
九月，高丽北朝胜。同月，西夷美利坚纠合西夷数十部落侵朝鲜，号“联合国军”。
十月，高丽北朝溃，美夷之师次于鸭绿水。帝以大将军彭桓公为东征元帅，加太子少保，太子岸英为监军，统精
锐二十万入高丽，战于长津，美夷败绩。
征西将军王震统兵入西域，设西域都护府，立生产建设兵团。西域归王化。</p></li>
<li><p>高祖武帝开国三年 51</p>

<p>十一月，行“三反”。
是年，王师美夷战于朝鲜。美夷惧，求和，帝不许。
吐蕃归王化。自是，天下几一统。
太子战死沙场，天下悲恸。</p></li>
<li><p>高祖武帝开国四年 52</p>

<p>一月，行“五反”。
八月，帝下“削藩令”，令东北节度使高岗王（开国辅政六亲王之一），华东节度使饶石公，西南节度使邓平公，中南节度使邓恢公，西北节度使习勋公进京。时人谓之：“五马进京，一马当先。”
是年，王师美夷再战于朝鲜。王师据上甘岭，敌纠兵数万以攻，终溃。</p></li>
<li><p>高祖武帝开国五年 53</p>

<p>一月，行“新三反”。
三月，俄狄王斯大林死。（注：狄王死不曰崩。）
五月，与俄狄盟。
六月，始料民，口六亿又一百九十又三万八千又三十又五。为前所未有之盛世。
九月，彭桓公平美夷于高丽。高丽中分。北者为朝鲜，南者为韩国。</p></li>
<li><p>高祖武帝开国六年 54</p>

<p>帝使使日内瓦，南越中分。
五月，故东北节度使高岗王自杀于北京，天下震惊。谥“幽”，“动祭乱常曰幽”。
八月，江淮大水，平地汹涌不见寸土。
九月，行布票。天下币制革新由是而始。
十二月，御史劾故东北王高，华东王饶怀不臣之心阴谋乱上。帝令有司查办。</p></li>
<li><p>高祖武帝开国七年 55</p>

<p>五月，帝使周文正公盟诸王于万隆。
七月，行“肃反“。帝下《关于农业合作化问题》诏。南越来朝，赐贝八亿朋。
十月，帝下《农业合作化的一场辩论和当前阶级斗争》诏。
是年，帝大封开国诸将，计元帅十，大将十，上将若干。满朝文武，人才济济。</p></li>
<li><p>高祖武帝开国八年 56</p>

<p>五月，帝曰：“百花齐放，百家争鸣“。右party扰乱朝纲自是起。
七月，帝曰：“美帝国主义是个纸老虎。”
是年，埃及来宾，匈奴来盟。八方万国，皆慕我中华圣化。</p></li>
<li><p>高祖武帝开国九年 高祖反右元年 57
五月，帝逐右party。改元：反右。
十月，帝曰：“大鸣、大放、大字报、大辩论”。
十一月，帝西巡俄狄，曰：“东风压倒西风。“</p></li>
<li><p>高祖武帝反右二年 58</p>

<p>二月，诰告天下，命灭“四害”。“四害”者，蚊、蝇、鼠、雀也。
六月，左丞相薄作《两年超过英国》上疏，帝大悦，嘉之。
七月，俄狄王赫鲁晓夫来朝。
九月，桂人来告田可亩产十三万余斤者。
十一月，滇民有饥色。
是年“大跃进“，万民炼钢，卫星纷飞。东征大军自高丽还。</p></li>
<li><p>高祖武帝反右三年 59</p>

<p>吐蕃叛，帝命征之。王师势如破竹，吐藩达丨赖逃往天竺。吐藩乃定。
一月，帝下《“反瞒产私分”》诏，令天下百姓不得隐瞒粮食。
二月，诸侯朝王于郑。
七月，帝大会诸侯于庐山。彭桓公上《万言书》，以军人干政事。帝怒。
八月，下彭桓公于狱，尽逐右party。野有“功高震主，鸟尽弓藏”之议。
是年，民有饥色。</p></li>
<li><p>高祖武帝反右四年 60</p>

<p>民大饥，赤地千里，野有饿孚，豫桂尤甚。赈饥民。
四月，帝命周文正公巡信阳。帝不食肉。
六月，帝至沪上。
七月，俄狄背盟。
十一月，诏令六军将士“两忆三查“。“两忆三查”者，“忆阶级苦、忆民族苦、查立场、查斗志、查工作”也。</p></li>
<li><p>高祖武帝反右五年 61</p>

<p>大饥。赈饥民。帝以“天道不常“传位于刘哀宗。哀宗始摄政，未改元。
是年，高祖再会诸侯于庐山。</p></li>
<li><p>哀帝反右六年 62</p>

<p>民饥。
四月，伊犁饥民乱。
六月，彭桓公谏以“八万言书”，帝怒。
七月，诸侯朝高祖于北戴河，高祖曰：“阶级斗争必须年年讲、月月讲、天天讲。”
九月，天竺犯我吐藩。
十月，王师伐天竺，大败之。天朝声威远播。</p></li>
<li><p>哀帝反右七年 63</p>

<p>二月，在京。高祖曰：“阶级斗争，一抓就灵”。
三月，高祖大诰天下曰：“向雷锋**学习”。
九月，锡兰来宾。
十二月，周文正公出巡亚非拉十四国。天下万国，竞相慕我中华上国之风采。
是年，我朝石油自给。</p></li>
<li><p>哀帝反右八年 64</p>

<p>五月，《高祖语录》始颁行。
六月，行“样板戏”。京津沪，民有奇装异服者。
十月，原子弹爆。
十二月，行“四清”。</p></li>
<li><p>哀帝反右九年 65</p>

<p>一月，高祖颁《二十三条》。
七月，前朝代宗李宗仁自海外归降。高祖携帝慰之。
十月，高祖曰：“不要怕造反。”
九月，结晶牛胰岛素成。
十一月，大学士姚作《评新编历史剧〈海瑞罢官〉》，“文革”初始。</p></li>
<li><p>哀帝反右十年 高祖文革元年 66
改元：文革。
三月，邢台地震。
五月，“文革“始行。罢科举。
七月，高祖泅水于江，遂至于京师。
八月，百万红卫朝王于天丨安门。天下始大乱。</p></li>
<li><p>高祖武帝文革二年 67</p>

<p>一月，上皇废哀宗，哀宗请骸骨，帝不许。高祖重秉政，颁《公共安全专家六条》《六军支左》。
二月，“二月逆流”。
三月，黜左丞相薄。
五月，天下始行“忠字舞”、“早请示，晚汇报”、“语录歌”、“语录操”。
八月，英夷使馆火。
是年，颁《高祖语录》八千六百余万。</p></li>
<li><p>高祖武帝文革三年 68</p>

<p>黜哀宗刘、右丞相邓。
是年，吐蕃，西域革委会成丨立。</p></li>
<li><p>高祖武帝文革四年 69</p>

<p>林庄公赞曰：“大海航行靠舵手，干革命要靠毛丨泽东思想！”
三月，王师败俄狄于珍宝洲。
四月，九大，封林庄公为亲王，加九锡，赐林亲王天子旌旗，出入免跪拜。
十一月，杀哀帝于开封。其卒不赴告。</p></li>
<li><p>高祖武帝文革五年 70</p>

<p>春，林庄亲王欲上帝尊号，帝不悦。
四月，卫星上天，红旗未落地。
八月，帝会诸侯于庐山。
十二月，帝会夷人斯诺。周文正公主持修建葛洲坝。</p></li>
<li><p>高祖武帝文革六年 71</p>

<p>一月，陈懿公薨，帝往悼之，曰：“陈毅是位好**。”加封王，谥“懿”，法曰：“温柔贤善曰懿“。
八月，帝南巡。
九月，林庄亲王叛。欲弑帝，帝觉，攻林庄亲王，庄亲王北奔，死于漠北。谥“庄”，谥法曰：“死于原野曰庄
“。臣而作乱，贬爵号为伯，厥死不言薨。</p></li>
<li><p>高祖武帝文革七年 72</p>

<p>美夷，倭奴来盟。</p></li>
<li><p>高祖武帝文革八年 73</p>

<p>一月，南越平。
三月，重起用邓平公为右丞相
七月，皇孙远新封张铁生“白卷英雄“。
十二月，帝令六军各提督对调。</p></li>
<li><p>高祖武帝文革九年 74</p>

<p>二月。赞比亚国王来朝。帝提出三个世界之划分。
十一月，大元帅，彭桓公薨。谥“桓“，谥法曰：“辟土服远曰桓。”。
是年，发秦始皇陵。</p></li>
<li><p>高祖武帝文革十年 75</p>

<p>是年，前朝思帝死于东海夷洲。谥法曰：“追悔前过曰思”。王而失国，厥死不言崩。</p></li>
<li><p>高祖武帝文革十一年 惠宗凡是元年 76</p>

<p>帝病，道扬末命于公子华，曰：“你办事，我放心。”，公子华嗣训。
一月，周文正公薨。谥法曰：“慈惠爱民曰文“，“刚直不阿曰正”。国人悲
之，执手泣别。
四月，国人益悲，集于天丨安门。
七月，地大震，死伤无数，丧丁二十八万余口，帝惊。
是月，大元帅，朱武公薨。
八月，帝崩。天崩地坼，万民震恸，如丧考妣。谥武。谥法曰：“克定祸乱曰武”。公子华立，是为惠帝。惠帝
命“两个凡是”，改元：凡是。
十月，四凶作乱，叶定公执四凶。谥法曰：“刚强直理曰武”。</p></li>
<li><p>惠帝凡是二年 77</p>

<p>八月，“文革”罢，天下初定。重开科举取士。南斯拉夫王铁托来朝。
是年，邓平公摄政。惠帝畏之。</p></li>
<li><p>惠帝凡是三年 78</p>

<p>一月，南越背盟。
十一月，邓平公游美夷。
是年，拨乱反正。</p></li>
<li><p>惠帝凡是四年 79</p>

<p>二月，南越背我，邓平公命六师伐之。
是年，始行“计划生育“。</p></li>
<li><p>惠帝凡是五年 宣帝改革元年 80</p>

<p>五月，葬刘哀帝。谥法曰：“恭仁短折曰哀”。邓平公悼曰：“伟大的无产阶级…永垂不朽。”
十一月，邓平公与诸大臣共废惠帝，邓平公立，是为宣帝。
是年，改革开放。</p></li>
<li><p>宣帝改革二年 81</p>

<p>五月，开国女亲王宋薨。维新立王，率巡大卞，用变和天下。</p></li>
<li><p>宣帝改革三年 德帝耀丨邦元年 82</p>

<p>七月，料民，口十亿。
是年，胡德公执政。</p></li>
<li><p>德帝耀丨邦二年 83</p>

<p>是年，设六师行署于京师。</p></li>
<li><p>德帝耀丨邦三年 84</p>

<p>王师肆伐南越。</p></li>
<li><p>德帝耀丨邦四年 85</p>

<p>是年，裁甲士四分一。</p></li>
<li><p>德帝耀丨邦五年 86</p>

<p>叶定公薨。谥法曰：“安民大虑曰定”。
十二月，众翰林大学士上书斥污吏。</p></li>
<li><p>德帝耀丨邦六年 仁宗紫阳元年 87</p>

<p>一月，上史系宗，以为德亲王。立亲王赵，是为仁宗。改元：紫阳。</p></li>
<li><p>仁帝紫阳二年 88</p>

<p>是年，物价飞涨。王舟破南越于南海。</p></li>
<li><p>仁帝紫阳三年 孝帝整顿元年 89</p>

<p>二月，美夷来宾。
三月，吐藩乱。
四月，德亲王耀丨邦薨，谥法曰：“绥柔士民曰德“。京师大乱，暴民起于萧墙，波及天下。唯帝治沪上，安民
伐乱，一时东南平定，万民悦服。
六月乙酉，国人暴丨动，李丞相奉上皇旨平京师乱，废仁宗。壬辰，帝登基，改元：整顿。
九月，上皇始退而不朝。</p></li>
<li><p>孝帝整顿四年孝帝市场元年92</p>

<p>二月，太上舜巡，百越南海诸民迎之，吏民欢欣，太上喜，下南巡旨，乃改元：市场。</p></li>
<li><p>孝帝市场四年孝帝三讲元年 95</p>

<p>革顺天府尹陈，九门提督王，王自缢以谢罪，陈交部议处。天下万民喜而奔走。
十一月，帝颁《三讲》诏，曰：“讲学习、讲政治、讲正气。”改元：三讲。</p></li>
<li><p>孝帝三讲二年 96</p>

<p>帝观兵于台湾海峡。百万将士三呼万岁，足为一时之观。有西夷兵临东海窥之，帝镇定不为动，夷乃去。</p></li>
<li><p>孝帝三讲三年 97</p>

<p>二月，太上崩，天下举哀七日。谥法曰：“圣善周闻曰宣”。
七月，逐英夷于九龙。</p></li>
<li><p>孝帝三讲四年 98</p>

<p>三月，以容基为丞相。
是年夏，洪甚，湖广，两江受其害，嘉鱼平地水深一丈。广州，金陵，济南各府均出兵数万解万民于倒悬。军民
鱼水，堪为千古佳话。各地大开官仓赈灾。上诏免灾地三年钱粮。是岁，仓廪实，民生无碍。</p></li>
<li><p>孝帝三讲五年 99</p>

<p>元月，帝登京师世纪坛。
五月，美夷炸我驻南使馆。帝斥之，夷惶恐，献布帛钱粮若干。太学生群起于宫门。帝诏曰：不为己甚。
十二月，逐葡夷于澳门。自是逐尽洋夷，唯前朝余孽尚据澎湖以抗圣化。
是年，再裁甲士50万。</p></li>
<li><p>孝帝三个代表元年 00</p>

<p>二月，帝巡幸高州，始行“三个代表”，乃改元“三个代表”
四月，有邪教F1G造乱于宫门。
七月，帝下诏除之。</p></li>
<li><p>孝帝三个代表二年孝帝德治元年 01</p>

<p>正月，帝下诏，以德为治国之本，乃改元：德治。是月，乱民*于宫门。
二月，京师西五十里地震，大风沙。
三月，江西乡校爆炸，士民震怖。未及，大盗龚某作乱于石家庄，人心惴惴。
四月，西夷名美利坚者遣兵窥境，尽为我所擒。乃昭谕夷使，严词责备，夷酋布殊大惧，顿首泣血而为书，谢罪殿前。上宽仁，念彼夷兵家小亦有倚门之苦，皆予开释，令其团聚。八方万国，由是遍赞中华上邦之厚德。
七月，上派重臣赴沙俄展示实力，大获全胜迎奥运归，举国欢颜。</p></li>
<li><p>孝帝德治二年 恭帝科学发展元年 02</p>

<p>三月，港首朝帝述职，港人讥之。龙颜怒，斥曰：“Too simple,sometimes naive！“世人乃悉上通诗书礼乐余得明阳之吼，文武之道，张弛并举，天下骚然。
十一月，百官入觐，孝帝阐位。初，上皇废仁宗，立两江总督江，是为孝帝，孝帝龙行虎步，太平天子真命，即位一十有三年矣。法曰：“慈惠爱亲曰孝”；“德象天地曰帝”、“德合天者曰帝”。
丁亥，胡亲王登基，改元“科学发展”，封八辅政亲王，凡吴国公、温宝公、贾林公、曾红公、黄丨菊公、吴正公、李春公、gan#luo公，出入免跪拜。
十二月，帝遣使使于蒙特卡洛，夷具惶恐，世博事乃成。</p></li>
<li><p>恭帝 科学发展 二年 03</p>

<p>一月，帝率上书房诸大臣巡幸西柏坡，下《牢记“两个务必”》诏，嘱万民承高祖之遗风。
年初，瘟疫盛行。至三月，京师人心惶惶。四月，帝令削顺天府尹孟、上皇御医张职。越数月，疫魔始降。
三月，拜温宝亲王为相，曾红亲王为镇国公，加封九锡。
十月，“神舟”五号升空，帝大悦，赏“航天英雄”杨戴双眼花翎。
本年，南朝余孽阿丨扁再行独祸，帝下旨斥之。</p></li>
<li><p>恭帝 科学发展三年 04</p>

<p>五月，天道无常，川赣湘等道大旱。至七月，赣湘及两广大水。
九月，四中全会，上皇孝帝始退而不朝。
是年，“空壳奶粉”、“嘉禾”事出，上不悦。</p></li>
<li><p>恭帝 科学发展四年 05</p>

<p>一月，帝诏告天下，永免农业税，万民抚额称善，赞胡丨温亲民简赋，史称“胡丨温新政”。
废帝仁宗殂。辅政亲王贾林公、内务府总管g.wang等往八宝山悼之。先是，仁宗谋黜太上，谕乱民曰：“我们都老了……”，太上与诸大臣共废之。
上下旨行士大夫保先教育。
三月，HONGKONG都护董奉旨入京，任谏议大夫。
四月，南朝国party魁连战、亲party魁宋瑜、新party魁郁明来朝。
九月，帝盟诸王于纽约，曰：“努力建设持久和平、共同繁荣的和谐世界”，四夷咸服。</p></li>
<li><p>恭帝 科学发展五年 和谐元年 06</p>

<p>三月，帝作“八荣八耻”诏，万民争诵之。
六月，大旱，民生幸无碍。
七月，修铁道直通吐蕃，举国欢悦。
八月，《孝帝文选》颁行天下，万民课之。
十月，高丽国行核爆，美夷磨刀欲伐之，帝令三军移驻鸭绿，美夷惧之，乃去。
六中全会，帝下《构建和谐社会》诏，乃改元“和谐”。</p></li>
<li><p>恭帝 和谐 二年 07</p>

<p>四月，上书房下诏，节能减排
同月，温相巡东夷、高丽，宣我国威。
十月，行十七大盛会，百官入朝。</p></li>
<li><p>恭帝 和谐三年 08</p>

<p>三月，南国雨雪成灾。
三月，吐蕃作乱，帝除之，并下诏斥乱酋达丨赖。
五月，蜀地大震，死伤十万余。帝遣亲王宝相为钦差大臣，赐尚方宝剑，总督四川。后，灾情甚重，帝御驾亲临，总督川蜀。
八月，行奥运盛会，万国来朝，我朝金牌夺冠，唯蹴鞠一败涂地，国人不悦，上乃罢丨教头谢氏亚龙
九月，三鹿荼毒我华夏儿女，同月，股指大跌，创万国之冠。
十月，嫦娥奔月。</p></li>
<li><p>恭帝 和谐四年 09</p>

<p>一月，我天朝之水师，远跨亚丁，始兴护航。
四月，万国来华，聚青岛而演水师。
五月，大祭国丧，三日不乐。
七月，日食现，同月，前朝新帝登基，号曰：英九.
十月，开国建都，六十年整；举国同欢！</p></li>
<li><p>亚克西元年 10</p>

<p>二月，元月，冬雷震震。万国灾难四起，民曰：2012前兆也。
三月，江南五省大旱，尤为云贵川三地尤重。帝遣亲王宝相，代天巡牧，赐尚方宝剑，提调云贵一切事物，总督云贵。
同月，华西沙暴四起，兼有洪灾。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oceanbase迭代器说明]]></title>
    <link href="http://cxh.me/2013/10/21/table-tablet-iterator/"/>
    <updated>2013-10-21T16:26:00+08:00</updated>
    <id>http://cxh.me/2013/10/21/table-tablet-iterator</id>
    <content type="html"><![CDATA[<p>  所有迭代器的类图如下所示：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/iterator.png" title="iterator类图" alt="iterator类图"><p class="align-center">iterator类图</p></p>

<h2>ObRootTabletIterator</h2>

<p>  所有tablet类迭代器，也就是ObRootTableIterator, ObTableTabletIterator等的直接父类，定义了迭代接口。</p>

<!-- more -->


<h2>ObTableTabletIterator</h2>

<p>  最基本的迭代器，继承ObRootTabletIterator, 负责迭代一个表的所有（或者某个指定range里面的）Tablet。</p>

<h3>实现机理 :</h3>

<p>  从Rowkey::MINROWKEY开始，每次迭代的tablet的endkey（加一个ObRowkey::MIN_OBJECT防止找到同一个）作为下次迭代的起始值。</p>

<h3>错误码与错误原因对应</h3>

<p><strong>断言失败</strong>：</p>

<ol>
<li> 接受返回值的传入参数tablet存在分配器（allocator）或者手动制定了其他的分配器（而不是由上次本迭代器制定的range_allocator)</li>
<li> sql查询结果为空</li>
</ol>


<p><strong>OB_ITER_END</strong>：</p>

<ol>
<li> 迭代正常结束，必须保证tablet是以MAX结束的（或者以ScanRange的endkey结束）。</li>
<li> 如果有一个表没有任何tablet，同样返回OB_ITER_END，而不是OB_NO_RESULT错误码（更新，争议的地方）。</li>
</ol>


<p><strong>OB_NOT_INIT</strong>:</p>

<p>  没有初始化，目前是没有传入RootTableService指针，或者指针为空。</p>

<p><strong>OB_ROOT_NOT_INTEGRATED</strong>：</p>

<p>  scan_range出错，当前end_key不再scan_range的范围里，</p>

<p><strong>OB_ERR_UNEXPECTED</strong>：</p>

<p>  tablet本身错误，start_key > end_key</p>

<h4>其他从root_table层得到的错误码：</h4>

<p><strong>OB_MEM_OVERFLOW</strong>： 内存错误</p>

<p><strong>OB_TABLE_NOT_EXIST</strong>：</p>

<ol>
<li> 获得表schema的时候发现schema中不存在这张表</li>
<li> 查询到的结果有空洞（某个范围下没有当前表的tablet）</li>
</ol>


<p><strong>OB_NO_RESULT</strong>：</p>

<p>  按照指定的条件，proxy查询不到结果，主要是table没有tablet的情况和tablet范围未封闭（没有max)，否则总会找到结果，即使没有对应的tablet，也应该返回OB_ENTRY_NOT_EXIST</p>

<p><strong>OB_ERROR</strong>：可能情况</p>

<ol>
<li> 当前表的元数据表没有指定</li>
<li> 获取root_table_name的时候写入失败</li>
<li> proxy读取tablet的时候结果加入返回列表的时候失败。</li>
<li> proxy构建内部表读取sql语句的时候失败（内存错误或者schema错误或者sql字符串填充失败）</li>
</ol>


<p><strong>OB_ENTRY_NOT_EXIST</strong>：</p>

<ol>
<li> 当前表的元数据表schema不存在。</li>
<li> tablet范围里面有空洞，按照rowkey查找一定范围的tablet之后找不到rowkey所刚好对应的tablet</li>
</ol>


<p><strong>OB_SCHEMA_ERROR</strong>：</p>

<p>  proxy生成sql语句的时候add_rowkey_column_value失败</p>

<p><strong>OB_ERR_NULL_VALUE</strong>：</p>

<p>  proxy生成sql语句的时候add_rowkey_column_value失败</p>

<p><strong>OB_ERR_SQLCLIENT</strong>：</p>

<p>  主要是一些sql调用失败。</p>

<p><strong>OB_ALLOCATE_MEMORY_FAILED</strong>：</p>

<p>  主要是deep copy range失败</p>

<p><strong>以上错误码都会直接返回到上层，只不过部分需要单独处理，比如OB_ENTRY_NOT_EXISTS 和OB_NO_RESULT是否继续迭代还是个问题。</strong></p>

<h2>ObRootTableIterator</h2>

<p>  继承ObRootTabletIterator，实现迭代所有表的所有tablet的功能，如果有table完全没有tablet，则返回OB_NO_TABLET，调用者决定是否继续迭代。</p>

<h3>实现机理</h3>

<p>  通过ObTableSchemaIterator迭代所有table, 每次生成一个table的TableTabletIterator,迭代此iterator直到end，然后继续迭代下一个表。如果遇到tablet_iter的错误，返回错误，除OB_NO_TABLET错误外，调用者应中止迭代。</p>

<h3>错误码与错误对应原因</h3>

<p><strong>OB_ITER_END</strong>：迭代所有表的tablet结束。</p>

<p><strong>OB_NO_TABLET</strong>： 从一个表里没有迭代出任何一个tablet，之后仍可继续迭代。</p>

<p>  其他错误码来自ObTableSchemaIterator和TableTabletIterator</p>

<h2>ObServerTabletIterator</h2>

<p>  继承ObRootTableIterator（仔细看不是tablet）,实现一个server上所有tablet的迭代。</p>

<h3>实现机理</h3>

<p>  迭代所有tablet直到找到有副本分布在这个server上的tablet，然后返回。如果出错，一概中断。</p>

<h3>错误码与错误原因对应</h3>

<p>OB_ITER_END：所有tablet迭代结束。</p>

<p>  其他错误码来自root_table_iterator</p>

<h2>ObAliveRootTableIterator</h2>

<p>  继承ObRootTableIterator（仔细看不是tablet),返回所有表的所有tablet，但是剔除不存活的版本，所以依赖一个ObChunkServerManager指针。</p>

<h2>ObTableTabletFilterVersionIterator</h2>

<p>  继承ObTableTabletIterator，返回所有表的所有tablet，但是剔除版本不等于指定版本的replica。</p>

<h3>错误码及错误原因对应</h3>

<p>OB_NOT_INIT：未初始化。</p>

<p>OB_INVALID_ARGUMENT： 初始化参数不合法。</p>

<h3>ObIteratorUtility</h3>

<p>  工具类，无状态，负责一些iterator数据处理：如剔除不存活的副本（strip_dead_replicas），筛选符合version条件的副本（filter_replica_version）等。</p>

<hr />

<h2>ObRootReplicaIterator</h2>

<p>  所有replica类迭代器，目前只有ObServerReplicaIterator，定义了迭代接口。包含一个ObRootTableIterator的迭代对象，即所有replica迭代器都是基于RootTableIterator迭代所有表的所有tablet的基础上实现的。</p>

<h2>ObServerReplicaIterator</h2>

<p>  迭代某个server上的所有replica(副本)</p>

<h3>实现机理</h3>

<p>  迭代所有tablet，直到得到一个tablet里面的分布在该server上的副本。没有就继续迭代。有错误一概中断。</p>

<h2>ObReplicaIteratorCalculator</h2>

<p>  合并两个replica类迭代器的结果，并返回当前吐出的replica（replica参数）是属于哪个迭代器的（type参数/LEFT_ITER/RIGHT_ITER/BOTH_ITER三种)</p>

<h3>实现机理</h3>

<ol>
<li> 首先置type为both_iter,两个迭代器都前进一步</li>
<li> 如果left_iter的结果> right_iter，吐出right_iter的结果，置type为LEFT_ITER，保存两个结果。</li>
<li> 同理如果right>left,吐出right_iter的结果，置type为RIGHT_ITER,保存两个结果。</li>
<li> 如果right==left，吐出随便哪个结果（左边），置type为BOTH_ITER,保存两个结果。</li>
<li> 之后每次next判断type，type=LEFT_ITER则迭代LEFT_ITER，跟right_iter上次的结果比较，决定吐出哪个，并置位type=left/right/both。RIGHT/BOTH同理。</li>
<li> 如果有单边迭代器中止，比如左边，则置type=RIGHT_ITER, 迭代到结束，反之亦然。</li>
<li> 正常中止条件：两边迭代器都中止。</li>
<li> OB_ITER_END情况下type返回值决定了哪边先结束。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级到ubuntu13.10]]></title>
    <link href="http://cxh.me/2013/10/18/update-to-ubuntu-13-10/"/>
    <updated>2013-10-18T10:49:00+08:00</updated>
    <id>http://cxh.me/2013/10/18/update-to-ubuntu-13-10</id>
    <content type="html"><![CDATA[<p>  Ubuntu13.10可以升级了，版本名称是：“俏丽的蝾螈”。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/ubuntu13_10.jpg" title="俏丽的蝾螈" alt="俏丽的蝾螈"><p class="align-center">俏丽的蝾螈</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过脚本统计代码覆盖率]]></title>
    <link href="http://cxh.me/2013/10/16/user-script-to-get-coverage/"/>
    <updated>2013-10-16T20:56:00+08:00</updated>
    <id>http://cxh.me/2013/10/16/user-script-to-get-coverage</id>
    <content type="html"><![CDATA[<p>  只是记录一下工作里面的一些trick。我发现我对这些trick的兴趣无比的高。</p>

<p>  我们有时候需要在开发机上统计代码覆盖率，这可能是做测试的同学经常的工作，做开发的同学也难免会遇到。对于某些分支复杂的逻辑，代码覆盖工具是极大的助力。</p>

<p>  关于gcc coverage选项和gcov/lcov工具的使用已经在 <a href="http://cxh.me/2013/10/16/test-coverage-percentage-statistics/" title="测试覆盖率统计">上篇文章</a>里面说过了，我们这里说的是如何实现方便的统计和拉取数据并显示。</p>

<!-- more -->


<p>  首先，测试目录和代码目录是分开的，我们在测试目录运行的时候会生成测试文件的代码覆盖率统计，但是实际上被测试的文件的代码覆盖率是在源码目录生成的。这是需要注意的一点，之前我考虑过合并两处的代码覆盖率统计文件，后来发现没有必要，毕竟你关注的是源码目录的统计文件。这样我们通过如下脚本实现代码覆盖率的生成和拉取。</p>

<pre><code>#!/bin/bash
if [ $# = 1 ] ;then
    lcov --capture --directory . --output-file $1.info --test-name $1
    lcov --remove $1.info "/usr*" -o $1.info # remove output for external libraries
    genhtml $1.info --output-directory ~/$1_output --title "$1" --show-details --legend
    rm $1.info
    tar czvf ~/$1.tar.gz ~/$1_output
    rm -rf ~/$1_output
else
    echo 'cover.sh &lt;testname&gt;'
fi
</code></pre>

<p>  解释几点：</p>

<ol>
<li><p> 第四行目的是去掉usr相关的统计，毕竟跟我们没关系。生成的代码打包到HOME目录下。</p></li>
<li><p> 可能会报.gcda文件目录出错，找不到要创建的目录的错误，这种主要用于跨平台情况。
这个是由于.gcda文件的生成默认保存到.o所在的目录，但是如果.o所在目录不存在，就会出现错误。
设置环境变量可以解决这个问题。设置GCOV_PREFIX=/target/run&#8217; 同 GCOV_PREFIX_STRIP=1
则生成的.gcda文件 将会保存到 /target/run/build/foo.gcda。</p></li>
<li><p> 有时候会遇到&#8221;Merge mismatch for summaries&#8221; 的错误，可以将.gcda全部删除或者对整个文件全部编译，而不是单个改变的文件，这个是由于gcda与gcno不相配导致的，因为两者之间都有个时间戳用来记录是不是相同的。</p></li>
</ol>


<p>  然后是关于拉取到本地的问题，直接在bashrc里面配置如下别名好了：</p>

<pre><code>alias getcov="from 你的测试用例.tar.gz &amp;&amp; tar zxvf xxx.tar.gz &amp;&amp; cd xxx"

function from() {m
 scp -r 你的用户名@$你的开发机:$@ .
}
alias html='google-chrome http://localhost:8000; python -m SimpleHTTPServer'
</code></pre>

<p>  这样getcov拉取覆盖率文件，html命令建立webserver并打开浏览器，小trick，用起来舒服而已。</p>

<hr />

<p>  擦，我不得我提醒各位，有时候发现修改了case之后覆盖率并没有提升，这一定不是你的问题，不一定是coverage数据没有更新的问题，不一定是数据没有拉取成功的问题，极有可能是浏览器缓存了数据的问题。</p>

<p>  针对这种问题，我们的解决方法就是：</p>

<p>  <strong>作死地按f5</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下挂载ntfs分区的问题/draft]]></title>
    <link href="http://cxh.me/2013/10/16/linux-mount-ntfs/"/>
    <updated>2013-10-16T10:29:00+08:00</updated>
    <id>http://cxh.me/2013/10/16/linux-mount-ntfs</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试覆盖率统计]]></title>
    <link href="http://cxh.me/2013/10/16/test-coverage-percentage-statistics/"/>
    <updated>2013-10-16T10:15:00+08:00</updated>
    <id>http://cxh.me/2013/10/16/test-coverage-percentage-statistics</id>
    <content type="html"><![CDATA[<h3>什么是代码覆盖率(code coverage)</h3>

<p>  代码覆盖（Code coverage）是软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p>

<p>  代码覆盖主要包括如下四个方面：</p>

<blockquote><ol>
<li>语句覆盖(StatementCoverage)</li>
<li>判定覆盖(DecisionCoverage)</li>
<li>条件覆盖(ConditionCoverage)</li>
<li>路径覆盖(PathCoverage) 或者叫条件/判断覆盖率</li>
</ol>
</blockquote>

<p>  具体的参见参考文献<a href="http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html" title="代码覆盖率浅谈">1</a> <a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87" title="代码覆盖率">2</a>.</p>

<h3>怎么得到覆盖率数据</h3>

<p>  这里我们主要说测试工具的使用的问题。c++的项目测试里面我们用gcc产生测试数据，用gcov和lcov生成测试结果的报表。</p>

<!-- more -->


<p>  gcc这里需要做的工作是编译的时候打开coverage选项，主要是如下几步。</p>

<blockquote><ol>
<li>编译的时候，增加 -fprofile-arcs -ftest-coverage 或者 –coverage；</li>
<li>链接的时候，增加 -fprofile-arcs 或者 –lgcov；</li>
<li>打开–g3 选项，去掉-O2以上级别的代码优化选项；否则编译器会对代码做一些优化，例如行合并，从而影响行覆盖率结果；</li>
</ol>
</blockquote>

<p>  为了方便的在Makefile里面控制是否生成测试覆盖率数据，我们在Makefile里面加入如下开关</p>

<pre><code>ifeq ($(coverage), yes)
    CXXFLAGS       +=  -fprofile-arcs -ftest-coverage
    LINKERCXX      +=  -fprofile-arcs -ftest-coverage
    OPT_FLAGS     =  -g3
endif
</code></pre>

<p>  这样就可以通过make coverage=yes生成。</p>

<p>  同理如果用automake工具的话，Makefile.am里面需要加入如下语句：</p>

<pre><code>if COVERAGE
    CXXFLAGS+=-fprofile-arcs -ftest-coverage
    AM_LDFLAGS+=-lgcov
    OPT_FLAGS =  -g3
endif
</code></pre>

<p>  configure.ac/configure.in脚本里面需要加入</p>

<pre><code>AC_ARG_WITH([coverage],
       AS_HELP_STRING([--with-coverage],
              [with coverage (default is NO)]),
          [
            if test "$withval" = "yes"; then
                coverage=yes
            fi
          ],
          [coverage=no]
   )
AM_CONDITIONAL([COVERAGE], test x$coverage = xyes )
</code></pre>

<p>  就可以通过</p>

<pre><code>./configure --with-coverage来生成Makefile了
</code></pre>

<p>  之后我们可以通过gcov/lcov工具来显示覆盖率的结果，使用帮助参见参考文献<a href="http://sdet.org/?p=212" title="Linux下c/c++项目代码覆盖率的产生方法">3</a> <a href="http://www.cnblogs.com/turtle-fly/archive/2013/01/09/2851474.html" title="[整理] gcov lcov 覆盖c/c++项目入门">4</a>。至于如何在去开发机拉取结果/一些小技巧和容易出现的问题，请看<a href="http://cxh.me/2013/10/16/user-script-to-get-coverage/" title="通过脚本统计代码覆盖率">下一篇博客</a>。</p>

<h3>参考文献</h3>

<blockquote><p>[1] 代码覆盖率浅谈，<a href="http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html">http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html</a></p>

<p>[2] 代码覆盖率，<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87">http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87</a></p>

<p>[3] Linux下c/c++项目代码覆盖率的产生方法，<a href="http://sdet.org/?p=212">http://sdet.org/?p=212</a></p>

<p>[4] [整理] gcov lcov 覆盖c/c++项目入门, <a href="http://www.cnblogs.com/turtle-fly/archive/2013/01/09/2851474.html">http://www.cnblogs.com/turtle-fly/archive/2013/01/09/2851474.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git reset和git revert]]></title>
    <link href="http://cxh.me/2013/10/15/git-reset-revert/"/>
    <updated>2013-10-15T14:50:00+08:00</updated>
    <id>http://cxh.me/2013/10/15/git-reset-revert</id>
    <content type="html"><![CDATA[<h3>git reset 作用</h3>

<p>  git reset 主要完成到版本库某个特定版本的回退，分为如下三种方式</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/git-reset.png" title="git-reset三种方式" alt="git-reset三种方式"><p class="align-center">git-reset三种方式</p></p>

<blockquote><ul>
<li>git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息</li>
<li>git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可</li>
<li>git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</li>
</ul>
</blockquote>

<h3>git revert 作用</h3>

<p>  git revert从字面的理解上跟git reset是一样的，不同之处在于git revert生成一个反向的差异（特定版本-当前版本）然后提交到版本库，相当与做了之前操作的逆操作，这个操作是可以直接在版本库中看到并使用git reset回退的。</p>

<h3>撤销之后恢复</h3>

<p>  git-reset如果执行之后，再想回退到指定版本。//TODO</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn vim 整合方案]]></title>
    <link href="http://cxh.me/2013/10/15/svn-vim-integration/"/>
    <updated>2013-10-15T11:53:00+08:00</updated>
    <id>http://cxh.me/2013/10/15/svn-vim-integration</id>
    <content type="html"><![CDATA[<p>  这也是实际工作中遇到的问题，所以还是分类到了oceabase分类里面。</p>

<p>  遇到的情况是这样的，有可能同时做多个任务的修改，或者说上一个任务的修改并未提交（尚未ship不能提交），但是下一个已经修改了，这样的话，post-review的时候是需要管理post列表的，而不能把所有的修改一起post。之前应该写过一篇文章说一个post-review插件的实现，但是实际上颇为不便，最好的办法是直接在vim里面操作一个修改列表。这里我们首先通过如下方式生成修改列表。</p>

<!-- more -->


<pre><code>alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias std='st|grep ^D '
alias po='echo "#!/bin/sh" &gt;post-review.sh &amp;&amp; echo "post-review \\" &gt;&gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; std &gt;&gt;post-review.sh; stm &gt;&gt; post-review.sh ; vi post-review.sh'
</code></pre>

<p>  之后可以得到类似如下所示的post-review.sh，当然这个是不能直接运行的。</p>

<pre><code>#!/bin/sh
post-review \
M       tests/rootserver/root_table/iterator/test_ob_server_tablet_iter.cpp
M       tests/rootserver/root_table/iterator/test_ob_root_replica_iter.cpp
M       tests/rootserver/root_table/iterator/test_ob_server_replica_iter.cpp
M       tests/rootserver/root_table/iterator/test_iterator_base.h
M       tests/rootserver/root_table/iterator/Makefile.am
M       tests/rootserver/root_table/iterator/test_ob_root_table_iter.cpp
M       tests/rootserver/root_table/iterator/run.sh
M       tests/rootserver/root_table/iterator/test_ob_alive_root_table_iter.cpp
</code></pre>

<p>  我们面临两个问题：</p>

<blockquote><ol>
<li>每行的格式都略有差别，比如前面有A/M/D标记，后面没有续行符号\，没有空格什么的。</li>
<li>需要能够针对每一行或者多行进行svn操作（svn diff/revert 应该是最常见的操作）</li>
</ol>
</blockquote>

<p>  这里我们通过vim脚本实现如下的功能：</p>

<p>  svn.vim 实现如下</p>

<pre><code>function! StripSVN() range
    "Step through each line in the range...
    for linenum in range(a:firstline, a:lastline)
        "Replace loose ampersands (as in DeAmperfy())...
        let curr_line   = getline(linenum)
        let replacement = substitute(curr_line,'^\(A\|M\|D\)','','g')
        call setline(linenum, replacement." \\")
    endfor
    call cursor(linenum)
    "Report what was done...
    if a:lastline &gt; a:firstline
        echo "Strip Svn" (a:lastline - a:firstline + 1) "lines"
    endif
endfunction
function! SVNCommand(cmd, prompt, combine) range
    if a:prompt
        let sure = input("Are you sure? (y/n) ")
        if sure != 'y'
            return
        endif
    endif
    let cmd = '!svn '.a:cmd
    for linenum in range(a:firstline, a:lastline)
        "Replace loose ampersands (as in DeAmperfy())...
        let curr_line   = getline(linenum)
        let replacement = substitute(curr_line,'^\(A\|M\)','','g')
        let replacement = Trim(Trim(replacement,'\\'),' ')
        if a:combine
           let cmd = cmd.' '.replacement.' '
        else
            let cmd = '!svn ' . a:cmd. ' ' . replacement
            execute cmd
            "echo cmd
        endif
    endfor
    if a:combine
        execute cmd
        "echo cmd
    endif
endfunction
</code></pre>

<p>  第一个函数处理每行的格式，第二个函数读取每行的内容，生成命令并执行，prompt=1 的时候会提示并让用户确认， combine=1 的时候所有行会拼成一条执行，否则每行执行一次。</p>

<p>  然后在vimrc中添加：</p>

<pre><code>noremap &lt;leader&gt;sp :call StripSVN()&lt;CR&gt;
noremap &lt;leader&gt;sf :call SVNCommand("diff", 0 ,1)&lt;cr&gt;
noremap &lt;leader&gt;sr :call SVNCommand("revert", 1 ,0)&lt;cr&gt;dd
noremap &lt;leader&gt;sl :call SVNCommand("log", 0 ,0)&lt;cr&gt;
noremap &lt;leader&gt;sa :call SVNCommand("add", 0 ,1)&lt;cr&gt;
noremap &lt;leader&gt;sb :call SVNCommand("blame", 0 ,1)&lt;cr&gt;
noremap &lt;leader&gt;sd :call SVNCommand("delete", 1 ,0)&lt;cr&gt;dd
</code></pre>

<p>  这样实现了两种操作，n状态下在当前行执行操作，v状态下在选中的所有行执行操作。</p>

<hr />

<p>  其实偶然发现我好像没说怎么用，大致流程是这样的：</p>

<blockquote><ol>
<li>po(alias)，生成修改列表</li>
<li>在每个行，或者选中多个行执行svn命令(<leader>sf,<leader>sr什么的)，查看diff啊，回滚啊，查看log啊，查看blame啊</li>
<li>提交前选中所有行执行<leader>sp， 去掉行首的A/M/D标记，在行尾加续行符</li>
<li>执行post-review.sh提交</li>
</ol>
</blockquote>

<hr />

<p>参考文献：</p>

<blockquote><p>[1] SVN 命令参考（svn command reference）, <a href="http://riaoo.com/subpages/svn_cmd_reference.html">http://riaoo.com/subpages/svn_cmd_reference.html</a></p>

<p>[2] 使用脚本编写 Vim 编辑器, <a href="http://www.ibm.com/developerworks/cn/linux/l-vim-script-2/">http://www.ibm.com/developerworks/cn/linux/l-vim-script-2/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于svn commit fail的问题]]></title>
    <link href="http://cxh.me/2013/10/12/svn-commit-failed/"/>
    <updated>2013-10-12T21:39:00+08:00</updated>
    <id>http://cxh.me/2013/10/12/svn-commit-failed</id>
    <content type="html"><![CDATA[<p>  svn commit失败的时候会产生一个svn-commit.tmp 文件， 打开之后发现里面是commit-message，难道下次提交的时候还需要把消息复制进去么？</p>

<p>  看看 svn help commit, 发现有 -F 可以用, 平常都只有用 -m &lsquo;message&rsquo; 而已。定义如下：</p>

<blockquote><p>-F: 会把档案内容读进来, 然后直接 commit, 想当然就用 -F 直接取 svn-commit.tmp 来 commit.</p>

<blockquote><ul>
<li>例: svn ci -F svn-commit.tmp</li>
</ul>
</blockquote></blockquote>

<!-- more -->


<p>  PS: commit 完后, 还是要手动 rm svn-commit.tmp.</p>

<p>  另一个关于commit的问题是，如果 svn ci 进入填充commit-log的交互界面的时候，突然发现提交文件列表有误怎么办？</p>

<p>  其实很简单，只要不保存退出，就会有提示了。保存退出才会直接提交的。放心。</p>

<p>  钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个svn的问题]]></title>
    <link href="http://cxh.me/2013/10/12/several-svn-problems/"/>
    <updated>2013-10-12T19:27:00+08:00</updated>
    <id>http://cxh.me/2013/10/12/several-svn-problems</id>
    <content type="html"><![CDATA[<h3>误用rm删除了未提交文件</h3>

<p>  经常会遇到这种情况：本地修改了一部分东西，增增改改删删，后来发现已经用svn add过的的文件被删除了，但是这个文件只是加入了版本控制，而并不再版本库里，这时候post-review就会有各种问题。如图（前面有感叹号的文件）：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/before_revert.png" title="直接用rm删除的文件" alt="直接用rm删除的文件"><p class="align-center">直接用rm删除的文件</p></p>

<!-- more -->


<p>  解决办法也很简单，我们直接:</p>

<pre><code>svn revert ob_alive_table_tablet_iter.h
</code></pre>

<p>  这时候文件并不会被恢复，但是svn status上已经显示删除了，post-review不会再报错，如下图所示：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/after_revert.png" title="revert之后" alt="revert之后"><p class="align-center">revert之后</p></p>

<h3>版本控制中移除文件</h3>

<p>  经常会遇到错误的把文件加入了版本控制的情况，比如我加了一个Makefile.in到版本控制里（如图），但是svn rm 会同时从版本库和本地删除这个文件，这是我所不希望的，毕竟我还要再跑一遍automake。</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/before-rm.png" title="错误的把Makefile.in加入版本控制" alt="错误的把Makefile.in加入版本控制"><p class="align-center">错误的把Makefile.in加入版本控制</p></p>

<p>  其实 svn rm 提供了keep-local选项来保留本地副本：</p>

<pre><code>svn rm Makefile.in --keep-local
</code></pre>

<p>  执行之后的版本库状态如下图：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/before-rm.png" title="版本控制的状态" alt="版本控制的状态"><p class="align-center">版本控制的状态</p></p>

<p>  从文件管理里面看，这个本地副本依然存在，如下图：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/ll-result.png" title="文件管理里的情况" alt="文件管理里的情况"><p class="align-center">文件管理里的情况</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记几个诡异的bug]]></title>
    <link href="http://cxh.me/2013/10/12/a-strange-error/"/>
    <updated>2013-10-12T15:57:00+08:00</updated>
    <id>http://cxh.me/2013/10/12/a-strange-error</id>
    <content type="html"><![CDATA[<h3>ERROR: mutli target patterns</h3>

<p><s>这个莫名其妙啊，不知道在Makefile.am里改了什么，然后就这样，网上的解释大部分是说target里面有多余的冒号，但是我发现问题啊。最后该来该去bug没了，但是也复现不出来，只是在这里记一下，如果有复现的时候再说。</s></p>

<p>后来 <a href="http://weibo.com/leslieyuchen" title="阿里聿明">聿明</a> 解决了这个问题，原来是编译的线程开太多了，而开发机性能又不好，争用然后冲突。</p>

<pre><code>alias make='make -s -j 4' #这里开到4-5就不要更多了
</code></pre>

<!-- more -->


<h3>ob集群无法启动</h3>

<p>怀疑是机器的问题，但是如果大部分机器我都无法启动这算怎么一回事，</p>

<p>rs的日志如下：</p>

<pre><code>[2013-10-12 14:41:56.484203] WARN  create_first_table (ob_root_bootstrap.cpp:164) [140296887187200] fail to create e
mpty tablet. table_id=111 err=-54
[2013-10-12 14:41:56.484272] WARN  bootstrap_first_table (ob_root_bootstrap.cpp:130) [140296887187200] fail to creat
e first_tablet_entry's tablet. err=-54
[2013-10-12 14:41:56.484289] ERROR do_bootstrap (ob_root_server2.cpp:582) [140296887187200] bootstrap first root table error, err=-54
[2013-10-12 14:41:56.484302] ERROR boot_strap (ob_root_server2.cpp:565) [140296887187200] bootstrap failed! ret: [-54]
[2013-10-12 14:41:56.484314] INFO  ob_root_server2.cpp:570 [140296887187200] ObRootServer2::bootstrap() end:ret[-54]
[2013-10-12 14:41:56.484325] INFO  ob_root_worker.cpp:3129 [140296887187200] admin cmd=16, err=-54
[2013-10-12 14:41:56.484339] WARN  do_admin_without_return (ob_root_worker.cpp:3252) [140296887187200] not supported admin cmd:cmd[16]
</code></pre>

<p>cs的日志如下：</p>

<pre><code>ERROR do_request (ob_chunk_service.cpp:451) [139992810493696] service not started, only accept start schema message or heatbeat from rootserver.
[2013-10-12 14:41:56.480804] INFO  ob_tablet_image.cpp:3133 [139993389482080] begin scan report_tablet_list size:0
[2013-10-12 14:41:56.481673] INFO  ob_general_rpc_stub.cpp:259 [139993389482080] report tablets over, send OB_WAITING_JOB_DONE message.
[2013-10-12 14:41:56.482303] INFO  ob_tablet_manager.cpp:987 [139993389482080] tablet report. typeset=51
[2013-10-12 14:41:56.482321] INFO  ob_tablet_image.cpp:3133 [139993389482080] begin scan report_tablet_list size:0
[2013-10-12 14:41:56.483331] INFO  ob_general_rpc_stub.cpp:259 [139993389482080] report tablets over, send OB_WAITING_JOB_DONE message.
[2013-10-12 14:41:56.483670] ERROR do_request (ob_chunk_service.cpp:470) [139992810493696] call func error packet_code is 219 return code is -1026
</code></pre>

<p>ms的日志如下：</p>

<pre><code>[2013-10-12 14:41:56.510527] WARN  create (../../src/common/hash/ob_hashtable.h:302) [139726122704928] create buckets fail
[2013-10-12 14:41:56.527871] WARN  init (../../src/common/ob_kv_storecache.h:1755) [139726122704928] create map fail
 ret=-1 num=5543383
[2013-10-12 14:41:56.527890] ERROR init (ob_sql_query_cache.cpp:217) [139726122704928] KeyValueCache init error, ret: 1
[2013-10-12 14:41:56.527897] ERROR initialize (ob_mysql_server.cpp:151) [139726122704928] ObSQLQueryCache init error, ret: 1
[2013-10-12 14:41:56.527906] WARN  start (ob_mysql_server.cpp:508) [139726122704928] initialize failed ret is 1
[2013-10-12 14:41:56.527913] ERROR do_work (ob_merge_server_main.cpp:172) [139726122704928] obmysql server start failed,ret=1
[2013-10-12 14:41:56.527982] INFO  ob_mysql_server.cpp:611 [139726122704928] server stoped.
</code></pre>

<p><s>create_bucket失败，这个也不能总是说内存的问题吧&hellip;莫非是大部分开发机都资源不足？我靠谁干的&hellip;.</s></p>

<p>确认了 ms 起不来是因为内存分配失败的问题 感谢 <a href="http://www.weibo.com/u/1912538231" title="瑶瓔">瑶瓔</a> 的辛苦debug</p>

<h3>关于border_flag</h3>

<p>border_flag这事情是很早遗留的问题了，<a href="http://weibo.com/chuanhui85" title="阿里日照">@日照师兄</a> 说过，大概是border_flag和min/max对象两套东西一起在用，目前看直接不要用border_flag的MIN/MAX位就好了，比对的时候会直接跟min/max对象比对的，而忽略了border_flag。但是毕竟有些地方没改过来，比如：</p>

<pre><code>int ObRootTabletInfo::split_tablet(const ObReplica &amp; replica)
{
  int ret = OB_ERROR;
  if (replica.meta_.range_.start_key_ == meta_info_.range_.start_key_)
  {
    if (replica.meta_.range_.end_key_ &lt; meta_info_.range_.end_key_)
    {
      meta_info_.range_.border_flag_.unset_min_value(); #这里需要设置
      meta_info_.range_.start_key_ = replica.meta_.range_.end_key_;
      ret = OB_SUCCESS;
    }
  }
  if (OB_SUCCESS != ret)
  {
    TBSYS_LOG(WARN, "split tablet error:tablet[%s], replica[%s]", to_cstring(meta_info_.range_),
        to_cstring(replica.meta_.range_));
  }
  return ret;
}
</code></pre>

<p>如果split的时候一个tablet已经置位MIN/MAX了，现在分裂的时候后一部分（原tablet split之后的那部分）已经不是MIN-MAX，但是置位还在，就悲催了。</p>

<p>钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review在svn和git共同存在下的冲突问题]]></title>
    <link href="http://cxh.me/2013/10/11/post-review-conflict-under-git-svn/"/>
    <updated>2013-10-11T21:24:00+08:00</updated>
    <id>http://cxh.me/2013/10/11/post-review-conflict-under-git-svn</id>
    <content type="html"><![CDATA[<p>  有时候我们会同时用多种版本管理工具进行管理，或许这听着很eggache，但是有时候确实会发生，比如</p>

<ul>
<li>不习惯某种版本管理工具，希望通过另一种熟悉的版本管理工具进行管理</li>
<li>有些特性是其他的版本管理工具所没有的</li>
<li>开发的版本管理和自己的分支管理策略之间有冲突，开发的版本库不允许随便建立测试分支</li>
</ul>


<!-- more -->


<p>  具体到一种情况下，比如我们有一个svn的版本库，版本管理策略比较严格，而我们需要做一些有风险的本地开发的时候，都原意建立一个test分支，开发确定没有问题之后再合并到master分支，但是现实的情况不允许我们随便建立丢弃分支。这样就可以通过加入一个git的版本管理来实现。</p>

<p>  比如我们建立了一个新的版本库（repository）</p>

<pre><code>mkdir repository.git &amp;&amp; cd repository.git &amp;&amp; git init --bare
</code></pre>

<p>  然后checkout了版本并使当前项目加入版本管理，这里我只会一个笨办法，checkout一个空的，然后mv .git目录进去，有空再研究别的方法。</p>

<p>  之后所有的修改都可以通过git进行管理了，git的version control文件只存在于根目录下，所以也不会污染原有版本库。</p>

<p>  但是post-review的时候就有问题了我们明明有修改，但是post-review总是报错：</p>

<pre><code>  There don't seem to be any diffs!
</code></pre>

<p>  这到底是什么问题呢，启动debug模式运行post-review，结果如下：</p>

<pre><code>&gt;&gt;&gt; RBTools 0.5
&gt;&gt;&gt; Python 2.6.6 (r266:84292, May  1 2012, 13:52:17) 
[GCC 4.4.6 20110731 (Red Hat 4.4.6-3)]
&gt;&gt;&gt; Running on Linux-2.6.32-220.el6.x86_64-x86_64-with-redhat-6.2-Santiago
&gt;&gt;&gt; Home = /xxx
&gt;&gt;&gt; Current Directory = /xxx
&gt;&gt;&gt; Checking the repository type. Errors shown below are mostly harmless.
DEBUG:root:Checking for a Bazaar repository...
DEBUG:root:Checking for a CVS repository...
DEBUG:root:Checking for a ClearCase repository...
DEBUG:root:Checking for a Git repository...
DEBUG:root:Running: git rev-parse --git-dir
DEBUG:root:Running: git config core.bare
DEBUG:root:Running: git rev-parse --show-toplevel
DEBUG:root:Running: git symbolic-ref -q HEAD
DEBUG:root:Running: git config --get branch.master.merge
DEBUG:root:Running: git config --get branch.master.remote
DEBUG:root:Running: git config --get remote.origin.url
DEBUG:root:repository info: Path: /xxx.git, Base path: , Supports changesets: False
&gt;&gt;&gt; Finished checking the repository type.
&gt;&gt;&gt; HTTP GETting api/info/
DEBUG:root:Running: git merge-base origin/master refs/heads/master
DEBUG:root:Running: git diff --no-color --full-index --no-ext-diff --ignore-submodules --no-renames 43351ae337ca18c3f00660c9d565b18a5e904e66..refs/heads/master
There don't seem to be any diffs!
</code></pre>

<p>  可以看到，git的检测优先于subversion，这样当前版本库被当作git管理的版本库来处理了，所以才没有变更。</p>

<p>  解决办法有两个，要么修改RBTool的代码，更改检测优先级，或者post-review之前运行</p>

<pre><code>mv .git git
</code></pre>

<p>  这足够骗过RBTool了。</p>

<p>  钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[霸气风骚的系统监视器htop]]></title>
    <link href="http://cxh.me/2013/10/10/the-best-monitor-under-linux-htop/"/>
    <updated>2013-10-10T20:12:00+08:00</updated>
    <id>http://cxh.me/2013/10/10/the-best-monitor-under-linux-htop</id>
    <content type="html"><![CDATA[<p>做测试和运维的同学都比较熟悉top工具，top工具提供了强大的系统性能监视能力，但是top毕竟比较简陋，而服务器端又不能运行需要X的程序，所以需要一款更人性更强大的系统监视器。HTOP就是一个很好的选择。</p>

<!-- more -->


<h3>介绍</h3>

<blockquote><p>htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。</p>

<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>

<p>与top相比，htop有以下优点：</p>

<ul>
<li>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</li>
<li>在启动上，比top 更快。</li>
<li>杀进程时不需要输入进程号。</li>
<li>htop 支持鼠标操作。</li>
</ul>


<p>htop 官网：<a href="http://htop.sourceforge.net/">http://htop.sourceforge.net/</a></p></blockquote>

<h3>截图</h3>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/htop.png" title="htop截图" alt="htop截图"><p class="align-center">htop截图</p></p>

<h3>安装</h3>

<h4>Ubuntu</h4>

<pre><code>sudo apt-get install htop
</code></pre>

<h4>RHEL/CentOS</h4>

<h5>CentOS 5.x</h5>

<pre><code>32位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm
64位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm
导入key
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL
</code></pre>

<h5>CentOS 6.x</h5>

<pre><code>32位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm
64位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
导入key：
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
</code></pre>

<p>最后执行</p>

<pre><code>yum install htop
</code></pre>

<h4>源码安装</h4>

<pre><code>wget http://nchc.dl.sourceforge.net/project/htop/htop/1.0.1/htop-1.0.1.tar.gz
tar zxvf htop-1.0.1.tar.gz
cd htop-1.0.1
./configure
make
make install
</code></pre>

<h3>参考文献：</h3>

<blockquote><p>[1] （原创）htop：一款比top强悍好用的进程管理监控工具, <a href="http://www.ha97.com/4075.html">http://www.ha97.com/4075.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[去了趟锦州]]></title>
    <link href="http://cxh.me/2013/10/07/tourism-of-jinzhou/"/>
    <updated>2013-10-07T18:34:00+08:00</updated>
    <id>http://cxh.me/2013/10/07/tourism-of-jinzhou</id>
    <content type="html"><![CDATA[<p>  去锦州的原因，其实是没搞到去其他的地方的票。</p>

<p>  十一这个季节，就是人啊人啊人啊人啊人啊人啊人啊人啊人啊人啊人啊&hellip;</p>
]]></content>
  </entry>
  
</feed>
