<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-26T15:02:18+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个关于宏的问题]]></title>
    <link href="http://cxh.me/2014/06/26/a-macro-problem/"/>
    <updated>2014-06-26T10:53:00+08:00</updated>
    <id>http://cxh.me/2014/06/26/a-macro-problem</id>
    <content type="html"><![CDATA[<p>  写了一段代码ss，我想实现宏里面拼接一个变量然后取得这个变量的值的效果，但是没有成功：</p>

<pre><code>#define OB_FIRST_ROOT_TABLE_TID 21
#define OB_INVALID_ID INT_MAX
const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";

struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};


#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from "#table_name)
#define TABLE_BACKUP(table_prefix)\
TABLE_BACKUP_(table_prefix, table_prefix##_TABLE_NAME)

TableBackupSQL table_backup_list_[] =
{
  TABLE_BACKUP(OB_FIRST_ROOT_TABLE)
};


int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/sizeof(TableBackupSQL); i++)
  {
    TableBackupSQL&amp; desc = table_backup_list_[i];
    printf("%d, %s, %s\n", desc.table_id_, desc.table_name_, desc.sql_);
  }
}
</code></pre>

<p>  期望的结果是</p>

<pre><code>21, __first_root_table, select * from __first_root_table
</code></pre>

<p>  实际的结果是</p>

<pre><code>21, __first_root_table, select * from OB_FIRST_ROOT_TABLE_TABLE_NAME
</code></pre>

<p>  拼出来的OB_FIRST_ROOT_TABLE_TABLE_NAME没有被替换，当然有很多方法绕开。我试图两次展开宏但是没有成功，这个跟<a href="http://blog.csdn.net/maray/article/details/11096459" title="介绍一个C++奇巧淫技">这里</a>说的问题毕竟不是一个。不知道C++11里面有没有解决方法。</p>

<p>  另外，我才发现一个struct直接赋值是C++11才允许的。比如：</p>

<pre><code>TableBackupSQL table_backup_list_[] =
{
  {21, "__first_root_table", "select * from __first_root_table"}
};
</code></pre>

<p>  不加-std=c++0x或者 -std=gnu++0x的时候会报错。c语言支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress代码着色]]></title>
    <link href="http://cxh.me/2014/06/22/octopress-code-highlight/"/>
    <updated>2014-06-22T11:15:00+08:00</updated>
    <id>http://cxh.me/2014/06/22/octopress-code-highlight</id>
    <content type="html"><![CDATA[<p>  markdown有自己支持的代码模块，但是想支持着色，就需要单独对代码进行parse和加上css。octopress支持自己的代码语法，但是比较麻烦，并且是本地渲染，对不同语言需要指定。</p>

<p>  所以还是js渲染比较方便一点，我们可以用<a href="https://code.google.com/p/google-code-prettify/" title="google code prettify">google code prettify</a>进行着色，在markdown里面只要对代码加入缩进（tab或者四个空格）。服务端引入如下js:</p>

<pre><code>&lt;link href="http://cxh.me/javascripts/google-code-prettify/prettify.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;
&lt;script type="text/javascript" src="http://cxh.me/javascripts/google-code-prettify/prettify.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" &gt;
&lt;!--
    $(function() {
      $('pre').addClass('prettyprint').attr('style', 'overflow:auto');
      window.prettyPrint &amp;&amp; prettyPrint();
      $('table').addClass('table')
});
--&gt;
&lt;/script&gt;
</code></pre>

<p>  google code prettify的样式可以<a href="http://jmblog.github.io/color-themes-for-google-code-prettify/" title="google code prettify theme">这里</a>选择，关于行号的一些问题参见<a href="http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/" title="Jekyll中使用google-code-prettify高亮代码">这里</a>。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] google code prettify, <a href="https://code.google.com/p/google-code-prettify/">https://code.google.com/p/google-code-prettify/</a></p>

<p>[2] google code prettify theme, <a href="http://jmblog.github.io/color-themes-for-google-code-prettify/">http://jmblog.github.io/color-themes-for-google-code-prettify/</a></p>

<p>[3] Jekyll中使用google-code-prettify高亮代码, <a href="http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/">http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直接从markdown生成各种电子书]]></title>
    <link href="http://cxh.me/2014/06/21/generate-several-types-using-pandoc/"/>
    <updated>2014-06-21T21:23:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/generate-several-types-using-pandoc</id>
    <content type="html"><![CDATA[<p>  有时候我们需要把编辑的markdown转成各种格式，这不失为一种写书的方式。借助pandoc这把瑞士军刀，我们可以实现一个脚本编译各种格式的功能，代码如下：</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:build.py
import glob,os,sys,shutil

cmd_template={'html':"pandoc %s -o output/html/%s.html --template=default.html",
              'pdf':'pandoc -N --toc --template=default.latex --latex-engine=xelatex %s -o output/pdf/%s.pdf',
              'beamer': 'pandoc -N -t beamer --toc --template=default.beamer --latex-engine=xelatex %s -o output/beamer/%s.pdf',
              'epub': 'pandoc %s -o output/epub/%s.epub'
             }

if __name__ == '__main__':
    if len(sys.argv) &gt; 2:
        print 'Usage: build.py [pdf|html|epub|beamer]'
    else:
        out_type = 'html' if len(sys.argv) == 1 else sys.argv[1]
        assert(out_type in cmd_template)

    os.system('cat *.md &gt; swift_book.mkd')
    cmd = [os.system(cmd_template[out_type] %(path, os.path.splitext(path)[0])) for path in glob.glob("*.md")]
    cmd += [os.system(cmd_template[out_type] %('swift_book.mkd', 'swift_book'))]
    print cmd

    if out_type == 'html':
        try:
            shutil.rmtree('output/html/pic')
        except Exception , e:
            pass
        shutil.copytree("pic",'output/html/pic')
</code></pre>

<!--more-->


<p>  为此你需要<a href="http://johnmacfarlane.net/pandoc/installing.html" title="pandoc">安装一下pandoc</a>，需要pdf支持的话还需要<a href="https://www.tug.org/texlive/" title="texlive">装一下texlive</a>，用法如下：</p>

<pre><code>build.py [pdf|html|epub|beamer]

需要如下的目录结构：

    output  - beamer
            - pdf
            - epub
            - html
                - pic
</code></pre>

<p>   另外，脚本会拼一份合集在目录下，所以需要markdown文件有序，比如9.md会拼在10.md后面，所以需要9.md改名为09.md。</p>

<p>  一个使用的例子可以看<a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese" title="The-Swift-Programming-Language-in-Chinese">这里</a>。那些template都是模板文件，可以参考上面例子里的。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] The-Swift-Programming-Language-in-Chinese, <a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese">https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese</a></p>

<p>[2] pandoc, <a href="http://johnmacfarlane.net/pandoc/">http://johnmacfarlane.net/pandoc/</a></p>

<p>[3] pandoc, <a href="http://johnmacfarlane.net/pandoc/installing.html">http://johnmacfarlane.net/pandoc/installing.html</a></p>

<p>[4] texlive, <a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review插件]]></title>
    <link href="http://cxh.me/2014/06/21/ppost-review-plugin/"/>
    <updated>2014-06-21T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/ppost-review-plugin</id>
    <content type="html"><![CDATA[<h3>post-review.vim</h3>

<p>A plugin to generate post-review script</p>

<h3>Usage</h3>

<h4>install:</h4>

<pre><code>git clone https://github.com/chenxiaohui/post-review.vim 
</code></pre>

<p>put post-review.vim to your $VIM/plugin</p>

<p>add this to your vimrc</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>process:</h4>

<p>svndiff use vimdiff: see <a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">link</a></p>

<p>gitdiff use vimdiff: see <a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">link</a></p>

<p><img src="http://cxh.me/images/2013/git-vimdiff.png"></p>

<!--more-->


<p>first use svn diff/git diff and open vimdiff to see the difference</p>

<p>secondly when you consider the changed file needs to be posted , use <leader>pr to add it to post-review.sh</p>

<p>if you has no post-review.sh on your base_dir( specified by the g:base_dir_mark), you need to input the review id or just enter for a new review.</p>

<p>after you added all files you need to review, chmod +x post-review.sh and execute it.</p>

<p>(if you set g:chmod_after_create to 1 you will not need to chmod +x)</p>

<hr />

<p>  请无视楼主以上装逼的英文:</p>

<h3>post-review.vim</h3>

<p>  就是一个用来从vimdiff记录需要Post-review的文件的插件</p>

<p>  不知道Post-review的同学请google之, 用百度搜索的同学自觉面壁去</p>

<h3>用法</h3>

<h4>安装</h4>

<p>  统共分三步:</p>

<p>1.下载解压(或者git clone) url:<a href="https://github.com/chenxiaohui/post-review.vim">https://github.com/chenxiaohui/post-review.vim</a>
2.放到$VIM/plugin目录下(原谅我不写doc的习惯)
3.在vimrc中添加</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>使用</h4>

<p>  比如说Jack正欢快的写着代码呢，然后Jack要提交, 猛然发现好多修改啊</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<blockquote><p>难道不应该写一部分就post-review的嘛</p></blockquote>

<p>  好了不要care这种细节, 然后Jack需要一个一个查看修改的文件, 确定是放到哪个Post-review中提交</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<pre><code>What a fucking job!!!
</code></pre>

<p>  这时候你需要的就是这一款全自动, 人性化, 帮你生成post-review命令的插件, 只要998, 打进电话你就能拥有它&hellip;</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<blockquote><p>跑题了&hellip;</p></blockquote>

<p>  好了, 我们先svn diff或者git diff一下, 为了保证你看到的是如下界面请参考<a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">这里</a>或者<a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">这里</a>.</p>

<p><img src="http://www.ccvita.com/usr/uploads/2011/svn_diff.png" title="svndiff" alt="" /></p>

<p>  好了, 在你需要提交文件的那个窗口用快捷键<leader>pr, 标记完了所有的文件之后进入你的根目录(根目录是什么, 这个待会再说, 不要care这种细节), 下面是不是有一个post-review.sh了? 没有? 卧槽&hellip;男子汉大丈夫, 我写的插件, 有问题&hellip;.我也不承认&hellip;</p>

<p>  最后, 两个配置项:</p>

<pre><code>let g:base_dir_mark = 'cscope.out'
</code></pre>

<p>  制定了一个根目录标志, 也就是说你需要在你的项目根目录找一个(或者建一个)独一无二的文件(比如.git, cscope.out, tags)之类, 让插件去寻找这个文件, 找到之后就标识这个目录为根目录. 跟ctrlp学的.</p>

<pre><code>let g:chmod_after_create = 0
</code></pre>

<p>  无聊的选项, 建立完post-review之后是不是chmod +x, 无视它.</p>

<p>  发起新的post-review的时候建议把post-review.sh清空或者删除, 重复添加同一个文件的时候会判断.</p>

<p>  好了, 也就想到这么多了, 有其他的再补充, 钦此.</p>

<p>注：其实最后我发现还是这样更容易：</p>

<pre><code>alias st='svn st'
alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias po="echo 'post-review -d' &gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; stm &gt;&gt; post-review.sh ; chmod +x post-review.sh ;sed -i 's/^[MA]\s\+//g' post-review.sh;sed -i 's/$/ \\\\/g' post-review.sh;vi post-review.sh"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试一下机器和镜头]]></title>
    <link href="http://cxh.me/2014/06/21/photography-test/"/>
    <updated>2014-06-21T13:24:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/photography-test</id>
    <content type="html"><![CDATA[<p>  测试一下机器，镜头是18-55套头，表现中规中矩吧，K10D色彩不错。图压缩过。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/flower.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本文件和二进制文件读写]]></title>
    <link href="http://cxh.me/2014/06/21/bin-txt-file-read-write/"/>
    <updated>2014-06-21T12:28:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/bin-txt-file-read-write</id>
    <content type="html"><![CDATA[<p>  探究这个的起因是我在序列化一个数据结构，用二进制写到文件之后用vim打开发现后面居然多了一个值。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/binfile.png" title="用vim显示二进制文件" alt="用vim显示二进制文件"><p class="align-center">用vim显示二进制文件</p></p>

<p>  所以总结一下文件的两种不同写入方式。(当然上面是vim里面xxd显示的问题)</p>

<p>  我们用如下代码测试:</p>

<pre><code>int main(int argc, const char *argv[])
{
  FILE * fp  = fopen("output.txt", "w");
  fputc(10, fp);
  fputc(13, fp);
  fputc('\n', fp);
  fclose(fp);

  fp  = fopen("output.bin", "wb");
  int32_t length[] ={0x0a, 0x12345678};
  fwrite(&amp;length, sizeof(int32_t), 2, fp);
  fclose(fp);
  return 0;
}
</code></pre>

<!--more-->


<p><strong>windows下</strong></p>

<p>文本文件写入：</p>

<pre><code>0000000: 0d0a 0d0d 0a                             .....
</code></pre>

<p>二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>linux下：</strong></p>

<p>  文本方式写入</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入：</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>mac下</strong></p>

<p>  文本方式写入：</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p>  解释几个问题：</p>

<h3>回车符的转义</h3>

<p>  windows下写文本文件的时候换行符会被替换成回车换行(0d0a), 直接写0a(10)也是一样的. Linux和mac下不会,二进制文件不care这些.</p>

<h3>文件结尾判断</h3>

<p>  详见这里：<a href="http://blog.csdn.net/bingqing07/article/details/5785080">http://blog.csdn.net/bingqing07/article/details/5785080</a></p>

<h3>UTF-8 BOＭ</h3>

<p>  转载：</p>

<blockquote><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。
所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。
BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。
「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sublime根据markdown引用生成参考文献的插件]]></title>
    <link href="http://cxh.me/2014/06/20/susublime-plugin-to-generate-refrence/"/>
    <updated>2014-06-20T21:21:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/susublime-plugin-to-generate-refrence</id>
    <content type="html"><![CDATA[<p>  写这个的目的主要是每次写博客需要生成以下版权声明，免得引用了别人的文章被人说盗版。markdown里面支持通过列表组织引用的url，如下所示：</p>

<pre><code>  [1]: http://www.baidu.com   "百度"
  [2]: http:://www.google.com "谷歌"
  [3]: http://www.facebook.com "404 Not Found"
</code></pre>

<p>  我们可以通过这个形式来生成如下的代码</p>

<pre><code>###参考文献:

&gt;\[1] 百度, &lt;http://www.baidu.com&gt;

&gt;\[2] 谷歌, &lt;http:://www.google.com&gt;

&gt;\[3] 404 Not Found, &lt;http://www.facebook.com&gt;
</code></pre>

<p>  效果如下：</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 百度, <a href="http://www.baidu.com">http://www.baidu.com</a></p>

<p>[2] 谷歌, <a href="http:://www.google.com">http:://www.google.com</a></p>

<p>[3] 404 Not Found, <a href="http://www.facebook.com">http://www.facebook.com</a></p></blockquote>

<!--more-->


<p>  代码如下:</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:generate_ref.py

import sublime, sublime_plugin

class GeneraterefCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        sels = self.view.sel()
        lines=[]
        for sel in sels:
            lines += (self.view.substr(sel)).strip("\n").split("\n")
        outlines=[]
        for line in lines:
            idx1 = line.find(":")
            index = line[:idx1]
            idx2 = line.find('"', idx1)
            url = line[idx1+1:idx2].strip(' ')
            title = line[idx2:].strip('"')
            outlines.append('\n&gt;\%s %s, &lt;%s&gt;'%(index,title,url))
        self.view.insert(edit, sel.end(),"\n###参考文献:\n".decode("utf-8") + "\n".join(outlines))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress支持markdown表格]]></title>
    <link href="http://cxh.me/2014/06/20/octopress-pandoc-table/"/>
    <updated>2014-06-20T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/octopress-pandoc-table</id>
    <content type="html"><![CDATA[<p>   pandoc支持扩展的markdown，也就是支持类似于如下的表格：</p>

<pre><code>-----------------------------------------------------------------------------------------------------------------
测量指标                    低程度中心性             低亲近中心性                      低居间中心性
--------------------   -------------------   -----------------------------  -------------------------------------
高程度中心性                                        “自我”所嵌入的聚类                “自我”的联系人是冗余的，
                                                   远离网络中其他节点                整个世界绕他而行


高亲近中心性               是联系重要他人或                                       在事件中，自我位于一个相互
                         活跃人物的关键人物                                     联系密切、活跃的聚类中，与
                                                                             很多节点都很接近；其他节点也是如此
------------------------------------------------------------------------------------------------------------------
: 表3-1 不同中心性测量指标之间的关系[^16]
</code></pre>

<p>  效果可以渲染成这样：</p>

<table>
<caption>表3-1 不同中心性测量指标之间的关系[^16]</caption>
<col width="20%" />
<col width="19%" />
<col width="27%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">测量指标</th>
<th align="center">低程度中心性</th>
<th align="center">低亲近中心性</th>
<th align="center">低居间中心性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">高程度中心性</td>
<td align="center"></td>
<td align="center">“自我”所嵌入的聚类 远离网络中其他节点</td>
<td align="center">“自我”的联系人是冗余的， 整个世界绕他而行</td>
</tr>
<tr class="even">
<td align="left">高亲近中心性</td>
<td align="center">是联系重要他人或 活跃人物的关键人物</td>
<td align="center"></td>
<td align="center">在事件中，自我位于一个相互 联系密切、活跃的聚类中，与 很多节点都很接近；其他节点也是如此</td>
</tr>
</tbody>
</table>




<!--more-->


<p>  插件如下。</p>

<pre><code>require 'pathname'

module Jekyll
  class PandocTag &lt; Liquid::Tag
    def initialize(tag_name, markup, tokens)
      @file = nil
      if markup.strip =~ /(\S+)/i
        @file = $1
      end
      super
    end

    def render(context)
      code_dir = (context.registers[:site].config['pandoc_dir'].sub(/^\//,'') || 'pandoc')
      code_path = (Pathname.new(context.registers[:site].source) + code_dir).expand_path
      file = code_path + @file
      outfile = code_path + "output.html"
      if File.symlink?(code_path)
        return "Code directory '#{code_path}' cannot be a symlink"
      end

      unless file.file?
        return "File #{file} could not be found"
      end

      Dir.chdir(code_path) do
        system "pandoc -o output.html -f markdown -t html #{file}"
        outfile.read
      end
    end
  end

end

Liquid::Template.register_tag('pandoc', Jekyll::PandocTag)
</code></pre>

<p>  使用的时候先生成一个md文件，放在source/pandoc（随便设定）目录下。插件只是生成了html文件然后read进来了而已，所以有点傻，比如下面我的代码放到缩进里面还是被执行了。</p>

<p>  最后用如下语法载入（去掉空格）：</p>

<pre><code>{ % pandoc test.md % }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress的缩进插件]]></title>
    <link href="http://cxh.me/2014/06/20/octopress-indent-plugin/"/>
    <updated>2014-06-20T20:45:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/octopress-indent-plugin</id>
    <content type="html"><![CDATA[<p>  我们写中文的时候通常有首行缩进的需求，markdown默认是不支持的，octopress和wordpress也没有缩进的css。这里我们通过加个插件的方式完成。</p>

<p>  首先，处理markdown的渲染。我们建立如下插件:</p>

<pre><code>    module Jekyll
    module IndentFilter
        def indent(content)
            content.gsub(/&lt;p&gt;\s\s/, '&lt;p class="indent"&gt;')
        end
    end
end

Liquid::Template.register_filter(Jekyll::IndentFilter)
</code></pre>

<p>  这个就是做了个替换。会把行首的两个字符替换成一个css标签。然后加个css在系统css里面就行了：</p>

<pre><code>.indent{text-indent:2em;}
</code></pre>

<!--more-->


<p>  需要注意的是，整个文章的缩进层次可以这样使用：</p>

<pre><code># first
## second
## third
** bold **
no indent
* item
  indent
  &gt; * indent item
</code></pre>

<p>  效果如下所示：</p>

<h1>first</h1>

<h2>second</h2>

<h2>third</h2>

<p><strong> bold </strong></p>

<p>no indent</p>

<ul>
<li><p>item</p>

<p>indent</p></li>
</ul>


<blockquote><ul>
<li>indent item</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase设计中的注意事项]]></title>
    <link href="http://cxh.me/2014/06/19/oceanbase-design-notes/"/>
    <updated>2014-06-19T21:37:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/oceanbase-design-notes</id>
    <content type="html"><![CDATA[<ol>
<li>没有情况什么是不可能发生的</li>
<li>RPC或者其他网络调用是不一定能够返回结果的。也就是有三种可能，正确，失败，超时。</li>
<li>开发文档是需要一边写一边改最后再补的。</li>
<li>自顶向下，逐步求精还是有效的办法。方便解决很多设计上想不到的地方，细节永远最后再做，毕竟之前想的可能过一段时间决定不做了。</li>
<li>复杂任务要分成多个可测试的阶段完成，每个阶段保证能单独测试。为此多写一些代码也是值得的。</li>
<li>我们不是业务驱动，也不是技术驱动，而是测试驱动的&hellip;..</li>
<li>做好单测</li>
<li>做好单测&hellip;</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成像入门]]></title>
    <link href="http://cxh.me/2014/06/19/phphotography-theorem/"/>
    <updated>2014-06-19T19:00:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/phphotography-theorem</id>
    <content type="html"><![CDATA[<p>其实我只是感性的解释一下一些基本的原理。</p>

<ol>
<li><p>成像同一个点发出的所有光线在焦平面汇聚的结果。从原理上讲，小孔成像是更优的成像方式，因为小孔过滤了光线，让每个像点发出的光只有一束能参与成像，但是这样容易导致亮度偏低，同时小孔也不能像理论上说的足够小。</p></li>
<li><p>如果胶片/CCD刚好位于焦平面上，那么成像最清晰，焦平面前后的一段距离里面，成像虽然不够清晰但是也能接受，出了这个区域就认为不再能够成像。这个区域就是弥散斑所在的区域。对应的物体距离范围叫景深。</p></li>
<li><p>镜片如果折光度高的话，那么成像位置靠前，像小，同时光线密度增加导致景深增加。这就是短焦距镜片，短焦镜片的视角大。也就是说够光范围内的光都会被折射到成像底板的区域里。适合拍风景等大画幅照片，广角镜头就是这类。</p></li>
<li><p>相反，如果镜片折光度小，那么成像位置就靠后，像大，同时光线密度减少导致景深减少。这就是长焦镜头，长焦镜头视角小，景深小，适合拍人像，可以造成虚化的效果，同时也适合打鸟，毕竟放大倍数高，不易被发现。</p></li>
<li><p>同时，光圈也影响景深。在焦距一定的情况下，小光圈遮挡了周围的光线，由于中间部分折光系数高，所以增加了景深。由于入射光强度降低，要想保证成片的明度，就需要加大ISO，增加快门时间。反过来，大光圈会减少景深，由于入射光强度高，可以减少ISO，减少快门时间。所以说大光圈长焦是人像利器。</p></li>
<li><p>普通卡片机由于照顾日常使用场景，焦距光圈基本是固定的，并且固定在中短焦距的范围内。所以卡片机画幅不大，景深也不大，适合一般场景的拍照，但难免平淡无特色。</p></li>
</ol>


<p><img class="img-polaroid center" src="http://cxh.me/images/2014/photography.gif" title="成像光路图" alt="成像光路图"><p class="align-center">成像光路图</p></p>

<h3>参考文献:</h3>

<blockquote><p>[1] 一篇讲解成像原理的文章, <a href="http://blog.sina.com.cn/s/blog_64cff0510100hid1.html">http://blog.sina.com.cn/s/blog_64cff0510100hid1.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 安装配置总结]]></title>
    <link href="http://cxh.me/2014/06/19/nnginx-install-config/"/>
    <updated>2014-06-19T11:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/nnginx-install-config</id>
    <content type="html"><![CDATA[<p>具体的可以看参考文献里面的三篇博客，中间遇到一个问题，nignx提示无法找到php文件。主要有两个原因：</p>

<ol>
<li><p>确定nginx工作线程的启动用户有权限访问www-root，需要修改nginx.conf的这里：</p>

<pre><code> user  www-data;
</code></pre></li>
<li><p>确定www-root配置正确，需要修改这里：</p>

<pre><code> fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
</code></pre></li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] nginx配置入门, <a href="http://www.nginx.cn/591.html">http://www.nginx.cn/591.html</a></p>

<p>[2] Nginx安装, <a href="http://www.nginx.cn/install">http://www.nginx.cn/install</a></p>

<p>[3] nginx php-fpm安装配置, <a href="http://www.nginx.cn/231.html">http://www.nginx.cn/231.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[总结STL的通用算法基本形式]]></title>
    <link href="http://cxh.me/2014/06/19/stl-algorithm-signature/"/>
    <updated>2014-06-19T09:58:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/stl-algorithm-signature</id>
    <content type="html"><![CDATA[<p>stl的通用算法基本有如下四种形式：</p>

<ol>
<li>alg(beg, end, params)：使用源输入作为输出</li>
<li>alg(beg, end, dest, params) ：使用dest作为输出，需要保证有足够的空间，所以往往使用inserter</li>
<li>alg(beg, end, beg2, other params)：beg2作为输出，假定beg2开始的范围至少跟beg和end指定的范围一样大。</li>
<li>alg(beg, end, beg2, end2, params)：beg2 end2作为输出</li>
</ol>


<p>举例：</p>

<p>第一种比如：</p>

<pre><code>find(beg, end, search_value);
sort(beg, end);
accumulate(beg, end, original_value);
fill(beg, end, value); //特殊的：fill_n(begin, count, n)
replace(beg, end, value, replace_value);
unique(beg, end);
count(beg, end, value);
stable_sort(beg, end);
reverse(beg, end);
</code></pre>

<p>第二种比如：</p>

<pre><code>copy(beg, end, back_inserter(vector));
</code></pre>

<p>第三种比如：</p>

<pre><code>replace_copy(beg, end, beg2, value, replace_value);
unique_copy(beg, end, beg2);
reverse_copy(beg, end, beg2);
</code></pre>

<p>第四种比如：</p>

<pre><code>find_first_of(beg, end, beg2, end2);
</code></pre>

<p>另外，有的算法支持谓词，比如</p>

<pre><code>sort(beg, end, comp)
find_if(beg, end, comp)
count_if(beg, end, comp)
</code></pre>

<p>有的算法有copy和非copy版，比如</p>

<pre><code>replace(beg, end, value, replace_value);
unique(beg, end);

replace_copy(beg, end, beg2, value, replace_value);
unique_copy(beg, end, beg2);    
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c/c++ 文件/流读取函数总结]]></title>
    <link href="http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function/"/>
    <updated>2014-06-16T20:00:00+08:00</updated>
    <id>http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function</id>
    <content type="html"><![CDATA[<h3>针对文本文件的，  c++主要有如下几种吧</h3>

<ol>
<li><p>getline： 实现上，输入istream流，需要支持特定traits的迭代器。从流里面每次一行读入string，遇到delim结束。</p>

<pre><code>   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str, _CharT __delim);

   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     inline basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str);
</code></pre></li>
</ol>


<!--more-->


<ol>
<li><p>stream.get/put：分为如下几种类型。</p>

<ol>
<li>不接收参数的直接返回结果</li>
<li>接收一个char类型的参数</li>
<li>接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</li>
<li>put直接输入一个字符</li>
<li><p>get 系的函数都不会ignore delim分隔符的，读到行尾需要手动ignore回车</p>

<pre><code>   int_type 
   get(void);

   __istream_type&amp; 
   get(char_type&amp; __c);

   __istream_type&amp; 
   get(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   get(char_type* __s, streamsize __n)

   __istream_type&amp;
   get(__streambuf_type&amp; __sb, char_type __delim);

   inline __istream_type&amp;
   get(__streambuf_type&amp; __sb)

   // Unformatted output:
   __ostream_type&amp; 
   put(char_type __c);
</code></pre></li>
</ol>
</li>
<li><p>stream.getline()：接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</p>

<pre><code>   __istream_type&amp; 
   getline(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   getline(char_type* __s, streamsize __n)
</code></pre></li>
<li><p>stream.read/stream.write()： 二进制操作，读写一段数据。</p>

<pre><code>   __istream_type&amp; 
   read(char_type* __s, streamsize __n);

   streamsize 
   readsome(char_type* __s, streamsize __n);

   __ostream_type&amp; 
   write(const char_type* __s, streamsize __n);
</code></pre></li>
<li><p>输入输出运算</p></li>
</ol>


<h3>c大概有如下几个：</h3>

<ol>
<li> fgetc/fputc</li>
<li> fgets/fputs</li>
<li> fscanf/fprintf</li>
<li><p> fread/fwrite</p>

<pre><code>__STDIO_INLINE _IO_ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
</code></pre></li>
</ol>


<p>  另外，stdio.h里也有getline的实现，传入一个FILE指针。需要注意的是传入的char **指针是会被申请内存并赋值的。所以需要自己释放。</p>

<p>  这里就不详述了，详见：
  <a href="http://zhaoyuqiang.blog.51cto.com/6328846/1296902">http://zhaoyuqiang.blog.51cto.com/6328846/1296902</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记工作中遇到的一个性能问题]]></title>
    <link href="http://cxh.me/2014/06/15/a-performance-problem/"/>
    <updated>2014-06-15T12:16:00+08:00</updated>
    <id>http://cxh.me/2014/06/15/a-performance-problem</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个问题，更新schema的过程发现耗时太长，30多s。导致其他一系列流程阻住。记录一下这个问题的分析解决。</p>

<p>  开始觉得估计是数据量大sql执行时间过长，整个过程分为3条sql，也就是schema被分表成为的三个表的查询：</p>

<pre><code>    select * from __all_table;  //主键table_id
    select * from __all_column; //主键table_id,column_id
    select * from __all_join;//主键left_table_id, let_column_id
</code></pre>

<p>   之后在内存里面做Join。由于是有序的，所以join过程直接采用了二分查找。之于没有用散列做Join或者直接
   SQL语句里做Join的原因，只能说是历史遗留问题了。</p>

<p>   在三个执行过程中加计时，跑一下，发现结果如下：</p>

<pre><code>    all_table表查询，建立TableSchema对象并插入Array，20+s
    all_column查询， 二分找到对应的TableSchema，填入Column，10+s
    all_join查询，二分找到对应的TableSchema，填入JoinInfo，0.xs，忘了
</code></pre>

<!--more-->


<p>   问题很明显出在第一个上面。Perf分析一下程序执行过程，发现大量时间耗费在TableSchema的Operator=上面。我们的编程习惯是自己实现Operator=，拷贝构造直接调用自己的=重载。所以要么是拷贝构造占用了大量时间，要么是赋值占用了大量时间。</p>

<p>   同时，在命令行执行一下SQL查询，发现第一条SQL查询花费1s左右，而第二条花费10s，第三条表里没有数据。从数据量来看，大概也是这个数量级，因为column表里面存放所有table的列信息，意味着平均每个表有10个列。这条SQL在客户端默认的超时时间下会直接Timeout。</p>

<p>   考虑这个过程里面，运算符=的调用确实也只可能发现在第一个过程，因为后面都是直接填充里面的属性值。赋值的操作只有可能发生在动态表扩展。为了屏蔽一下扩展再分析，我们直接在Array建立前Reserve一下内存空间。也就是考虑到有18000+张表，直接Reserve(20000)。</p>

<p>   重跑发现总时间直接降到了13s，去掉第二条sql的执行时间（第三个过程忽略），第一个过程在1s之内返回。所以问题就处在动态表扩展上。</p>

<p>   我们知道算法上的动态表设计，每次扩展的时候是两倍申请空间，拷贝之前的对象到新地址空间，再析构之前的对象。这也就意味着20000张表扩展了log2(20000)，15次的样子(可能有个默认reserve数值)。当然问题也可以通过reserve这么解决了，但是流式接口，不能在数据迭代完毕之前知道有多少行数据。所以需要额外发起一次count()查询。但是再查询一次的开销还不如浪费点空间。</p>

<p>   继续分析，减少reserve值到10000发现根本没有效果，还是一样的耗费20s，这就意味着之前的所有expand的影响都没有最后一次大。但是这个明显不合理，因为1+2+4+&hellip;2<sup>n</sup> = 2<sup>n+1</sup> &ndash; 1，意味着之前所有的拷贝合并起来一定跟最后一次拷贝数量相当。时间上也应该占用一半。考虑到大内存分配跟小内存分配在我们的内存池里面开销差异不大，所以还是扩展上的问题。</p>

<p>   在Array的extend上加日志，继续跑。发现问题就在这里了，有大量的expand，这就意味着扩展的开销远大于我们考虑的情形。看ObArray的源码，发现实现上并不是我们理解的二倍扩展，ObArray的实现是每次扩展一个固定的大小(block_size/元素大小） ，而这个blocksize默认值是64k，算算我们的TableSchema有3k大小，也就是每20个就扩展了一次。在18000+的表构建过程中，扩展了差不多1000次。</p>

<p>   针对这个问题，我们把ObArray的扩展大小从64k提升到2M，扩展次数降低到100次以内。时间上，虽然不如直接reserve（20000），但是已经回到2s，整个过程在14s内。基本达到要求。</p>

<p>   后续就需要分析SQL查询是否能加快了。当然我把_all_column加入TableSchema的那个过程也reserve了一下，避免TableSchema里面column数组在每次push一个列的时候引起扩展，因为平均看，一个table所包含的平均列数也就10左右。性能待测试。</p>

<p>   从这个问题吸取的教训就是，动态表能之前确定长度的最好直接Reserve，否则相当于有多次申请内存-析构-拷贝构造（或赋值，我们之前是赋值）-释放内存的开销。同时，Perf是个好工具，虽然我还不是很熟悉。</p>

<p>   关于vector的扩容见<a href="http://blog.csdn.net/sodickbird/article/details/4594907" title="深入浅出vector resize/reserve">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式选主-笔记]]></title>
    <link href="http://cxh.me/2014/06/10/distributed-selection/"/>
    <updated>2014-06-10T21:08:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/distributed-selection</id>
    <content type="html"><![CDATA[<h3>数据库主备复制</h3>

<p>同步模式</p>

<ul>
<li>备机是否写盘之后应答</li>
<li>性能收主备机之间通讯距离，网络抖动影响</li>
</ul>


<p>异步模式</p>

<ul>
<li>主机不等待备机的应答</li>
<li>性能最优，可能造成数据丢失不一致</li>
</ul>


<p>半异步</p>

<ul>
<li>超过多数成功则返回</li>
<li>奇数台机器才可以</li>
<li>3/5 > 2/3 > 2/2</li>
</ul>


<!--more-->


<h3>网络</h3>

<ul>
<li>任意两个进程可以传递消息</li>
<li>进程有本地物理时钟 时钟使用NTP同步</li>
<li>超时有上限</li>
<li>进程不会发错误的消息</li>
</ul>


<h3>分布式选举基本问题</h3>

<p>不可靠的机群实现可靠的协议，通过投票的方案</p>

<ul>
<li>任意时刻只能有一个主</li>
<li>要容忍网络分区</li>
<li>Leader Lease，选主要等待上个主的lease过期</li>
<li>Lease周期的长短</li>
</ul>


<p>Paxos要求</p>

<ol>
<li>成员不能说假话（非拜占庭）</li>
<li>单个成员说话不能相互矛盾（投票给A了不能投票给B）</li>
<li>修改需要多数成员同意</li>
</ol>


<p>实现</p>

<ol>
<li>记住自己在lease周期的投票</li>
<li>重启等待一个lease周期不投票</li>
<li>多个人都想成为主的时候</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase事务引擎-笔记]]></title>
    <link href="http://cxh.me/2014/06/10/o-transaction/"/>
    <updated>2014-06-10T19:39:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/o-transaction</id>
    <content type="html"><![CDATA[<h3>外存数据库的特点</h3>

<p>每次写入需要读取一个完整单元，不同的块做不同的修改，再写回硬盘</p>

<h3>oceanbase的特点</h3>

<p>本质上差不多，但是快大小不一样，但是增量数据(修改点)集中存储。可以更好的利用内存，利用低峰期合并到内存。但是每次需要读取静态数据和修改。</p>

<p>相对来讲，优化了写入，牺牲了部分读取（完全命中bloomfilter的可以不读静态，相当于内存数据库，不存在动态数据的查询相当于传统数据库）。</p>

<!--more-->


<h3>业界的内存数据库</h3>

<ul>
<li>VoltDB</li>
<li>MemSQL</li>
</ul>


<p>内存数据库很贵</p>

<h3>存储事务引擎</h3>

<ul>
<li>hash索引：散列存储，单点查询更快</li>
<li>B+树索引：顺序索引，范围查询</li>
</ul>


<h3>更新流程</h3>

<ul>
<li>根据主键找到行所在位置</li>
<li>加锁</li>
</ul>


<h4>多版本并发控制</h4>

<p>针对高并发的请求，分配在一个队列里面，排队，不需要抢锁。线程可以省下来给其他</p>

<p>通过 /<em>hot_spot</em>/的hint实现，交给用户决定</p>

<h3>写日志的性能瓶颈</h3>

<p>每次写两条日志，保证两台备机写成功，1333条每秒</p>

<p>只能通过软件上的改变，group commit</p>

<p>每次commit合并多个写日志请求。</p>

<p>条件：</p>

<ul>
<li>空闲的时候直接commit。有日志来的时候判断没有日志在写，就提交。</li>
<li>聚集到一个阈值的时候写。有日志在写，就放到buffer里面。直到达到阈值。</li>
<li>如果第一个写完日志，系统空闲，就写日志。</li>
</ul>


<h3>总结</h3>

<ul>
<li>内存数据库+分布式系统的设计</li>
<li>mvcc的实现</li>
<li>group commit</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一个实际中遇到的覆盖问题]]></title>
    <link href="http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus/"/>
    <updated>2014-06-10T19:32:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个继承结构如下：</p>

<pre><code>ObServerSchemaService : init_core_schema(const ObSchemaManagerV2 &amp;schema)
         |
ObRootSchemaSerivice : init_core_schema()
</code></pre>

<p>  基类的init_core_schema接收一个核心表的schema，而这个schema往往是从rootserver传过来的，所以下面的子类RootSchemaService不需要传参，直接自己生成就好了。</p>

<p>  问题是如果在ObRootSchemaService的对象上想要调用ObServerSchemaService的init_core_schema函数会报错。因为命名空间上Root的会覆盖Server的，哪怕只是同名的数据成员也会隐藏基类的成员函数。比如：</p>

<pre><code>struct TableSchema
{
  const static int version_ = 1;
  int mem_version()
  {
    return version_;
  }
};

struct ExTableSchema: TableSchema
{
  int mem_version;
};
int main(void)
{
  ExTableSchema schema;
  schema.mem_version();
}
</code></pre>

<p>  解决方法很简单，直接指明命名空间就行了</p>

<pre><code>schema.TableSchema::mem_version();
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oceanbase简介 - 笔记]]></title>
    <link href="http://cxh.me/2014/06/09/oceanbase-introduction-note/"/>
    <updated>2014-06-09T19:01:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/oceanbase-introduction-note</id>
    <content type="html"><![CDATA[<h1>数据库简介</h1>

<h3>数据库的特点</h3>

<ul>
<li>原子性 ： 一笔账，要么转了，要么没转</li>
<li>一致性 ： 出账入账必须一致</li>
<li>隔离性 ： 多人转账不得相互影响</li>
<li>持久性 ： 转账一旦发生，持久存在</li>
</ul>


<p>还有两个：</p>

<ul>
<li>高可用</li>
<li>高性能</li>
</ul>


<h3>数据库 vs 计算机</h3>

<p>服务器：处理器，内存，磁盘，网卡</p>

<ul>
<li>原子性：计算机只能保证寄存器的原子</li>
<li>一致性：单个服务器上数据一致性比较好做</li>
<li>隔离性：多个事务串行处理隔离性不好做</li>
<li>持久性：磁盘或者固态盘才有持久性</li>
<li>高可用：磁盘年均故障率1%-3%，单个磁盘可用率99%-99.9%</li>
<li>高性能：服务器性能</li>
</ul>


<!--more-->


<h1>数据库和互联网</h1>

<p>银行 + 商务</p>

<p>网购：一次商务+一次金融</p>

<p>双十一：一天350亿，55s超过1个亿，支付宝2亿笔交易，头一分钟一千万买家上线</p>

<p>黑色星期五：美国19.3亿美元</p>

<h3>互联网时代数据库的要求</h3>

<p>ACID无法取代</p>

<p>在线金融、网购需要数据库高可用99.999%</p>

<p>可扩展性，性价比</p>

<h1>oceanbase</h1>

<p>高档服务器，高档存储，高深的数据库软件</p>

<p>传统数据库的高可用：</p>

<p>主库+备库， 共享存储，数据同步备库</p>

<p>主备同步三种模式：</p>

<ul>
<li>最大同步，可用性太差</li>
<li>最高性能，一致性太差</li>
<li>最大可用，尽力同步，备库应答OK，超时则容错，有丢失风险</li>
</ul>


<p>银行可靠性依赖于物理可靠性</p>

<p>传统数据库性价比不高，硬件，软件很贵</p>

<p>oceanbase 用了普通服务器，水平扩展 = 云计算+关系数据库 ， 存储大部分是固态盘</p>

<p>性能+可用性+扩展性</p>

<h4>性能</h4>

<ul>
<li>机械盘读 ： 机械磁盘随机读 100-300次/秒（IOPS)</li>
<li><p>SSD随机读： 几万次每秒</p></li>
<li><p>机械盘写：100-300次/秒</p></li>
<li>数据库写入放大：每次修改100B导致4k块的修改，oracle 8k mysql 16k， 产生几十倍的放大效应</li>
<li>固态盘：写入放大，先擦后写，有时候一次擦十几兆，需要先读再迁再擦再写</li>
</ul>


<h4>全内存数据库</h4>

<ul>
<li>性能高，性价比低，容量小</li>
<li>适用需要极高性能且数据量小的业务</li>
</ul>


<h4>Oceanbase</h4>

<p>内外存混合数据库</p>

<p>内存：热数据，频繁修改</p>

<p>外存：冷数据</p>

<p>性能略逊，容量大，性价比高</p>

<p>消除传统数据库写入放大</p>

<p>高可用：如何以低可靠硬件实现</p>

<h4>oceanbase Milestone：</h4>

<p>淘宝收藏夹->双集群（可以升级改bug对业务透明）-> OLAP功能 &ndash;> SQL支持 &ndash;> 三集群（分布式投票）</p>

<h4>oceanbase应用</h4>

<ul>
<li>稳定可靠</li>
<li>可在线扩展，业务增长过快</li>
<li>高性能低成本</li>
<li>不锁表创建索引</li>
</ul>


<h4>oceanbase质量保证</h4>

<p> 严格的c/c++编码规范
&ndash; 资源申请者负责释放
&ndash; 单入口单出口
&ndash; 定长内存管理
&ndash; 禁用全局变量，goto
&ndash; 严格限制使用stl
&ndash; 统一编码风格</p>

<p>无处不在的crc</p>

<h4>oceanbase数据校验</h4>

<ul>
<li>磁盘读写，每个记录带64位CRC</li>
<li>网络传输：每个网络包带64位CRC</li>
<li>多副本多个crc</li>
<li>修改增量多副本：64位CRC校验</li>
<li>redolog：每条带64位crc</li>
<li>每个表每个列64位crc</li>
</ul>


<p>灰度升级</p>

<h3>小结：</h3>

<p>数据库是人类伟大智慧的结晶</p>

<p>机会：</p>

<ul>
<li>云计算技术</li>
<li>网购繁荣</li>
<li>中国经济腾飞</li>
<li>ssd普及</li>
<li>优秀技术人才</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见的防御性编程策略]]></title>
    <link href="http://cxh.me/2014/06/09/defensive-strategy/"/>
    <updated>2014-06-09T11:51:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/defensive-strategy</id>
    <content type="html"><![CDATA[<p>  针对出错之后不能恢复的情况，最好的办法是写另外一个对象，确认成功之后原子的交换对象。同时也能避免对一个对象的修改持锁时间过长。这种思路广泛用在很多地方。</p>

<ol>
<li> 保存备份文件，当前的文件有可能有人在读在写，所以每次线程都写一个单独的备份文件，最后原子的覆盖之前的文件。</li>
<li> 升级系统。自动升级的时候下载了新的可执行文件，然后删除原来的文件，替换成下载文件。当然估计不会有人直接覆盖之前的文件。</li>
<li> 一些NOSQL的冻结。OB里面比较典型的就是UpdateServer的内存冻结，当然是copy on write实现的，最后原子的切换B树的根指针。主要是为了minor fqreeze的时候依然能提供写入服务。</li>
<li> =运算符重载的时候，如果当前类持有的对象先释放了，但是又没能成功复制需要拷贝的对象，就会有悬空的风险。effective c++里面给了一种实现方式，就是先生成一份拷贝，再swap。</li>
</ol>


<p>一个简单的例子如下：</p>

<pre><code>int do_checkpoint()
{
  int ret = OB_SUCCESS;
  if (enable_backup_)
  {
    if (OB_SUCCESS != (ret = write_to_file(tmp_file_path_)))
    {
      TBSYS_LOG(WARN, "failed to write schema backup file:ret[%d]", ret);
    }
    else
    {
      //copy tmp to schema.ini
      unlink(schema_file_path_);
      if (0 == rename(tmp_file_path_, schema_file_path_))
      {
        TBSYS_LOG(INFO, "save schema to backup succ. refresh_times_:%ld", refresh_times_);
      }
      else
      {
        TBSYS_LOG(WARN, "rename new schema file failed:ret[%d]", ret);
        ret = OB_ERR_UNEXPECTED;
      }
    }
  }
  return ret;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
