<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-28T19:39:30+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[github/gitcafe pages域名设置]]></title>
    <link href="http://cxh.me/2014/06/28/gitcafe-github-domain-config/"/>
    <updated>2014-06-28T18:17:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/gitcafe-github-domain-config</id>
    <content type="html"><![CDATA[<h3>A纪录和CNAME</h3>

<p>  裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。引用自参考文献<a href="http://www.zhihu.com/question/20414602" title="为什么越来越多的网站域名不加www了？">1</a></p>

<h3>gitcafe pages 域名配置</h3>

<pre><code>  example.com.          1684    IN  A   117.79.146.98

  www.example.com.      3581    IN  CNAME   example.gitcafe.com.
  example.gitcafe.com. 560  IN  A   117.79.146.98
</code></pre>

<p>  gitcafe文档说：</p>

<p>  如果你想绑定 www 子域名, 你需要将此 www 子域名添加到自定义域名里, 然后在你的域名管理页面增加一条 A 记录, 将它指向 GitCafe 服务器的 IP 地址 117.79.146.98</p>

<!--more-->


<h3>github pages 域名配置</h3>

<pre><code>;example.com
example.com.   73  IN  A 192.30.252.153
example.com.   73  IN  A 192.30.252.154

www.example.com.   xxxx  IN  CNAME example.github.io.
example.github.io.  xxxx  IN  CNAME github.map.fastly.net.
github.map.fastly.net.  9 IN  A 103.245.222.133
</code></pre>

<p>  同时配置CNAME文件:</p>

<ul>
<li><p>If your CNAME file contains example.com, then www.example.com will redirect to example.com.</p></li>
<li><p>If your CNAME file contains www.example.com, then example.com will redirect to www.example.com.</p></li>
</ul>


<p>  也就是说如果同时配置了A纪录和CNAME，那么对www的访问会重定向到主域名，或者主域名的访问重定向到www。本质上是301 redirect。</p>

<h3>dig和nslookup</h3>

<pre><code>dig www.example.com +nostats +nocomments +nocmd
nslookup 详见参考文献[2][2]
</code></pre>

<h3>参考文献:</h3>

<blockquote><p>[1] 为什么越来越多的网站域名不加www了？, <a href="http://www.zhihu.com/question/20414602">http://www.zhihu.com/question/20414602</a></p>

<p>[2] 常用域名记录解释：A记录、MX记录、CNAME记录、TXT记录、AAAA记录、NS记录, <a href="http://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html">http://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html</a></p>

<p>[3] Tips for configuring a CNAME record with your DNS provider, <a href="https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider">https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于一个配置项的设计]]></title>
    <link href="http://cxh.me/2014/06/28/a-desgin-problem-of-config/"/>
    <updated>2014-06-28T16:27:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/a-desgin-problem-of-config</id>
    <content type="html"><![CDATA[<p>  有个需求需要配置每张表的备份SQL语句，我开始想实现如下的效果：</p>

<pre><code>struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};

struct TableBackupTransaction
{
  static const int OB_MAX_SQL_PER_TRANS = 5;
  TableBackupSQL sql_list_[OB_MAX_SQL_PER_TRANS];
};


TableBackupTransaction table_backup_list_[] =
{
  {
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
  },
  {
    TableBackupSQL(1, "name", "select * from cs")
  }
};
</code></pre>

<p>  然后用宏美化一下就成这样了：</p>

<!--more-->


<pre><code>#define TABLE_BACKUP_SINGLE(table_prefix, sql)\
  { TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, sql) }
#define TABLE_BACKUP(table_prefix, sql)\
   TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, sql)
#define TABLE_BACKUP_MULTIPLE

ObInnerTableBackupGuard::TableBackupSQL ObInnerTableBackupGuard::table_backup_list_[][MAX_SQL_PER_TRANS] =
{
  TABLE_BACKUP_SINGLE(OB_FIRST_ROOT_TABLE, "select * from %s"),

  TABLE_BACKUP_MULTIPLE
  {
    TABLE_BACKUP(OB_ALL_TABLE, "select * from %s"),
    TABLE_BACKUP(OB_ALL_COLUMN, "select * from %s"),
    TABLE_BACKUP(OB_ALL_JOIN_INFO, "select * from %s"),
    TABLE_BACKUP(OB_ALL_DDL_OPERATION, "select max(schema_version) from %s "),
  },

  TABLE_BACKUP_SINGLE(OB_ALL_SYS_STAT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SYS_PARAM, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_USER, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_TABLE_PRIVILEGE,  "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_CLUSTER, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_TRIGGER_EVENT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_CLIENT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SYS_CONFIG,"select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SYS_CONFIG_STAT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SERVER, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_CLUSTER_STAT, "select * from %s")
};
</code></pre>

<p>  无奈想法很美好，实际上行不通，至少不开C++11新特性的情况下，不允许这样初始化，退而求其次：</p>

<pre><code>struct TableBackupTransaction
{
  static const int OB_MAX_SQL_PER_TRANS = 5;
  int sql_count_;
  TableBackupSQL sql_list_[OB_MAX_SQL_PER_TRANS];
  TableBackupTransaction(const TableBackupSQL * sql_list, int count)
  {
    //assert, length sql_list
    for(int i = 0; i &lt; count; i++)
    {
      sql_list_[i] = sql_list[i];
    }//or memcpy
    sql_count_ = count;
  }
  TableBackupTransaction(const TableBackupSQL &amp; sql_list)
  {
    sql_list_[0] = sql_list;
    sql_count_ = 1;
  }
};

TableBackupTransaction table_backup_list_[] =
{
  TableBackupTransaction({
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
  }),
  TableBackupTransaction({
    TableBackupSQL(1, "name", "select * from cs")
  })
};
</code></pre>

<p>  多了一次复制，但是初始化列表{a,b,c&hellip;}在不开C++11的时候不能作为函数参数传递，只能这样</p>

<pre><code>TableBackupSQL table_backup_[] =
{
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
};
TableBackupTransaction table_backup_list_[] =
{
  TableBackupTransaction(table_backup_, sizeof(table_backup_)/sizeof(TableBackupSQL)),
  TableBackupTransaction(TableBackupSQL(1, "name", "select * from cs"))
};
</code></pre>

<p>  弱爆了，最后改成二位数组好了：</p>

<pre><code>struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
  bool is_valid() const
  {
    return sql_ != NULL &amp;&amp; table_name_ != NULL &amp;&amp; table_id_ != OB_INVALID_ID;
  }
};

TableBackupSQL table_backup_list_[][5] =
{
  {
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
  },
  {
    TableBackupSQL(1, "name", "select * from cs")
  }
};
</code></pre>

<p>  只不过二维数组每个维度只是数组，没有额外的信息，不能扩展，访问只能这样：</p>

<pre><code>int main(void)
{
  TableBackupSQL (*trans)[5] = table_backup_list_;
  for (int i = 0; i &lt; sizeof(table_backup_list_)/(sizeof(TableBackupSQL)*5); i++, trans++)
  {
    for (int j = 0; j &lt; 5; j++)
    {
      const TableBackupSQL&amp; desc = *trans[j];
      if (!desc.is_valid())
      {
        break;
      }
      printf("%d, %d: %d, %s, %s\n",i ,j , desc.table_id_, desc.table_name_, desc.sql_);
    }
  }
}
</code></pre>

<p>或者</p>

<pre><code>int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/(sizeof(TableBackupSQL)*5); i++)
  {
    const TableBackupSQL (&amp;trans)[5] = table_backup_list_[i];
    for (int j = 0; j &lt; 5; j++)
    {
      const TableBackupSQL desc = trans[j];
      if (!desc.is_valid())
      {
        break;
      }
      printf("%d, %d: %d, %s, %s\n",i ,j , desc.table_id_, desc.table_name_, desc.sql_);
    }
  }
}
</code></pre>

<p>  弱爆了&hellip;.所以我最后决定把Transaction和单条事务直接分开了&hellip;.</p>

<p>int main(void)
{</p>

<p>  int a = 1;
  int b = a;
}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同步github上的项目到gitcafe]]></title>
    <link href="http://cxh.me/2014/06/28/gitsync-github-gitcafe/"/>
    <updated>2014-06-28T12:41:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/gitsync-github-gitcafe</id>
    <content type="html"><![CDATA[<p>  github固然好，只是国内访问有点慢。为了提高博客访问速度我决定把github上托管的博客同步到gitcafe上。最好能在DNS那里做CDN，但是貌似没有免费的服务。那直接指向gitcafe好了，反正没有什么国外访问的需求。简单记一下过程。</p>

<p>  gitcafe自己有导入的功能，但是貌似不是很好用。而且不够智能。所以我们先建立一个跟用户名一样的目录。gitcafe只允许这种方式的Html页面生成。并且只渲染gitcafe-pages分支。</p>

<p>  我们修改source分支.git/config加入</p>

<pre><code>[remote "cafe"]
  url = git@gitcafe.com:xxx/xxx.git
  fetch = +refs/heads/*:refs/remotes/cafe/*
</code></pre>

<p>  由于</p>

<pre><code>[branch "source"]
  remote = origin
  merge = refs/heads/source
</code></pre>

<p>  所以当前source分支（这下面我没有master）默认提交到origin（github)，所以我们通过</p>

<pre><code>git push cafe
</code></pre>

<p>  提交source，会被扩展成：</p>

<pre><code>git push cafe source:source "当前分支
</code></pre>

<p>  然后提交<em>deploy，这是渲染之后的html页面，前面那个是octopress的源码。修改</em>deploy/.git/config</p>

<pre><code>[remote "cafe"]
  url = git@gitcafe.com:chenxiaohui/chenxiaohui.git
  fetch = +refs/heads/*:refs/remotes/cafe/*
</code></pre>

<p>  然后提交:</p>

<pre><code>git push cafe master:gitcafe-pages
</code></pre>

<!--more-->


<p>  本地分支名字和远程分支不同的时候不能省略，否则会被自动扩展成相同的名字。这就是问题了，我们多了一个master分支&hellip;.</p>

<p>  按照gitcafe的教程删除master未果，不过顺便把默认分支改成了gitcafe-pages。删除master分支的时候，里面有一段说明：</p>

<pre><code>为什么要删除 master 分支
当你在创建一个新的仓库的时候没有指定分支的话，Git 会默认创建 master 分支并指定它为默认分支。

一般情况下使用 master 分支作为整个项目的核心分支是很普遍的行为， 而 Pages 服务之所以使用 gitcafe-pages 分支的方式区别项目文件和 Pages 文件。 这样你就可以在一个仓库中保存他们而且彼此不会有任何影响。

但是像是个人主页类的 Pages 服务或其他一些应用场合，可能并不需要 master 的存在， 甚至必须要删除它，或者只是你有洁癖┑(￣Д ￣)┍ 那么你就需要如下的方法来删除 master 分支。
</code></pre>

<p>  (#‵′)靠，就是这样。</p>

<p>  最后修改一下Rakefile</p>

<pre><code>...
    system "git push origin #{deploy_branch}"
    system "git push cafe #{deploy_branch}:gitcafe-pages"
    puts "\n## Github Pages deploy complete"
  end
...

  puts "\n## Pushing source"
  system "git push origin "
  system "git push cafe"
  puts "\n## Github source pushed"
</code></pre>

<p>  当然问题是同一个本地分支track了两个远程分支，但是默认值只能配置一个：</p>

<pre><code>[branch "master"]
    remote = cafe
    merge = refs/heads/gitcafe-pages
</code></pre>

<p>  这说明master分支上更新gitcafe必须指明repository，好在我们直接用git push/pull不带任何参数的时候不多。同时如果git pull的话，默认的merge两个repository是不同的，好在我们也一般不用从两个repository上面pull。</p>

<p>  顺便去挂一下域名就好了。</p>

<p>  矮马，快多了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git远程分支和refs文件详解]]></title>
    <link href="http://cxh.me/2014/06/28/git-remote-branch/"/>
    <updated>2014-06-28T11:14:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/git-remote-branch</id>
    <content type="html"><![CDATA[<p>  最近同时同步博客到github和gitcafe上，遇到一些问题，我们分如下几个方面来分析一下：</p>

<h3>推送远程分支到同一个服务器</h3>

<p>  比如首先建立git服务器，顺便clone出两个副本</p>

<pre><code>mkdir server
cd server
git init --bare
cd ..
git clone server git1
git clone server git2
</code></pre>

<p>  目前git branch是空的。我们提交一点东西建立master分支。</p>

<pre><code>cd git1
touch a.txt
git add .
git commit -m "init"
git push origin master
</code></pre>

<p>  现在git branch -a 显示:</p>

<pre><code>* master
  remotes/origin/master
</code></pre>

<p>  当前系统处于master分支，远程origin的repository上也有一个master分支。两个是tracking的。我们切到git2下面</p>

<pre><code>cd ../git2
git pull origin
</code></pre>

<p>  这时候git2跟git1完全同步了。现在我们开始尝试建立另一个分支并推送到服务器。习惯的，我们还是切回git1</p>

<pre><code>cd ../git1
git checkout -b source
</code></pre>

<p>  这时候我们已经有了一个本地分支了，如果这个分支不需要共享，那么你可以一直在这个分支上commit但是不push到服务器，直到这个分支被合并回主分支或者丢弃。git branch 显示如下：</p>

<pre><code>  master
* source
</code></pre>

<!--more-->


<p>  我们最终决定把这个分支push到服务器上与其他人共享，如下：</p>

<pre><code>git push origin source:source
</code></pre>

<p>  这时候git branch -a 能看到当前repository里面所有的分支，包括两个本地的，两个远程的，本地和远程的都处于tracking状态。</p>

<pre><code>  master
* source
  remotes/origin/master
  remotes/origin/source
</code></pre>

<p>  切到另一个副本。</p>

<pre><code>cd ../git2
git pull origin
</code></pre>

<p>  显示如下：</p>

<pre><code> * [新分支]          source      -&gt; origin/source
</code></pre>

<p>  git branch -a显示本地已经有了一个远程分支的指针，但是没有tracking这个分支的本地分支：</p>

<pre><code>* master
  remotes/origin/master
  remotes/origin/source
</code></pre>

<p>  同样我们可以在.git/refs/remotes/origin下看到分支的名字，但是refs/heads下面并没有。我们来检出这个远程分支：</p>

<pre><code>git checkout -b source origin/source
</code></pre>

<p>  这时候git branch -a 显示就跟git1一致了。git2下也可以编辑source分支并同步。这些都是比较常见的操作，我们需要注意的是，多分支下默认的参数。比如，在两个分支都修改一点东西：</p>

<pre><code>cd ../git1
git checkout master
//modify 
git add .
git commit -m "master modify"
git checkout source
//modify
git add .
git commit -m "source modify"
</code></pre>

<p>  这时候git push origin 是针对当前分支的，所以两个分支同时push更新只能</p>

<pre><code>git push origin
git checkout master
git push origin
</code></pre>

<p>  pull更新的时候</p>

<pre><code>cd ../git2
git checkout master
git pull origin
</code></pre>

<p>  这会同时更新两个分支的指针，但是不会merge另一个分支，我们去另一个分支下</p>

<pre><code>git checkout source
git pull origin
</code></pre>

<p>  但是出错如下：</p>

<pre><code>You asked to pull from the remote 'origin', but did not specify
a branch. Because this is not the default configured remote
for your current branch, you must specify a branch on the command line.
</code></pre>

<p>  问题在于没有给当前分支配置merge的路径，git不知道去merge哪个分支。（<del>虽然我觉得既然是tracking的不应该不知道啊</del>）。</p>

<p>  如果你有 1.6.2 以上版本的 Git，&mdash;track 选项可以同时配置merge的路径：</p>

<pre><code>git checkout --track origin/serverfix
</code></pre>

<p>  这里我们修改配置文件加入branch &ldquo;source&#8221;：</p>

<pre><code>[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    logallrefupdates = true
[remote "origin"]
    url = /media/cxh/backup/work/ceshi/git/server
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master"这里指server上的refs/heads/master
[branch "source"]
    remote = origin
    merge = refs/heads/source
</code></pre>

<p>  这意味着每次fetch origin的时候更新所有remotes/origin的头指针到refs/heads/下面，具体可以去.git下查阅这个目录，但是头指针都是只读的。merge是由所在branch定义的。</p>

<p>  我们加了branch &ldquo;source&#8221;的配置指定当前source的merge策略是使用<strong>服务器端的</strong>refs/heads/source来合并到当前分支。这样就可以顺利的git pull origin了。</p>

<h3>推送远程分支到不同服务器</h3>

<p>  我们先建立新的repo：</p>

<pre><code>cd ..
mkdir server2
cd server2
git init --bare
</code></pre>

<p>  加入git1副本，并提交</p>

<pre><code>git remote add server xxx/server2
git push server
</code></pre>

<p>  上面过程的本质是提交当前分支头指针到server，相当于拷贝refs/head/xxx到refs/remotes/server/下并提交。git push server会被展开成</p>

<pre><code>git push server 当前分支名：当前分支名
</code></pre>

<p>  我们可以在git2副本同样加入该repository并更新引用</p>

<pre><code>git remote add server xxx/server2
git fetch server
</code></pre>

<p>  可以看到refs下目录结构如下：</p>

<pre><code>├── heads
│   ├── master
│   └── source
├── remotes
│   ├── origin
│   │   ├── master
│   │   └── source
│   └── server
│       └── source
└── tags
</code></pre>

<h3>总结一下</h3>

<ul>
<li><p>update</p>

<ul>
<li><p>fetch操作的本质是更新repo所指定远程分支的头指针(server->refs/remotes/xxx/)</p></li>
<li><p>merge操作的本质是合并当前分支和指定的头指针(refs/remotes/xxx->refs/heads)</p></li>
<li><p>pull操作的本质是fetch + merge</p></li>
</ul>
</li>
<li><p>commit</p>

<ul>
<li><p>commit的本质是修改了当前分支的头指针(refs/heads)</p></li>
<li><p>push操作本质是提交当前分支头指针到server，顺便也修改了本地存储的server头指针(refs/remotes/xxx)</p></li>
</ul>
</li>
<li><p>checkout</p>

<ul>
<li><p>复制本地分支的本质是拷贝了refs/heads/下的一个头指针</p></li>
<li><p>push本地分支到server的本质是把这个头指针上传服务器，顺便拷贝了本地存储的server头指针（refs/remotes/xxx)</p></li>
<li><p>tracking远程分支的本质是把refs/remotes/下的指针拷贝到了refs/heads下</p></li>
</ul>
</li>
</ul>


<blockquote><p>注：以上过程都没有涉及数据流。</p></blockquote>

<h3>参考文献:</h3>

<blockquote><p>[1] Git 分支 &ndash; 远程分支, <a href="http://git-scm.com/book/zh/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">http://git-scm.com/book/zh/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF</a></p>

<p>[2] The Configuration File – “Branch” Section, <a href="http://www.gitguys.com/topics/the-configuration-file-branch-section/">http://www.gitguys.com/topics/the-configuration-file-branch-section/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个关于宏的问题]]></title>
    <link href="http://cxh.me/2014/06/26/a-macro-problem/"/>
    <updated>2014-06-26T10:53:00+08:00</updated>
    <id>http://cxh.me/2014/06/26/a-macro-problem</id>
    <content type="html"><![CDATA[<p>  写了一段代码，我想实现宏里面拼接一个变量然后取得这个变量的值的效果，但是没有成功：</p>

<pre><code>#define OB_FIRST_ROOT_TABLE_TID 21
#define OB_INVALID_ID INT_MAX
const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";

struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};


#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from "#table_name)
#define TABLE_BACKUP(table_prefix)\
TABLE_BACKUP_(table_prefix, table_prefix##_TABLE_NAME)

TableBackupSQL table_backup_list_[] =
{
  TABLE_BACKUP(OB_FIRST_ROOT_TABLE)
};


int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/sizeof(TableBackupSQL); i++)
  {
    TableBackupSQL&amp; desc = table_backup_list_[i];
    printf("%d, %s, %s\n", desc.table_id_, desc.table_name_, desc.sql_);
  }
}
</code></pre>

<p>  期望的结果是</p>

<pre><code>21, __first_root_table, select * from __first_root_table
</code></pre>

<p>  实际的结果是</p>

<pre><code>21, __first_root_table, select * from OB_FIRST_ROOT_TABLE_TABLE_NAME
</code></pre>

<!--more-->


<p>  拼出来的OB_FIRST_ROOT_TABLE_TABLE_NAME没有被替换，当然有很多方法绕开。我试图两次展开宏但是没有成功，这个跟<a href="http://blog.csdn.net/maray/article/details/11096459" title="介绍一个C++奇巧淫技">这里</a>说的问题毕竟不是一个。不知道C++11里面有没有解决方法。</p>

<p>  另外，我才发现一个struct直接赋值是C++11才允许的。比如：</p>

<pre><code>TableBackupSQL table_backup_list_[] =
{
  {21, "__first_root_table", "select * from __first_root_table"}
};
</code></pre>

<p>  不加-std=c++0x或者 -std=gnu++0x的时候会报错。c语言支持。</p>

<p>  后来发现我遗忘了一个事实，宏替换是发生在预编译期的，这时候都没有做语法词法分析，程序不知道一个变量应该如何替换，所以变量实际上没有被替换成值，这跟函数定义是不一样的。比如：</p>

<pre><code>#define wrap(value) value
int a  = 1;
int b = wrap(a);
</code></pre>

<p>  我们用gcc打印展开之后的结果如下：</p>

<pre><code>int a = 1;
int b = a;
</code></pre>

<p>  这里是不会展开成 int b = 1;的。而连接符#的作用也只是把宏替换后的字面值加上引号，比如：</p>

<pre><code>#define wrap(value) #value
int a  = 1;
const char * b = wrap(a);
</code></pre>

<p>  展开结果是：</p>

<pre><code>int a = 1;
const char * b = "a";
</code></pre>

<p>  而连接符##的作用就更简单了，就是提供一个标示宏传入参数的作用，比如</p>

<pre><code>#define wrap(value) a##value
int ab = 2;
int b = wrap(b);
</code></pre>

<p>  如果不写##就变成了avalue，无法区分输入参数，如果写a(value)就会替换成a(b),如果写a value就会替换成a b，所以想替换成ab只能用##。</p>

<p>  至于上面那个问题，如果我们table的名字都是宏定义的字符串，那就好办多了：</p>

<pre><code>const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";
#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from " table_name)
</code></pre>

<p>  感谢郁白师兄的指导。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress代码着色]]></title>
    <link href="http://cxh.me/2014/06/22/octopress-code-highlight/"/>
    <updated>2014-06-22T11:15:00+08:00</updated>
    <id>http://cxh.me/2014/06/22/octopress-code-highlight</id>
    <content type="html"><![CDATA[<p>  markdown有自己支持的代码模块，但是想支持着色，就需要单独对代码进行parse和加上css。octopress支持自己的代码语法，但是比较麻烦，并且是本地渲染，对不同语言需要指定。</p>

<p>  所以还是js渲染比较方便一点，我们可以用<a href="https://code.google.com/p/google-code-prettify/" title="google code prettify">google code prettify</a>进行着色，在markdown里面只要对代码加入缩进（tab或者四个空格）。服务端引入如下js:</p>

<pre><code>&lt;link href="http://cxh.me/javascripts/google-code-prettify/prettify.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;
&lt;script type="text/javascript" src="http://cxh.me/javascripts/google-code-prettify/prettify.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" &gt;
&lt;!--
    $(function() {
      $('pre').addClass('prettyprint').attr('style', 'overflow:auto');
      window.prettyPrint &amp;&amp; prettyPrint();
      $('table').addClass('table')
});
--&gt;
&lt;/script&gt;
</code></pre>

<p>  google code prettify的样式可以<a href="http://jmblog.github.io/color-themes-for-google-code-prettify/" title="google code prettify theme">这里</a>选择，关于行号的一些问题参见<a href="http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/" title="Jekyll中使用google-code-prettify高亮代码">这里</a>。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] google code prettify, <a href="https://code.google.com/p/google-code-prettify/">https://code.google.com/p/google-code-prettify/</a></p>

<p>[2] google code prettify theme, <a href="http://jmblog.github.io/color-themes-for-google-code-prettify/">http://jmblog.github.io/color-themes-for-google-code-prettify/</a></p>

<p>[3] Jekyll中使用google-code-prettify高亮代码, <a href="http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/">http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直接从markdown生成各种电子书]]></title>
    <link href="http://cxh.me/2014/06/21/generate-several-types-using-pandoc/"/>
    <updated>2014-06-21T21:23:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/generate-several-types-using-pandoc</id>
    <content type="html"><![CDATA[<p>  有时候我们需要把编辑的markdown转成各种格式，这不失为一种写书的方式。借助pandoc这把瑞士军刀，我们可以实现一个脚本编译各种格式的功能，代码如下：</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:build.py
import glob,os,sys,shutil

cmd_template={'html':"pandoc %s -o output/html/%s.html --template=default.html",
              'pdf':'pandoc -N --toc --template=default.latex --latex-engine=xelatex %s -o output/pdf/%s.pdf',
              'beamer': 'pandoc -N -t beamer --toc --template=default.beamer --latex-engine=xelatex %s -o output/beamer/%s.pdf',
              'epub': 'pandoc %s -o output/epub/%s.epub'
             }

if __name__ == '__main__':
    if len(sys.argv) &gt; 2:
        print 'Usage: build.py [pdf|html|epub|beamer]'
    else:
        out_type = 'html' if len(sys.argv) == 1 else sys.argv[1]
        assert(out_type in cmd_template)

    os.system('cat *.md &gt; swift_book.mkd')
    cmd = [os.system(cmd_template[out_type] %(path, os.path.splitext(path)[0])) for path in glob.glob("*.md")]
    cmd += [os.system(cmd_template[out_type] %('swift_book.mkd', 'swift_book'))]
    print cmd

    if out_type == 'html':
        try:
            shutil.rmtree('output/html/pic')
        except Exception , e:
            pass
        shutil.copytree("pic",'output/html/pic')
</code></pre>

<!--more-->


<p>  为此你需要<a href="http://johnmacfarlane.net/pandoc/installing.html" title="pandoc">安装一下pandoc</a>，需要pdf支持的话还需要<a href="https://www.tug.org/texlive/" title="texlive">装一下texlive</a>，用法如下：</p>

<pre><code>build.py [pdf|html|epub|beamer]

需要如下的目录结构：

    output  - beamer
            - pdf
            - epub
            - html
                - pic
</code></pre>

<p>   另外，脚本会拼一份合集在目录下，所以需要markdown文件有序，比如9.md会拼在10.md后面，所以需要9.md改名为09.md。</p>

<p>  一个使用的例子可以看<a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese" title="The-Swift-Programming-Language-in-Chinese">这里</a>。那些template都是模板文件，可以参考上面例子里的。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] The-Swift-Programming-Language-in-Chinese, <a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese">https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese</a></p>

<p>[2] pandoc, <a href="http://johnmacfarlane.net/pandoc/">http://johnmacfarlane.net/pandoc/</a></p>

<p>[3] pandoc, <a href="http://johnmacfarlane.net/pandoc/installing.html">http://johnmacfarlane.net/pandoc/installing.html</a></p>

<p>[4] texlive, <a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review插件]]></title>
    <link href="http://cxh.me/2014/06/21/ppost-review-plugin/"/>
    <updated>2014-06-21T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/ppost-review-plugin</id>
    <content type="html"><![CDATA[<h3>post-review.vim</h3>

<p>A plugin to generate post-review script</p>

<h3>Usage</h3>

<h4>install:</h4>

<pre><code>git clone https://github.com/chenxiaohui/post-review.vim 
</code></pre>

<p>put post-review.vim to your $VIM/plugin</p>

<p>add this to your vimrc</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>process:</h4>

<p>svndiff use vimdiff: see <a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">link</a></p>

<p>gitdiff use vimdiff: see <a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">link</a></p>

<p><img src="http://cxh.me/images/2013/git-vimdiff.png"></p>

<!--more-->


<p>first use svn diff/git diff and open vimdiff to see the difference</p>

<p>secondly when you consider the changed file needs to be posted , use <leader>pr to add it to post-review.sh</p>

<p>if you has no post-review.sh on your base_dir( specified by the g:base_dir_mark), you need to input the review id or just enter for a new review.</p>

<p>after you added all files you need to review, chmod +x post-review.sh and execute it.</p>

<p>(if you set g:chmod_after_create to 1 you will not need to chmod +x)</p>

<hr />

<p>  请无视楼主以上装逼的英文:</p>

<h3>post-review.vim</h3>

<p>  就是一个用来从vimdiff记录需要Post-review的文件的插件</p>

<p>  不知道Post-review的同学请google之, 用百度搜索的同学自觉面壁去</p>

<h3>用法</h3>

<h4>安装</h4>

<p>  统共分三步:</p>

<p>1.下载解压(或者git clone) url:<a href="https://github.com/chenxiaohui/post-review.vim">https://github.com/chenxiaohui/post-review.vim</a>
2.放到$VIM/plugin目录下(原谅我不写doc的习惯)
3.在vimrc中添加</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>使用</h4>

<p>  比如说Jack正欢快的写着代码呢，然后Jack要提交, 猛然发现好多修改啊</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<blockquote><p>难道不应该写一部分就post-review的嘛</p></blockquote>

<p>  好了不要care这种细节, 然后Jack需要一个一个查看修改的文件, 确定是放到哪个Post-review中提交</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<pre><code>What a fucking job!!!
</code></pre>

<p>  这时候你需要的就是这一款全自动, 人性化, 帮你生成post-review命令的插件, 只要998, 打进电话你就能拥有它&hellip;</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<blockquote><p>跑题了&hellip;</p></blockquote>

<p>  好了, 我们先svn diff或者git diff一下, 为了保证你看到的是如下界面请参考<a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">这里</a>或者<a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">这里</a>.</p>

<p><img src="http://www.ccvita.com/usr/uploads/2011/svn_diff.png" title="svndiff" alt="" /></p>

<p>  好了, 在你需要提交文件的那个窗口用快捷键<leader>pr, 标记完了所有的文件之后进入你的根目录(根目录是什么, 这个待会再说, 不要care这种细节), 下面是不是有一个post-review.sh了? 没有? 卧槽&hellip;男子汉大丈夫, 我写的插件, 有问题&hellip;.我也不承认&hellip;</p>

<p>  最后, 两个配置项:</p>

<pre><code>let g:base_dir_mark = 'cscope.out'
</code></pre>

<p>  制定了一个根目录标志, 也就是说你需要在你的项目根目录找一个(或者建一个)独一无二的文件(比如.git, cscope.out, tags)之类, 让插件去寻找这个文件, 找到之后就标识这个目录为根目录. 跟ctrlp学的.</p>

<pre><code>let g:chmod_after_create = 0
</code></pre>

<p>  无聊的选项, 建立完post-review之后是不是chmod +x, 无视它.</p>

<p>  发起新的post-review的时候建议把post-review.sh清空或者删除, 重复添加同一个文件的时候会判断.</p>

<p>  好了, 也就想到这么多了, 有其他的再补充, 钦此.</p>

<p>注：其实最后我发现还是这样更容易：</p>

<pre><code>alias st='svn st'
alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias po="echo 'post-review -d' &gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; stm &gt;&gt; post-review.sh ; chmod +x post-review.sh ;sed -i 's/^[MA]\s\+//g' post-review.sh;sed -i 's/$/ \\\\/g' post-review.sh;vi post-review.sh"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试一下机器和镜头]]></title>
    <link href="http://cxh.me/2014/06/21/photography-test/"/>
    <updated>2014-06-21T13:24:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/photography-test</id>
    <content type="html"><![CDATA[<p>  测试一下机器，镜头是18-55套头，表现中规中矩吧，K10D色彩不错。图压缩过。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/flower.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本文件和二进制文件读写]]></title>
    <link href="http://cxh.me/2014/06/21/bin-txt-file-read-write/"/>
    <updated>2014-06-21T12:28:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/bin-txt-file-read-write</id>
    <content type="html"><![CDATA[<p>  探究这个的起因是我在序列化一个数据结构，用二进制写到文件之后用vim打开发现后面居然多了一个值。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/binfile.png" title="用vim显示二进制文件" alt="用vim显示二进制文件"><p class="align-center">用vim显示二进制文件</p></p>

<p>  所以总结一下文件的两种不同写入方式。(当然上面是vim里面xxd显示的问题)</p>

<p>  我们用如下代码测试:</p>

<pre><code>int main(int argc, const char *argv[])
{
  FILE * fp  = fopen("output.txt", "w");
  fputc(10, fp);
  fputc(13, fp);
  fputc('\n', fp);
  fclose(fp);

  fp  = fopen("output.bin", "wb");
  int32_t length[] ={0x0a, 0x12345678};
  fwrite(&amp;length, sizeof(int32_t), 2, fp);
  fclose(fp);
  return 0;
}
</code></pre>

<!--more-->


<p><strong>windows下</strong></p>

<p>文本文件写入：</p>

<pre><code>0000000: 0d0a 0d0d 0a                             .....
</code></pre>

<p>二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>linux下：</strong></p>

<p>  文本方式写入</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入：</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>mac下</strong></p>

<p>  文本方式写入：</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p>  解释几个问题：</p>

<h3>回车符的转义</h3>

<p>  windows下写文本文件的时候换行符会被替换成回车换行(0d0a), 直接写0a(10)也是一样的. Linux和mac下不会,二进制文件不care这些.</p>

<h3>文件结尾判断</h3>

<p>  详见这里：<a href="http://blog.csdn.net/bingqing07/article/details/5785080">http://blog.csdn.net/bingqing07/article/details/5785080</a></p>

<h3>UTF-8 BOＭ</h3>

<p>  转载：</p>

<blockquote><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。
所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。
BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。
「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sublime根据markdown引用生成参考文献的插件]]></title>
    <link href="http://cxh.me/2014/06/20/susublime-plugin-to-generate-refrence/"/>
    <updated>2014-06-20T21:21:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/susublime-plugin-to-generate-refrence</id>
    <content type="html"><![CDATA[<p>  写这个的目的主要是每次写博客需要生成以下版权声明，免得引用了别人的文章被人说盗版。markdown里面支持通过列表组织引用的url，如下所示：</p>

<pre><code>  [1]: http://www.baidu.com   "百度"
  [2]: http:://www.google.com "谷歌"
  [3]: http://www.facebook.com "404 Not Found"
</code></pre>

<p>  我们可以通过这个形式来生成如下的代码</p>

<pre><code>###参考文献:

&gt;\[1] 百度, &lt;http://www.baidu.com&gt;

&gt;\[2] 谷歌, &lt;http:://www.google.com&gt;

&gt;\[3] 404 Not Found, &lt;http://www.facebook.com&gt;
</code></pre>

<p>  效果如下：</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 百度, <a href="http://www.baidu.com">http://www.baidu.com</a></p>

<p>[2] 谷歌, <a href="http:://www.google.com">http:://www.google.com</a></p>

<p>[3] 404 Not Found, <a href="http://www.facebook.com">http://www.facebook.com</a></p></blockquote>

<!--more-->


<p>  代码如下:</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:generate_ref.py

import sublime, sublime_plugin

class GeneraterefCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        sels = self.view.sel()
        lines=[]
        for sel in sels:
            lines += (self.view.substr(sel)).strip("\n").split("\n")
        outlines=[]
        for line in lines:
            idx1 = line.find(":")
            index = line[:idx1]
            idx2 = line.find('"', idx1)
            url = line[idx1+1:idx2].strip(' ')
            title = line[idx2:].strip('"')
            outlines.append('\n&gt;\%s %s, &lt;%s&gt;'%(index,title,url))
        self.view.insert(edit, sel.end(),"\n###参考文献:\n".decode("utf-8") + "\n".join(outlines))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress支持markdown表格]]></title>
    <link href="http://cxh.me/2014/06/20/octopress-pandoc-table/"/>
    <updated>2014-06-20T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/octopress-pandoc-table</id>
    <content type="html"><![CDATA[<p>   pandoc支持扩展的markdown，也就是支持类似于如下的表格：</p>

<pre><code>-----------------------------------------------------------------------------------------------------------------
测量指标                    低程度中心性             低亲近中心性                      低居间中心性
--------------------   -------------------   -----------------------------  -------------------------------------
高程度中心性                                        “自我”所嵌入的聚类                “自我”的联系人是冗余的，
                                                   远离网络中其他节点                整个世界绕他而行


高亲近中心性               是联系重要他人或                                       在事件中，自我位于一个相互
                         活跃人物的关键人物                                     联系密切、活跃的聚类中，与
                                                                             很多节点都很接近；其他节点也是如此
------------------------------------------------------------------------------------------------------------------
: 表3-1 不同中心性测量指标之间的关系[^16]
</code></pre>

<p>  效果可以渲染成这样：</p>

<table>
<caption>表3-1 不同中心性测量指标之间的关系[^16]</caption>
<col width="20%" />
<col width="19%" />
<col width="27%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">测量指标</th>
<th align="center">低程度中心性</th>
<th align="center">低亲近中心性</th>
<th align="center">低居间中心性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">高程度中心性</td>
<td align="center"></td>
<td align="center">“自我”所嵌入的聚类 远离网络中其他节点</td>
<td align="center">“自我”的联系人是冗余的， 整个世界绕他而行</td>
</tr>
<tr class="even">
<td align="left">高亲近中心性</td>
<td align="center">是联系重要他人或 活跃人物的关键人物</td>
<td align="center"></td>
<td align="center">在事件中，自我位于一个相互 联系密切、活跃的聚类中，与 很多节点都很接近；其他节点也是如此</td>
</tr>
</tbody>
</table>




<!--more-->


<p>  插件如下。</p>

<pre><code>require 'pathname'

module Jekyll
  class PandocTag &lt; Liquid::Tag
    def initialize(tag_name, markup, tokens)
      @file = nil
      if markup.strip =~ /(\S+)/i
        @file = $1
      end
      super
    end

    def render(context)
      code_dir = (context.registers[:site].config['pandoc_dir'].sub(/^\//,'') || 'pandoc')
      code_path = (Pathname.new(context.registers[:site].source) + code_dir).expand_path
      file = code_path + @file
      outfile = code_path + "output.html"
      if File.symlink?(code_path)
        return "Code directory '#{code_path}' cannot be a symlink"
      end

      unless file.file?
        return "File #{file} could not be found"
      end

      Dir.chdir(code_path) do
        system "pandoc -o output.html -f markdown -t html #{file}"
        outfile.read
      end
    end
  end

end

Liquid::Template.register_tag('pandoc', Jekyll::PandocTag)
</code></pre>

<p>  使用的时候先生成一个md文件，放在source/pandoc（随便设定）目录下。插件只是生成了html文件然后read进来了而已，所以有点傻，比如下面我的代码放到缩进里面还是被执行了。</p>

<p>  最后用如下语法载入（去掉空格）：</p>

<pre><code>{ % pandoc test.md % }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress的缩进插件]]></title>
    <link href="http://cxh.me/2014/06/20/octopress-indent-plugin/"/>
    <updated>2014-06-20T20:45:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/octopress-indent-plugin</id>
    <content type="html"><![CDATA[<p>  我们写中文的时候通常有首行缩进的需求，markdown默认是不支持的，octopress和wordpress也没有缩进的css。这里我们通过加个插件的方式完成。</p>

<p>  首先，处理markdown的渲染。我们建立如下插件:</p>

<pre><code>    module Jekyll
    module IndentFilter
        def indent(content)
            content.gsub(/&lt;p&gt;\s\s/, '&lt;p class="indent"&gt;')
        end
    end
end

Liquid::Template.register_filter(Jekyll::IndentFilter)
</code></pre>

<p>  这个就是做了个替换。会把行首的两个字符替换成一个css标签。然后加个css在系统css里面就行了：</p>

<pre><code>.indent{text-indent:2em;}
</code></pre>

<!--more-->


<p>  需要注意的是，整个文章的缩进层次可以这样使用：</p>

<pre><code># first
## second
## third
** bold **
no indent
* item
  indent
  &gt; * indent item
</code></pre>

<p>  效果如下所示：</p>

<h1>first</h1>

<h2>second</h2>

<h2>third</h2>

<p><strong> bold </strong></p>

<p>no indent</p>

<ul>
<li><p>item</p>

<p>indent</p></li>
</ul>


<blockquote><ul>
<li>indent item</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase设计中的注意事项]]></title>
    <link href="http://cxh.me/2014/06/19/oceanbase-design-notes/"/>
    <updated>2014-06-19T21:37:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/oceanbase-design-notes</id>
    <content type="html"><![CDATA[<ol>
<li>没有情况什么是不可能发生的</li>
<li>RPC或者其他网络调用是不一定能够返回结果的。也就是有三种可能，正确，失败，超时。</li>
<li>开发文档是需要一边写一边改最后再补的。</li>
<li>自顶向下，逐步求精还是有效的办法。方便解决很多设计上想不到的地方，细节永远最后再做，毕竟之前想的可能过一段时间决定不做了。</li>
<li>复杂任务要分成多个可测试的阶段完成，每个阶段保证能单独测试。为此多写一些代码也是值得的。</li>
<li>我们不是业务驱动，也不是技术驱动，而是测试驱动的&hellip;..</li>
<li>做好单测</li>
<li>做好单测&hellip;</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成像入门]]></title>
    <link href="http://cxh.me/2014/06/19/phphotography-theorem/"/>
    <updated>2014-06-19T19:00:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/phphotography-theorem</id>
    <content type="html"><![CDATA[<p>其实我只是感性的解释一下一些基本的原理。</p>

<ol>
<li><p>成像同一个点发出的所有光线在焦平面汇聚的结果。从原理上讲，小孔成像是更优的成像方式，因为小孔过滤了光线，让每个像点发出的光只有一束能参与成像，但是这样容易导致亮度偏低，同时小孔也不能像理论上说的足够小。</p></li>
<li><p>如果胶片/CCD刚好位于焦平面上，那么成像最清晰，焦平面前后的一段距离里面，成像虽然不够清晰但是也能接受，出了这个区域就认为不再能够成像。这个区域就是弥散斑所在的区域。对应的物体距离范围叫景深。</p></li>
<li><p>镜片如果折光度高的话，那么成像位置靠前，像小，同时<del>光线</del>聚焦点密度增加导致景深增加（算相等的物距，如果两个点聚焦之后的焦深不大的话，那么把底片移动到其中一个点上，另一个点的弥散圈也不大）。这就是短焦距镜片，短焦镜片的视角大。也就是说够大范围内的光都会被折射到成像底板的区域里（焦深）。适合拍风景等大画幅照片，广角镜头就是这类。</p></li>
<li><p>相反，如果镜片折光度小，那么成像位置就靠后，像大，同时<del>光线</del>聚焦点密度减少导致景深减少。这就是长焦镜头，长焦镜头视角小，景深小，适合拍人像，可以造成虚化的效果，同时也适合打鸟，毕竟放大倍数高，不易被发现。</p></li>
<li><p>同时，光圈也影响景深。在焦距一定的情况下，小光圈造成的焦深大，而现在的情况下排除了焦距和物距的影像，那么焦深大，景深就大<del>遮挡了周围的光线，由于中间部分折光系数高</del>，所以增加了景深。由于入射光强度降低，要想保证成片的明度，就需要加大ISO，增加快门时间。反过来，大光圈会减少景深，由于入射光强度高，可以减少ISO，减少快门时间。所以说大光圈长焦是人像利器。</p></li>
<li><p>物距影响景深，越近的物体，在光轴上成像点密度越低，景深越小（算相等的物距，如果两个点聚焦之后的焦深大，那么把底片移动到其中一个点上，另一个点的弥散圈也大）</p></li>
<li><p>普通卡片机由于照顾日常使用场景，焦距光圈基本是固定的，并且固定在中短焦距的范围内。所以卡片机画幅不大，景深也不大，适合一般场景的拍照，但难免平淡无特色。</p></li>
</ol>


<p><img class="img-polaroid center" src="http://cxh.me/images/2014/photography.gif" title="成像光路图" alt="成像光路图"><p class="align-center">成像光路图</p></p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/aperture.jpg" title="光圈对景深的影响" alt="光圈对景深的影响"><p class="align-center">光圈对景深的影响</p></p>

<h3>参考文献:</h3>

<blockquote><p>[1] 一篇讲解成像原理的文章, <a href="http://blog.sina.com.cn/s/blog_64cff0510100hid1.html">http://blog.sina.com.cn/s/blog_64cff0510100hid1.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 安装配置总结]]></title>
    <link href="http://cxh.me/2014/06/19/nnginx-install-config/"/>
    <updated>2014-06-19T11:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/nnginx-install-config</id>
    <content type="html"><![CDATA[<p>具体的可以看参考文献里面的三篇博客，中间遇到一个问题，nignx提示无法找到php文件。主要有两个原因：</p>

<ol>
<li><p>确定nginx工作线程的启动用户有权限访问www-root，需要修改nginx.conf的这里：</p>

<pre><code> user  www-data;
</code></pre></li>
<li><p>确定www-root配置正确，需要修改这里：</p>

<pre><code> fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
</code></pre></li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] nginx配置入门, <a href="http://www.nginx.cn/591.html">http://www.nginx.cn/591.html</a></p>

<p>[2] Nginx安装, <a href="http://www.nginx.cn/install">http://www.nginx.cn/install</a></p>

<p>[3] nginx php-fpm安装配置, <a href="http://www.nginx.cn/231.html">http://www.nginx.cn/231.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[总结STL的通用算法基本形式]]></title>
    <link href="http://cxh.me/2014/06/19/stl-algorithm-signature/"/>
    <updated>2014-06-19T09:58:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/stl-algorithm-signature</id>
    <content type="html"><![CDATA[<p>stl的通用算法基本有如下四种形式：</p>

<ol>
<li>alg(beg, end, params)：使用源输入作为输出</li>
<li>alg(beg, end, dest, params) ：使用dest作为输出，需要保证有足够的空间，所以往往使用inserter</li>
<li>alg(beg, end, beg2, other params)：beg2作为输出，假定beg2开始的范围至少跟beg和end指定的范围一样大。</li>
<li>alg(beg, end, beg2, end2, params)：beg2 end2作为输出</li>
</ol>


<p>举例：</p>

<p>第一种比如：</p>

<pre><code>find(beg, end, search_value);
sort(beg, end);
accumulate(beg, end, original_value);
fill(beg, end, value); //特殊的：fill_n(begin, count, n)
replace(beg, end, value, replace_value);
unique(beg, end);
count(beg, end, value);
stable_sort(beg, end);
reverse(beg, end);
</code></pre>

<p>第二种比如：</p>

<pre><code>copy(beg, end, back_inserter(vector));
</code></pre>

<p>第三种比如：</p>

<pre><code>replace_copy(beg, end, beg2, value, replace_value);
unique_copy(beg, end, beg2);
reverse_copy(beg, end, beg2);
</code></pre>

<p>第四种比如：</p>

<pre><code>find_first_of(beg, end, beg2, end2);
</code></pre>

<p>另外，有的算法支持谓词，比如</p>

<pre><code>sort(beg, end, comp)
find_if(beg, end, comp)
count_if(beg, end, comp)
</code></pre>

<p>有的算法有copy和非copy版，比如</p>

<pre><code>replace(beg, end, value, replace_value);
unique(beg, end);

replace_copy(beg, end, beg2, value, replace_value);
unique_copy(beg, end, beg2);    
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c/c++ 文件/流读取函数总结]]></title>
    <link href="http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function/"/>
    <updated>2014-06-16T20:00:00+08:00</updated>
    <id>http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function</id>
    <content type="html"><![CDATA[<h3>针对文本文件的，  c++主要有如下几种吧</h3>

<ol>
<li><p>getline： 实现上，输入istream流，需要支持特定traits的迭代器。从流里面每次一行读入string，遇到delim结束。</p>

<pre><code>   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str, _CharT __delim);

   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     inline basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str);
</code></pre></li>
</ol>


<!--more-->


<ol>
<li><p>stream.get/put：分为如下几种类型。</p>

<ol>
<li>不接收参数的直接返回结果</li>
<li>接收一个char类型的参数</li>
<li>接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</li>
<li>put直接输入一个字符</li>
<li><p>get 系的函数都不会ignore delim分隔符的，读到行尾需要手动ignore回车</p>

<pre><code>   int_type 
   get(void);

   __istream_type&amp; 
   get(char_type&amp; __c);

   __istream_type&amp; 
   get(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   get(char_type* __s, streamsize __n)

   __istream_type&amp;
   get(__streambuf_type&amp; __sb, char_type __delim);

   inline __istream_type&amp;
   get(__streambuf_type&amp; __sb)

   // Unformatted output:
   __ostream_type&amp; 
   put(char_type __c);
</code></pre></li>
</ol>
</li>
<li><p>stream.getline()：接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</p>

<pre><code>   __istream_type&amp; 
   getline(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   getline(char_type* __s, streamsize __n)
</code></pre></li>
<li><p>stream.read/stream.write()： 二进制操作，读写一段数据。</p>

<pre><code>   __istream_type&amp; 
   read(char_type* __s, streamsize __n);

   streamsize 
   readsome(char_type* __s, streamsize __n);

   __ostream_type&amp; 
   write(const char_type* __s, streamsize __n);
</code></pre></li>
<li><p>输入输出运算</p></li>
</ol>


<h3>c大概有如下几个：</h3>

<ol>
<li> fgetc/fputc</li>
<li> fgets/fputs</li>
<li> fscanf/fprintf</li>
<li><p> fread/fwrite</p>

<pre><code>__STDIO_INLINE _IO_ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
</code></pre></li>
</ol>


<p>  另外，stdio.h里也有getline的实现，传入一个FILE指针。需要注意的是传入的char **指针是会被申请内存并赋值的。所以需要自己释放。</p>

<p>  这里就不详述了，详见：
  <a href="http://zhaoyuqiang.blog.51cto.com/6328846/1296902">http://zhaoyuqiang.blog.51cto.com/6328846/1296902</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记工作中遇到的一个性能问题]]></title>
    <link href="http://cxh.me/2014/06/15/a-performance-problem/"/>
    <updated>2014-06-15T12:16:00+08:00</updated>
    <id>http://cxh.me/2014/06/15/a-performance-problem</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个问题，更新schema的过程发现耗时太长，30多s。导致其他一系列流程阻住。记录一下这个问题的分析解决。</p>

<p>  开始觉得估计是数据量大sql执行时间过长，整个过程分为3条sql，也就是schema被分表成为的三个表的查询：</p>

<pre><code>    select * from __all_table;  //主键table_id
    select * from __all_column; //主键table_id,column_id
    select * from __all_join;//主键left_table_id, let_column_id
</code></pre>

<p>   之后在内存里面做Join。由于是有序的，所以join过程直接采用了二分查找。之于没有用散列做Join或者直接
   SQL语句里做Join的原因，只能说是历史遗留问题了。</p>

<p>   在三个执行过程中加计时，跑一下，发现结果如下：</p>

<pre><code>    all_table表查询，建立TableSchema对象并插入Array，20+s
    all_column查询， 二分找到对应的TableSchema，填入Column，10+s
    all_join查询，二分找到对应的TableSchema，填入JoinInfo，0.xs，忘了
</code></pre>

<!--more-->


<p>   问题很明显出在第一个上面。Perf分析一下程序执行过程，发现大量时间耗费在TableSchema的Operator=上面。我们的编程习惯是自己实现Operator=，拷贝构造直接调用自己的=重载。所以要么是拷贝构造占用了大量时间，要么是赋值占用了大量时间。</p>

<p>   同时，在命令行执行一下SQL查询，发现第一条SQL查询花费1s左右，而第二条花费10s，第三条表里没有数据。从数据量来看，大概也是这个数量级，因为column表里面存放所有table的列信息，意味着平均每个表有10个列。这条SQL在客户端默认的超时时间下会直接Timeout。</p>

<p>   考虑这个过程里面，运算符=的调用确实也只可能发现在第一个过程，因为后面都是直接填充里面的属性值。赋值的操作只有可能发生在动态表扩展。为了屏蔽一下扩展再分析，我们直接在Array建立前Reserve一下内存空间。也就是考虑到有18000+张表，直接Reserve(20000)。</p>

<p>   重跑发现总时间直接降到了13s，去掉第二条sql的执行时间（第三个过程忽略），第一个过程在1s之内返回。所以问题就处在动态表扩展上。</p>

<p>   我们知道算法上的动态表设计，每次扩展的时候是两倍申请空间，拷贝之前的对象到新地址空间，再析构之前的对象。这也就意味着20000张表扩展了log2(20000)，15次的样子(可能有个默认reserve数值)。当然问题也可以通过reserve这么解决了，但是流式接口，不能在数据迭代完毕之前知道有多少行数据。所以需要额外发起一次count()查询。但是再查询一次的开销还不如浪费点空间。</p>

<p>   继续分析，减少reserve值到10000发现根本没有效果，还是一样的耗费20s，这就意味着之前的所有expand的影响都没有最后一次大。但是这个明显不合理，因为1+2+4+&hellip;2<sup>n</sup> = 2<sup>n+1</sup> &ndash; 1，意味着之前所有的拷贝合并起来一定跟最后一次拷贝数量相当。时间上也应该占用一半。考虑到大内存分配跟小内存分配在我们的内存池里面开销差异不大，所以还是扩展上的问题。</p>

<p>   在Array的extend上加日志，继续跑。发现问题就在这里了，有大量的expand，这就意味着扩展的开销远大于我们考虑的情形。看ObArray的源码，发现实现上并不是我们理解的二倍扩展，ObArray的实现是每次扩展一个固定的大小(block_size/元素大小） ，而这个blocksize默认值是64k，算算我们的TableSchema有3k大小，也就是每20个就扩展了一次。在18000+的表构建过程中，扩展了差不多1000次。</p>

<p>   针对这个问题，我们把ObArray的扩展大小从64k提升到2M，扩展次数降低到100次以内。时间上，虽然不如直接reserve（20000），但是已经回到2s，整个过程在14s内。基本达到要求。</p>

<p>   后续就需要分析SQL查询是否能加快了。当然我把_all_column加入TableSchema的那个过程也reserve了一下，避免TableSchema里面column数组在每次push一个列的时候引起扩展，因为平均看，一个table所包含的平均列数也就10左右。性能待测试。</p>

<p>   从这个问题吸取的教训就是，动态表能之前确定长度的最好直接Reserve，否则相当于有多次申请内存-析构-拷贝构造（或赋值，我们之前是赋值）-释放内存的开销。同时，Perf是个好工具，虽然我还不是很熟悉。</p>

<p>   关于vector的扩容见<a href="http://blog.csdn.net/sodickbird/article/details/4594907" title="深入浅出vector resize/reserve">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式选主-笔记]]></title>
    <link href="http://cxh.me/2014/06/10/distributed-selection/"/>
    <updated>2014-06-10T21:08:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/distributed-selection</id>
    <content type="html"><![CDATA[<h3>数据库主备复制</h3>

<p>同步模式</p>

<ul>
<li>备机是否写盘之后应答</li>
<li>性能收主备机之间通讯距离，网络抖动影响</li>
</ul>


<p>异步模式</p>

<ul>
<li>主机不等待备机的应答</li>
<li>性能最优，可能造成数据丢失不一致</li>
</ul>


<p>半异步</p>

<ul>
<li>超过多数成功则返回</li>
<li>奇数台机器才可以</li>
<li>3/5 > 2/3 > 2/2</li>
</ul>


<!--more-->


<h3>网络</h3>

<ul>
<li>任意两个进程可以传递消息</li>
<li>进程有本地物理时钟 时钟使用NTP同步</li>
<li>超时有上限</li>
<li>进程不会发错误的消息</li>
</ul>


<h3>分布式选举基本问题</h3>

<p>不可靠的机群实现可靠的协议，通过投票的方案</p>

<ul>
<li>任意时刻只能有一个主</li>
<li>要容忍网络分区</li>
<li>Leader Lease，选主要等待上个主的lease过期</li>
<li>Lease周期的长短</li>
</ul>


<p>Paxos要求</p>

<ol>
<li>成员不能说假话（非拜占庭）</li>
<li>单个成员说话不能相互矛盾（投票给A了不能投票给B）</li>
<li>修改需要多数成员同意</li>
</ol>


<p>实现</p>

<ol>
<li>记住自己在lease周期的投票</li>
<li>重启等待一个lease周期不投票</li>
<li>多个人都想成为主的时候</li>
</ol>

]]></content>
  </entry>
  
</feed>
