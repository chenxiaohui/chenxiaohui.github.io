<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-02-04T14:53:29+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[区分下shell和makefile中的特殊字符]]></title>
    <link href="http://cxh.me/2015/02/04/distinguish-special-symbol-in-shell-and-makefile/"/>
    <updated>2015-02-04T14:51:00+08:00</updated>
    <id>http://cxh.me/2015/02/04/distinguish-special-symbol-in-shell-and-makefile</id>
    <content type="html"><![CDATA[<p>  主要是在Makefile中看到了这种字符($@)，不理解含义，查阅了一下，跟shell中意义不一样：</p>

<pre><code>$@     -is the name of the target currently being processed.
$&lt;     -is the name of the first dependency.
</code></pre>

<p>  顺便提下shell下的</p>

<pre><code>$#    Stores the number of command-line arguments that were passed to the shell program.
$?    Stores the exit value of the last command that was executed.
$0    Stores the first word of the entered command (the name of the shell program).
$*    Stores all the arguments that were entered on thecommand line ($1 $2 ...).
"$@"  Stores all the arguments that were entered on the command line, individually quoted ("$1" "$2" ...).
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gcc命令行参数总结]]></title>
    <link href="http://cxh.me/2015/02/04/gc-gcc-parameters-summary/"/>
    <updated>2015-02-04T11:36:00+08:00</updated>
    <id>http://cxh.me/2015/02/04/gc-gcc-parameters-summary</id>
    <content type="html"><![CDATA[<p>   总结一下混乱的GCC命令行参数，帮助写Makefile:</p>

<ol>
<li><p>编译阶段</p>

<ol>
<li>预编译E->生成汇编S(ccl)&ndash;>生成机器码c(as)&ndash;>链接生成目标程序(ld)</li>
</ol>
</li>
<li><p>输出类型：</p>

<ol>
<li>-E 只执行到预编译</li>
<li>-S 只执行到汇编阶段。生成汇编代码。</li>
<li>-c 只执行到编译。输出目标文件。</li>
<li>空。生成链接目标代码。</li>
<li>-o 指定输出文件名。</li>
</ol>
</li>
<li><p>输入类型：</p>

<ol>
<li><p>每个阶段可以接受之前阶段的中间结果（可跨越）。比如：</p>

<pre><code> gcc -E hello.c -o hello.i
 gcc -S hello.i -o hello.s
 顺序可以换：
 gcc -c -o hello.o hello.c
</code></pre></li>
</ol>
</li>
<li><p>优化调试相关</p>

<ol>
<li>-g 生成调试信息</li>
<li>-s 去掉调试和符号信息</li>
<li>-O[1|2|3..] 编译优化</li>
<li>-W[all] 开启额外警告</li>
</ol>
</li>
<li><p>链接相关：</p>

<ol>
<li>-l, 指定所使用到的函数库</li>
<li>-L, 指定函数库所在的文件夹。</li>
<li>-I, 指定头文件所在的文件夹</li>
</ol>
</li>
</ol>


<h3>Bibliography:</h3>

<blockquote><p>[1] Linux平台gcc和动态共享库的基础知识, <a href="http://robbinfan.com/blog/9/gcc-linker-basic-usage">http://robbinfan.com/blog/9/gcc-linker-basic-usage</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Configuration Inheritance]]></title>
    <link href="http://cxh.me/2015/02/02/python-config-inheritance/"/>
    <updated>2015-02-02T11:54:00+08:00</updated>
    <id>http://cxh.me/2015/02/02/python-config-inheritance</id>
    <content type="html"><![CDATA[<p>  While refactoring a project, I met with a situation that one configuration extends another configuration, like this:</p>

<pre><code>ConfigA = {"a":xx, "b":xx}
ConfigB extends ConfigA + {"a":yy, c:"yy"}
</code></pre>

<p>  Code before refactor treats configA and configB separately. So after a few code iterations you will find configA has something same with configB. So I change it to this：</p>

<pre><code>configA = {"a":xx, "b":xx}
configB = dict(configA.items() + {"a":yy, c:"yy"}}
</code></pre>

<p>  While this treats configA and configB evenly, meanwhile, it costs extra replication. A better way is like this:</p>

<pre><code>configA = {"a":xx, "b":xx}
configB = dict(configA, **{"a":yy, c:"yy"}})
</code></pre>

<p>  The order of configA and configB&rsquo;s own elements is immutable, which means if configA and configB has a same element, use configB as result.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About random shuffle in cplusplus]]></title>
    <link href="http://cxh.me/2015/02/01/random-shuffle/"/>
    <updated>2015-02-01T19:14:00+08:00</updated>
    <id>http://cxh.me/2015/02/01/random-shuffle</id>
    <content type="html"><![CDATA[<p>   Actually I just want to memorize the usage of STL function random_shuffle. It takes two or threes arguments, the begin iterator, end iterator and a generator. What makes it interesting is the optional third parameter. Random_shuffle will pass the index to generator and takes the output as index to place current element while shuffling. Here is an example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
const int POKER_NUM = 52; //52 pocker cards
void print_poker(int PokerNum)
{
    cout &lt;&lt; PokerNum &lt;&lt; " ";
}

class MyRand
{
public:
    int operator()(int index)
    {
        return rand() % PockerNum;
    }
};

int main()
{
    srand( (unsigned)time(NULL) ); //rand seed
    vector&lt;int&gt; poker; 
    //initialize
    for (int num = 0; num &lt; POKER_NUM; ++num)
    {
        poker.push_back(num+1);
    }

    //with default random_shuffle
    random_shuffle(poker.begin(), poker.end());
    for_each(poker.begin(), poker.end(), print_poker);
    cout &lt;&lt; endl;

    //use custom random_shuffle
    random_shuffle(poker.begin(), poker.end(), MyRand());
    copy(poker.begin(), poker.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
}
</code></pre>

<p>  I copy it from <a href="http://blog.csdn.net/aheroofeast/article/details/3907192" title="random_shuffle算法小例子">here</a>. While I found a mistake in it. The result isn&rsquo;t really random. The pseudo-code of above is :</p>

<pre><code>for i in 0..n
    exchange a[i] and a[random(0..n)]
</code></pre>

<p>  We assume a method can generate a sequence(a[0]..[n]) randomly, which means each sequence appears with the probability 1/n!. Take certain sequence a[0&#8217;]&hellip;a[n&#8217;] as an example: a[0&#8217;] appears with the probability 1/n, so a[1&#8217;] should appear with the probability 1/(n-1), etc. The algorithm above find a[1&#8217;] in the whole candidates, makes the probability 1/n actually. The right algorithm is like this:</p>

<pre><code>for i in 0..n
    exchange a[i] and a[random(i..n)]
</code></pre>

<p>  With a little change in the code:</p>

<pre><code>class MyRand
{
public:
    int operator()(int index)
    {
        return rand() % (PockerNum - index) + index;
    }
};
</code></pre>

<h3>Bibliography:</h3>

<blockquote><p>[1] random_shuffle算法小例子, <a href="http://blog.csdn.net/aheroofeast/article/details/3907192">http://blog.csdn.net/aheroofeast/article/details/3907192</a></p>

<p>[2]   &ldquo;Algorithms, <a href="http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY">http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的治牙经历]]></title>
    <link href="http://cxh.me/2015/02/01/experience-of-curing-my-teeth/"/>
    <updated>2015-02-01T17:02:00+08:00</updated>
    <id>http://cxh.me/2015/02/01/experience-of-curing-my-teeth</id>
    <content type="html"><![CDATA[<p>  2015.1.12，生日，去做了第一轮刮治的第一次治疗。痛不欲生啊。</p>

<p>  11月的时候查出来牙周有问题，其实很早就觉得不好了，洗牙之前没去看。洗牙的时候拍了牙片，槽骨吸收的很厉害了。中间又拖了两个月，一个是忙，一个是没挂上号，终于上周去北大口腔挂了号。医生说很严重，侵袭性牙周炎，牙周袋太深，可能还是得手术。</p>

<p>  今天第一次刮治。感慨牙这个东西，不意识到的时候不会觉得他的重要，上周探完牙周袋深度就疼了一个周，这次更是痛不欲生的感觉，打了麻药还是这样。而且奇怪的是手刮并不怎么疼，疼的还是超声洗牙石的部分。唯一的安慰是大夫态度都不错。牙科的大夫mm居多，虽然带着口罩都看不清楚长相&hellip;</p>

<p>  以前还是不重视啊。家庭上也整体不重视。中国还是有很多落后的地方，理念上这么多年都没有更新过来。联想到公务员热和中国父母普遍的求稳定，觉得理念真是落后太多了。至于过年各种嘘寒问暖的亲戚&hellip;哎，你们没有隐私这个观念么&hellip;还好我家人父母不太执着这些事情，就是说说算了&hellip;或者我压根没当真过..</p>

<p>  总的来说。长大了，要慢慢消除家庭的影响。有独立的思考了，就要慢慢消除教育的影响。离开了熟悉的环境，就要慢慢消除文化的影响。保持一个open的心态，不断质疑以前形成的思维定势，才能走出去，走的远。</p>

<hr />

<p>  此贴持续更新，毕竟还有四到五轮的刮治，每轮又要分多次，之后如果做牙周手术，又有得受了。立贴为记录吧。</p>

<p>  今天才注意到北大口腔的字还是老江题的。联想到今天疼爽了的经历，真是excited啊</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/excited.png"></p>

<hr />

<p>  第二次刮治，右上右下。倒是比第一次疼痛减轻多了，不过上次刮治之后都是臼齿吃饭，这下吃饭比较成问题。另外麻药的持久感好强，感觉右半边脸好像不存在一样。</p>

<p>  下周继续。第一轮三次完成。大夫比较辛苦。</p>

<hr />

<p>  第一轮第三次结束，医生说好多了，至少肿退下去了。买了牙缝刷每天饭后刷，还是能刷出一些刷牙刷不到的东西。下次检查年后了，抽空去拔个智齿。</p>

<hr />

<p>  今天想去拔智齿。经历了这样的流程：感冒不能拔->周日好的差不多了->早晨没起来->7点半出发去北大口腔第三门诊->被告知外科不现场挂号只能预约->北医三院，屏幕直接显示没号->海淀医院，被告知没号->中关村医院，成功挂号，拔牙医生只有周一到周六在->回，over。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在命令行使用Shadowsocks翻墙]]></title>
    <link href="http://cxh.me/2015/01/30/use-shadowsocks-in-terminal/"/>
    <updated>2015-01-30T18:13:00+08:00</updated>
    <id>http://cxh.me/2015/01/30/use-shadowsocks-in-terminal</id>
    <content type="html"><![CDATA[<p>  拜GFW所赐，连tm boot2docker都连接不上了。好在有shadowsocks的服务，可以转成http proxy给命令行使用。</p>

<p>  首先安装<a href="http://www.privoxy.org/" title="Privoxy">privoxy</a>。Linux下直接<code>apt-get install proxy</code>，然后编辑配置文件（etc/privoxy/config)：</p>

<pre><code>forward-socks5   /               127.0.0.1:1080 .
listen-address  localhost:8118
#local network do not use proxy
forward         192.168.*.*/     .
forward            10.*.*.*/     .
forward           127.*.*.*/     .
</code></pre>

<p>  基本上上这两项就可以了。之后在shell配置下代理，详见<a href="http://cxh.me/2015/01/11/linux-proxy-setup/" title="通过搭建代理来共享网络">参考文献2</a>：</p>

<pre><code>export http_proxy='http://127.0.0.1:8118'
export https_proxy='http://127.0.0.1:8118'
</code></pre>

<p>  最后chkconfig设置下开机启动。Mac下略微麻烦一些。主要是配置开机启动。详见<a href="http://blog.devtang.com/blog/2012/12/08/use-privoxy/" title="使用Privoxy做智能代理切换">参考文献3</a>。至于Mac下的Shadowsocks，还是ShadowsocksX比较方便，跟Linux下一样，都是会在1080启动监听。</p>

<h3>Bibliography:</h3>

<blockquote><p>[1] Privoxy, <a href="http://www.privoxy.org/">http://www.privoxy.org/</a></p>

<p>[2] 通过搭建代理来共享网络, <a href="http://cxh.me/2015/01/11/linux-proxy-setup/">http://cxh.me/2015/01/11/linux-proxy-setup/</a></p>

<p>[3] 使用Privoxy做智能代理切换, <a href="http://blog.devtang.com/blog/2012/12/08/use-privoxy/">http://blog.devtang.com/blog/2012/12/08/use-privoxy/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 中相等的比较]]></title>
    <link href="http://cxh.me/2015/01/29/java-compare-strategy/"/>
    <updated>2015-01-29T20:42:00+08:00</updated>
    <id>http://cxh.me/2015/01/29/java-compare-strategy</id>
    <content type="html"><![CDATA[<p>  遇到如下一个问题，java中使用复杂类型做Hashkey的时候，构造另一个值相同的对象作为key无法获取map的value。原因其实是java的==判断的依据是两个引用是否指向了同一个对象。实际调用了hashCode函数。内置对象的逻辑相等比较需要使用equals，比如String。而对于非内置对象，equals也同样调用了hashCode来判断相等。</p>

<p>  所以对于需要逻辑相等判断的对象，需要override两个函数，比如如下一个getkey的类定义了如何从Map中根据path和type得到一个唯一的对象：</p>

<p>  class ZkEventKey {</p>

<pre><code>    EventType type = null;
    String path = null;

    ZkEventKey(EventType type, String path) {
        super();
        this.type = type;
        this.path = path;
    }

    EventType getType() {
        return type;
    }

    String getPath() {
        return path;
    }

    @Override
    public String toString() {
        return "ZkEventKey [type=" + type + ", path=" + path + "]";
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj){
            return true;
        }else if (obj == null){
            return false;
        }
        if (getClass() != obj.getClass()){
            return false;
        }
        ZkEventKey other = (ZkEventKey)obj;
        if(type == other.type &amp;&amp; path.equals(other.path)){
            return true;
        }
        return false;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + type.hashCode(); 
        result = prime * result + path.hashCode(); 
        return result;
    }
}
</code></pre>

<p>  hashCode取31是一个统计的结论，在接近2<sup>x</sup>的质数下，散列冲突最小。没有看到过证明。</p>

<!--more-->


<p>  测试如下，value用String代替了。</p>

<pre><code>public void Test(){
    Map&lt;ZkEventKey, String&gt; map = new ConcurrentHashMap&lt;TestMap.ZkEventKey, String&gt;();
    ZkEventKey key1 = new ZkEventKey(EventType.NodeChildrenChanged, "/ua_server");
    ZkEventKey key2 = new ZkEventKey(EventType.NodeChildrenChanged, "/ua_server");
    map.put(key1, "Test Value");
    System.out.println(key1.equals(key2));
    System.out.println(map.get(key2));
}

结果：
true
Test Value
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eclipse多命令行窗口]]></title>
    <link href="http://cxh.me/2015/01/29/eclipse-multi-console/"/>
    <updated>2015-01-29T20:41:00+08:00</updated>
    <id>http://cxh.me/2015/01/29/eclipse-multi-console</id>
    <content type="html"><![CDATA[<p>   有时候需要在eclipse中同时运行客户端程序和服务器程序，开始都是一个在eclipse里面运行，另一个在命令行单独启动，未免不方便。后来发现，其实可以直接在eclipse中运行两次。调试视图会有两个显示，同时新建一个console窗口，关联另一个实例的显示就可以同时监视两个程序的输出了。</p>

<p>   <img class="img-polaroid center" src="http://cxh.me/images/2015/eclipse_instance.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协变返回类型]]></title>
    <link href="http://cxh.me/2015/01/27/convariant-return-type/"/>
    <updated>2015-01-27T15:48:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/convariant-return-type</id>
    <content type="html"><![CDATA[<p>  协变返回类型（Convariant Return Type）是指override的函数，返回值有继承关系（子类函数返回类型是父类返回类型的子类）。例子如下：</p>

<!--more-->


<pre><code>class Base
{
  public:
    Base (){}
    virtual void print(){
      printf("Base");
    }
};

class Derived : public Base
{
  public:
    Derived(){}
    virtual ~Derived (){}
    void print(){
      printf("Derived");
    }
};

class TestBase
{
  public:
    TestBase (){}
    virtual Base* getObject(){
      return new Base();
    }
};

class TestDerived : public TestBase
{
  public:
    TestDerived (){}
    virtual ~TestDerived (){}
    Derived* getObject(){
      printf("invoke here\n");
      return new Derived;
    }
};

int main(int argc, const char *argv[])
{
  TestBase * base = new TestDerived();
  Base* b = base-&gt;getObject();
  b-&gt;print();
  return 0;
}

结果：
invoke here
Derived
</code></pre>

<p>  java同理，只不过验证起来比较容易。直接打印对象就行。</p>

<pre><code>public class BaseClass {
}
public class DerivedClass extends BaseClass{
}

public class TestBase {
    public BaseClass getObject(){
        return new BaseClass();
    }
}

public class TestDerived extends TestBase{
    public DerivedClass getObject(){
        return new DerivedClass();
    }
    public static void main(String[] args) {
        TestBase base = new TestDerived();
        System.out.println(base.getObject());
    }
}

返回值：
test.server.others.DerivedClass@5d1eb50b
</code></pre>

<p>  这里想验证的其实是返回引用是可以的。返回对象是不行的。java只有返回引用，所以都可以。可自行验证。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java和C++继承上的一点不同]]></title>
    <link href="http://cxh.me/2015/01/27/java-cpp-derive-difference/"/>
    <updated>2015-01-27T14:51:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/java-cpp-derive-difference</id>
    <content type="html"><![CDATA[<p>   之前没注意过这里：</p>

<p>   java继承的时候只会隐藏父类同名同类型的函数。C++直接隐藏了同名的所有函数，如下：</p>

<pre><code>public class BaseClass {
    public void Print(String str){
        System.out.println("String" + str);
    }
    public void Print(int num){
        System.out.println(num);
    }
}
public class TestDerived extends BaseClass {
    public void Print(String str) {
        System.out.println("String" + str);
    }
    public static void main(String[] args) {
        new TestDerived().Print(121);
    }
}
</code></pre>

<p>  输出结果是121</p>

<p>  而同样的实现C++中直接会找不到父类的函数。</p>

<!--more-->


<pre><code>#include &lt;stdio.h&gt;
class Base
{
  public:
    Base (){}
    void Print(const char* str);
    void Print(int num);
};
void Base::Print(const char* str)
{
  printf(str);
}
void Base::Print(int num)
{
  printf("%d", num);
}

class Derived : public Base
{
  public:
    Derived(){}
    void Print(const char* str);
};
void Derived::Print(const char* str)
{
  printf("%s", str);
}

int main(int argc, const char *argv[])
{
  Derived d;
  d.Print(11);
  return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用shadow socks翻墙]]></title>
    <link href="http://cxh.me/2015/01/26/shadow-socks-proxy/"/>
    <updated>2015-01-26T15:39:00+08:00</updated>
    <id>http://cxh.me/2015/01/26/shadow-socks-proxy</id>
    <content type="html"><![CDATA[<p>   拜GFW所赐，连tm boot2docker都连接不上了。而且最近红杏抽风，遂决定买<a href="https://portal.shadowsocks.com/aff.php?aff=483" title="shadow socks">shadowsocks</a>服务翻墙。服务直接在官网购买，90一年，比红杏略便宜一点，主要还是可控性比较大，因为是socks5的代理。</p>

<p>  <a href="https://portal.shadowsocks.com/aff.php?aff=483" title="shadow socks">这里</a>购买服务，一年99，这个优惠码可以再打一点折<code>imouto985</code>。之后进入后台可以看到分配给自己的密码，服务器主要是日本，美国和新加坡的，实测貌似日本的响应更快一点。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/shadow_mac.png"></p>

<p>  mac下下载了客户端直接打开配置好地址就能用，linux下需要自己配置代理。</p>

<p>  首先下载安装node.js</p>

<pre><code>wget http://nodejs.org/dist/v0.10.35/node-v0.10.35.tar.gz
tar zxvf node-v0.10.35.tar.gz 
cd node-v0.10.35
./configure &amp;&amp; make 
sudo make install
</code></pre>

<p>  然后安装npm和shadowsocks</p>

<pre><code>sudo apt-get install npm
sudo apt-get install shadowsocks
</code></pre>

<p>  apt-get安装的nodejs好像有问题，所以用源码安装。编辑配置文件，默认是<code>/usr/local/lib/node_modules/shadowsocks/config.json</code>，启动之后就可以连上服务器了。</p>

<p>  之后需要配置proxy。以chrome为例，如果之前配置过goagent的话，基本配置一样。不过proxy switch sharp终于升级到了proxy switch omega了。需要注意的是shadowsocks是socks代理，选择的时候不要选择http。gfwlist 可用如下：</p>

<pre><code>https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt
</code></pre>

<p>  之后就可以翻墙了。最后说一句：<strong>Fxxk GFW，祝病魔早日战胜方校长，所有参与GFW的人都将钉在历史的耻辱柱上</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java中重用对象的bug]]></title>
    <link href="http://cxh.me/2015/01/23/java-reuse-bug/"/>
    <updated>2015-01-23T11:15:00+08:00</updated>
    <id>http://cxh.me/2015/01/23/java-reuse-bug</id>
    <content type="html"><![CDATA[<p>  首先这不是java编译器的问题，就是写代码的时候大意了。</p>

<p>  有这样一个函数</p>

<pre><code>int parse(String msg, Message out)；
</code></pre>

<p>  解析一个String，返回一个结构体。这么做的目的主要是避开try catch的性能问题，通过返回码来处理异常。这里就很容易出现这样的用法了：</p>

<pre><code>Message msg = new Message();
for (xxxx){
    if (0 == parse(str, msg))

}
</code></pre>

<p>  当时觉得还挺好，复用了一个对象。实际明显有问题的，这个对象的生命周期不见得只在for循环内部，一旦引用被传递出去，就会有悬挂（java里是不是不这么叫）的问题。多个引用指向了一个对象，计算结果是不可预测的。</p>

<p>  主要问题是java里面默认都是传引用的，所以要时刻保持对gc机制的警惕。或者直接实现clone接口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash下模拟group by功能]]></title>
    <link href="http://cxh.me/2015/01/22/simulate-group-by-in-bash/"/>
    <updated>2015-01-22T15:56:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/simulate-group-by-in-bash</id>
    <content type="html"><![CDATA[<p>  遇到这样一个问题：有一堆数据，需要统计相同key下相同的column的重复出现次数，实际上就是数据库里面的group by功能，但是建表导入然后计算未免麻烦，何况数据是临时数据，导入计算完毕之后就不需要了。这里用shell下的一些命令来完成。</p>

<p>  数据格式</p>

<pre><code>user            tag_id  type        time
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    EXPOSURE    2015:13:37:16
</code></pre>

<p>  目的：</p>

<pre><code>统计同一个用户下，同一个tag的点击次数：
</code></pre>

<p>  实现如下：</p>

<ol>
<li><p> 排序</p>

<p>首先对数据进行排序。这是最基本的，见<a href="http://cxh.me/2015/01/22/sort-using-multiple-columns/" title="Sort多列排序">上篇文章</a>。</p>

<pre><code>sort -k 1 
</code></pre></li>
<li><p> 过滤不需要的行和列。</p>

<pre><code>awk '{print $1, $2, $3}' |grep "Click" 
</code></pre></li>
<li><p> 这时候出现了一些重复列了，这也就是我们要做group by的数据。</p>

<pre><code>uniq -c | awk {'print $2, $3, $1'} 
</code></pre></li>
</ol>


<p>  后面awk只是调了一下位置。合并起来就是：</p>

<pre><code>sort -k 1  test.txt|awk '{print $1, $2, $3}' |grep "Click"|uniq -c | awk {'print $2, $3, $1'} 
</code></pre>

<p>  输出结果：</p>

<pre><code>AAAAAAAAAAA tag1 2
AAAAAAAAAAA tag2 1
BBBBBBBBBBB tag2 2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sort多列排序]]></title>
    <link href="http://cxh.me/2015/01/22/sort-using-multiple-columns/"/>
    <updated>2015-01-22T13:38:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/sort-using-multiple-columns</id>
    <content type="html"><![CDATA[<p>  遇到这样一个需求，希望按照第二列排序，第二列相同的情况下按照第一列排序，数据如下：</p>

<pre><code>b   2   c
c   2   b
a   1   b
</code></pre>

<p>  习惯性的用:</p>

<pre><code>sort -k 2 -k 1 input.txt
</code></pre>

<p>  输出结果是：</p>

<pre><code>a   1   b
c   2   b
b   2   c
</code></pre>

<p>  可以看到实际上先按照第二列排序，第二列相同按照第三列排序了。问题在于sort -k默认是按照顺序排序到末尾的。如果要打破默认，需要指定从哪个列到哪个列。</p>

<pre><code>sort -k 2，2 -k 1 input.txt
</code></pre>

<p>  换个角度说，<code>sort -k 1 -k 2</code> 的效果跟 <code>sort -k 1</code> 是一样的。所以最好还是让数据按照排序列生成，这样看起来也最直观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Django下获取checkbox的返回值]]></title>
    <link href="http://cxh.me/2015/01/19/django-checkbox/"/>
    <updated>2015-01-19T16:46:00+08:00</updated>
    <id>http://cxh.me/2015/01/19/django-checkbox</id>
    <content type="html"><![CDATA[<p>  HTML中我们可以在form中这样写复选框：</p>

<pre><code>&lt;form action="demo_form.asp"&gt;
  &lt;input type="checkbox" name="vehicle" value="Bike"&gt; I have a bike&lt;br&gt;
  &lt;input type="checkbox" name="vehicle" value="Car" checked&gt; I have a car&lt;br&gt;
  &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;
</code></pre>

<p>  但是作为服务端处理起来未免不变，尤其是checkbox list是自动生成的时候。此时可以用group方式把form value组合起来。如下：</p>

<pre><code>{\% for item in items \%}
    &lt;td&gt;&lt;input type="checkbox" name="selected_push[]" value=""&gt;&lt;/td&gt;
{\% endfor \%}
</code></pre>

<p>  服务端从命令行可以看到收到的post里面是有&#8217;selected_push[]&lsquo;变量的。但是直接get的结果只有一个。查阅stackoverflow发现RequestContext有单独的getlist函数来处理。果然还是跟PHP不一样啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python编码]]></title>
    <link href="http://cxh.me/2015/01/19/python-encoding/"/>
    <updated>2015-01-19T14:34:00+08:00</updated>
    <id>http://cxh.me/2015/01/19/python-encoding</id>
    <content type="html"><![CDATA[<p>  众所周知Python的内码编码是Unicode，所有输入的编码都需要转换成unicode然后转出成为其他编码。Python2中存在unicode对象和str对象两种，在中文处理的时候很容易出问题，而Python3直接全部统一了编码到unicode。</p>

<p>  举一个例子说明编码的转换，首先我们的环境是utf-8</p>

<pre><code>LANG=zh_CN.UTF-8
LANGUAGE=zh_CN:zh
LC_CTYPE="zh_CN.UTF-8"
LC_NUMERIC="zh_CN.UTF-8"
LC_TIME="zh_CN.UTF-8"
LC_COLLATE="zh_CN.UTF-8"
LC_MONETARY="zh_CN.UTF-8"
LC_MESSAGES="zh_CN.UTF-8"
LC_PAPER="zh_CN.UTF-8"
LC_NAME="zh_CN.UTF-8"
LC_ADDRESS="zh_CN.UTF-8"
LC_TELEPHONE="zh_CN.UTF-8"
LC_MEASUREMENT="zh_CN.UTF-8"
LC_IDENTIFICATION="zh_CN.UTF-8"
LC_ALL=zh_CN.UTF-8
</code></pre>

<p>  然后测试一个从环境的输入和写回到环境。</p>

<pre><code>文件编码gbk:
print '中文'
print u'中文'
输出
    ����
    中文

文件编码utf-8
print '中文'
print u'中文'

输出
    中文
    中文
</code></pre>

<p>  说明print输出的时候按照default encoding进行了编码。所以只有gbk的编码乱码了。同样对输入的判断，环境如果是utf8，输出不变的话，不会有乱码。但是如果从文件里读取了字符串或者代码里有硬编码字符，就需要考虑编码了。另外，unicode和str相加会有编码问题。比如：</p>

<pre><code>文件编码gbk:    
value = raw_input()
print value + "中文"
输入
    中文
输出
    中文����

value = raw_input()
print value + u"中文"
输入
    en
输出
    en中文
输入
    中文
输出
    UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)
</code></pre>

<p>  str+str输出肯定是str，所以需要适配环境的编码，第一个乱码可以理解。而str+unicode的时候，str会被按default encoding解码。utf8无法按照python default encoding ascii解码。utf8文件编码下的情况类似。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[保存知乎日报到pocket]]></title>
    <link href="http://cxh.me/2015/01/18/send-zhihu-to-pocket/"/>
    <updated>2015-01-18T15:30:00+08:00</updated>
    <id>http://cxh.me/2015/01/18/send-zhihu-to-pocket</id>
    <content type="html"><![CDATA[<p>  知乎日报是中国人民喜闻乐见的资讯类应用，Pocket是深受世界人民喜爱的阅读工具。鉴于反碎片化阅读的个人习惯，决定把散落在各个地方的有价值咨询集中到一个应用里面，于是有了如下的工具。</p>

<p>  首先我们要parse知乎日报的URL。按照官方的说法每天三次投放，那抓一次就行了。直接用了<a href="http://coolshell.cn/articles/9104.htm" title="sed 简明教程">sed工具</a>。</p>

<pre><code>curl -s http://daily.zhihu.com | sed 's/&lt;a href="\(http:\/\/daily.zhihu.com\/story[^"]*\)"/\n\1\n/g' |grep 'http://daily.zhihu.com/story'
</code></pre>

<!--more-->


<p>  然后需要打通跟Pocket的渠道。首先去注册Pocket SDK <a href="http://getpocket.com/developer/">http://getpocket.com/developer/</a></p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/pocket.png"></p>

<p>  将会得到如下的几个授权码。我只注册了Web和Desktop</p>

<pre><code>NAME    PLATFORM    CONSUMER KEY
ZhihuDaily2Pocket   Web xxxx-xxxxxxxxxxxxxxxxxxxx
ZhihuDaily2Pocket   Desktop (other) xxxx-xxxxxxxxxxxxxxxxxxxx
</code></pre>

<p>  之后先请求pocket的consumer key：</p>

<pre><code>curl -s -X POST  -H "X-Accept: Application/json" -H "Content-Type: application/json"  -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxxx","redirect_uri":"http://google.com"}'  https://getpocket.com/v3/oauth/request | grep '}' | python -mjson.tool
</code></pre>

<p>  这里需要注意Accept头部使用的是X-Accept，这是我之前死活得不到相应的原因。</p>

<p>  返回结果类似于：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/x-www-form-urlencoded
Status: 200 OK

code=dcba4321-dcba-4321-dcba-4321dc
</code></pre>

<p>  如果是web应用，这里可以把用户导向一个授权页面了。</p>

<pre><code>https://getpocket.com/auth/authorize?request_token=dcba4321-dcba-4321-dcba-4321dc&amp;redirect_uri=http://google.com
</code></pre>

<p>  授权后，我们把code和consumerkey转换成access token：</p>

<pre><code>curl -s http://getpocket.com/v3/oauth/authorize -X POST -H "Content-Type: application/json" -H "X-Accept: application/json" -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxxx","code":"dcba4321-dcba-4321-dcba-4321dc"}'
</code></pre>

<p>  得到类似如下的结果：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/x-www-form-urlencoded
Status: 200 OK

access_token=5678defg-5678-defg-5678-defg56&amp;
username=pocketuser
</code></pre>

<p>  根据这个access_token可以添加新的url了。</p>

<pre><code>curl -s http://getpocket.com/v3/add -X POST -H "Content-Type: application/json" -H "X-Accept: application/json" -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxxx", "access_token":"yyyy-yyyy-yyyy-yyyy-yyyy","url":"http://daily.zhihu.com/story/4437286"}'
</code></pre>

<p>  之前授权流程完成之后，作为某个特定用户，之后的请求指令就不会变话了。所以程序可以简化到如下：</p>

<pre><code>curl -s http://daily.zhihu.com | sed 's/&lt;a href="\(http:\/\/daily.zhihu.com\/story[^"]*\)"/\n\1\n/g' |grep 'http://daily.zhihu.com/story' |
while read line
do
    curl -s http://getpocket.com/v3/add -X POST -H "Content-Type: application/json" -H "X-Accept: application/json" -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxx", "access_token":"yyyy-yyyy-yyyy-yyyy-yyyy","url":"'$line'"}'|python -mjson.tool| grep 'resolved_url'
done 
</code></pre>

<p>  添加个定时任务到cron中就行了。</p>

<p>  <strong>当然最后我发现IFTTT是个更简单的方案&hellip;..</strong></p>

<h3>参考文献:</h3>

<blockquote><p>[1] sed 简明教程, <a href="http://coolshell.cn/articles/9104.htm">http://coolshell.cn/articles/9104.htm</a></p>

<p>[2] Pocket API Documentation, <a href="http://getpocket.com/developer/docs">http://getpocket.com/developer/docs</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转载：生活不是眼前的苟且，生活有诗和远方——高晓松]]></title>
    <link href="http://cxh.me/2015/01/17/life-has-peom-and-distance/"/>
    <updated>2015-01-17T18:41:00+08:00</updated>
    <id>http://cxh.me/2015/01/17/life-has-peom-and-distance</id>
    <content type="html"><![CDATA[<p>  “我妈说生活不是眼前的苟且，生活有诗和远方。我 和我妹妹深受这教育。谁要觉得你眼前这点儿苟且就是你的人生，那你这一生就完了。生活就是适合远方，能走多远走多远；走不远，一分钱没有，那么就读诗，诗 就是你坐在这，它就是远方。”</p>

<p>  关于房子，我跟大多数人概念不一样。我从小住在清华校园里，家是那种二层的小楼，外表看起来很普通，面积也不是特大，但是特别安静。</p>

<p>  这地儿都没动过，也没装修之说，从我生下来就是这样红色的，很老很旧。但我在那儿真觉得挺好，有一个家，但我在那儿真觉得挺好，有一个家，不仅仅是睡觉的 地方，我自己也不知道这房子多少年了，我们也在感慨：后边的院子多好啊，出门就是操场、游泳馆，还有漂亮的女生，白发的先生；四周的邻居，随便踹开一家的 门，里面住的都是中国顶级的大知识分子，进去聊会儿天怎么都长知识，梁思成林徽因就住我前面的院子。小时候有什么问题家里老人就写一张字条，说这问题你问 谁谁谁。我找到人家家里，打开字条一看，哦，你是那谁家的孩子，那你讲吧，都是中国头把交椅啊。这才是住处真正的意义吧，它让你透气，而不是豪华的景观、 户型和装修什么的。</p>

<!--more-->


<p>  2007年， 我们搬了出来，因为家人都在国外，我又不在清华教书，学校就把房子收回去了，后来我去了洛杉矶。</p>

<p>  去了美国，我一样是无房户，坚定的无房主义者。刚去美国的时候，我做编剧和开发，只卖出了两首电影歌曲。美国流行音乐是草根文化，美国卖吉他的黑人当我师 傅都有富余，不是说他弹得比我好，是同样一个琴我们弹的都不是一个级别，出的声音都不一样。国外很多伟大的乐队，都是一个班的同学，在中国整个高校也选拔 不出一个牛的乐队。为啥？国内很多年轻人的热情都分散了，赚钱的热情大过音乐本身，比如买房。</p>

<p>  郑钧有一天跟我说，有些艺术家被抓进精神病院，成了精神病；有些精神病人从精神病院逃出来，成为艺术家，你就是那后者，你的生活就像行为艺术。不过，我肯 定不属于时尚人士，因为从来不关注别人的流行趋势，也算不上中产阶级，如果我的钱只够旅行或是买房子，那我就去旅行。</p>

<p>  平时除了听听歌，看看电影，我最大的爱好就是满世界跑着玩。大概去过三十多个国家了，到一个地方就买一辆车，然后玩一段时间就把车卖了，再去下一个地方。</p>

<p>  经常在旅途中碰上一堆人，然后很快成为朋友，然后喝酒，然后下了火车各自离去。之前还在欧洲碰见一个东欧乐队，我帮人弹琴，后来还跟人卖艺去了，跟着人到 处跑到处弹唱，到荷兰，到西班牙，到丹麦……我妈也是，一个人背包走遍世界，我妈现在还在流浪，在考察美国天主教遗址。</p>

<p>  我妹也是，也没有买房，她挣的钱比我多得多。之前她骑摩托横穿非洲，摩托车在沙漠小村里坏了，她索性就在那里生活两个月等着零件寄到。然后在撒哈拉沙漠一 小村子里给我写一个明信片，叫做“彩虹之上”，她在明信片里告诉我说，哥，我骑了一个宝马摩托，好开心。我看到沙漠深处的血色残阳，与酋长族人喝酒，他们 的笑容晃眼睛……因为我跟我妹都不买房，你知道你只要不买房，你想开什么车开什么车。你想，你一个厕所的面积就恨不得能买一奔驰。然后她就开一宝马摩托， 坏了，说整个非洲都没这零件，她说你知道我现在在做什么吗？我在撒哈拉一个小村子里给人当导游。</p>

<p>  我妈从小就教育我们，不要被一些所谓的财产困住。所以我跟我妹走遍世界，然后我俩都不买房，就觉得很幸福。我妈说生活不是眼前的苟且，生活有诗和远方。我 和我妹妹深受这教育。谁要觉得你眼前这点儿苟且就是你的人生，那你这一生就完了。生活就是适合远方，能走多远走多远；走不远，一分钱没有，那么就读诗，诗 就是你坐在这，它就是远方。越是年长，越能体会我妈的话。</p>

<p>  美国人平均31岁才第一次购房，德国人42岁，比利时人37岁，欧洲拥有独立住房的人口占50%，剩下都是租房。为什么现在中国的年轻人一毕业就结婚？一 结婚就买房？怎样才能买到房？一套房子会限制你所有的行为和决定。因为你知道，要一提裸婚，没有人愿意嫁给你。即使老婆愿意，他们家人呢？别人会怎么看？ 孩子以后怎么办？以今天的房价，普通人买房只有两种情况，一种是双方父母出钱资助，这种人基本上前途和发展被父母控股。第二种人是牺牲了太多的发展机会， 典当梦想来成就一套房子。他们购买的，其实是自己内心深处的“安全感”。他们觉得，有一套房子，会让自己内心安全一点儿。但是安全感真的可以来自于一套房 子吗？归根结底，还是价值观的问题。世界再怎么变，还是要有坚持，即使它是落后。我不入流，这不要紧。我每一天开心，这才是重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理Django的自增字段]]></title>
    <link href="http://cxh.me/2015/01/15/django-assign-autoincrement-field/"/>
    <updated>2015-01-15T22:00:00+08:00</updated>
    <id>http://cxh.me/2015/01/15/django-assign-autoincrement-field</id>
    <content type="html"><![CDATA[<p>  有时候需要手动构造一个Django model对象并保存，遇到如下的情况：</p>

<pre><code>model定义如下：
class AuthHistory(models.Model):
user_name = models.CharField(max_length=100, default=None)
item_id = models.CharField(max_length=100)
datetime = models.DateTimeField()
url = models.CharField(max_length=1000)
title = models.CharField(max_length=1000)
operation = models.CharField(max_length=100, default=None)

构造对象如下：
history = AuthHistory("cxh", tid, datetime.datetime.now(), item['url'], item['title'], operation)
</code></pre>

<p>  报错:<code>django title invalid literal for int() with base 10:cxh</code>，明显是把第一个字段赋给自增长id了，因为Django会给没有主键的表直接加上id字段作为主键。</p>

<p>  手动指定域当然是可以的：</p>

<pre><code>history = AuthHistory( user_name="cxh", item_id=tid, datetime=datetime.datetime.now(), url=item['url'], title=item['title'], operation=operation)
</code></pre>

<p>  但是未免很麻烦。传值肯定不合理，毕竟id是数据库记录的。试了一下，给id域直接传NULL就行了。</p>

<pre><code>history = AuthHistory(None, "cxh", tid, datetime.datetime.now(), item['url'], item['title'], operation)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用maven执行java程序]]></title>
    <link href="http://cxh.me/2015/01/15/maven-execute-java-program/"/>
    <updated>2015-01-15T17:08:00+08:00</updated>
    <id>http://cxh.me/2015/01/15/maven-execute-java-program</id>
    <content type="html"><![CDATA[<p>  Eclipse中需要执行一个java程序的之后只需要在入口类Run就行，但是有时候需要同时开两个程序，尤其对C/S模式的应用来说。针对这种情况，可以分如下三种方式启动另一个程序：</p>

<ol>
<li><p> java -cp 指定的类。shell（或者ZSH才有）下貌似是会有提示如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/javacp.png"></p>

<p>以上方式至少需要保证用到的jar都在classpath中。</p></li>
<li><p> 从eclipse中copy执行命令。去调试页面，查看刚才执行的command的属性页面。会看到如下界面，copy命令到shell中执行即可。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/eclipse_command.png"></p></li>
<li><p> maven execute。 命令类似：</p>

<pre><code>mvn exec:java -Dexec.mainClass=boot.BootStrap
</code></pre>

<p>注意是第二个exec后是点，不是：，另外如果有多模块，在root project下需要加module:</p>

<pre><code>mvn exec:java -pl xxx -Dexec.mainClass=boot.BootStrap 
</code></pre></li>
</ol>

]]></content>
  </entry>
  
</feed>
