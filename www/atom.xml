<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-16T20:04:34+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[c/c++ 文件/流读取函数总结]]></title>
    <link href="http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function/"/>
    <updated>2014-06-16T20:00:00+08:00</updated>
    <id>http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function</id>
    <content type="html"><![CDATA[<h3>针对文本文件的，  c++主要有如下几种吧</h3>

<ol>
<li><p>getline： 实现上，输入istream流，需要支持特定traits的迭代器。从流里面每次一行读入string，遇到delim结束。</p>

<pre><code>   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str, _CharT __delim);

   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     inline basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str);
</code></pre></li>
</ol>


<!--more-->


<ol>
<li><p>stream.get/put：分为如下几种类型。</p>

<ol>
<li>不接收参数的直接返回结果</li>
<li>接收一个char类型的参数</li>
<li>接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</li>
<li><p>put直接输入一个字符</p>

<pre><code>   int_type 
   get(void);

   __istream_type&amp; 
   get(char_type&amp; __c);

   __istream_type&amp; 
   get(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   get(char_type* __s, streamsize __n)

   __istream_type&amp;
   get(__streambuf_type&amp; __sb, char_type __delim);

   inline __istream_type&amp;
   get(__streambuf_type&amp; __sb)

   // Unformatted output:
   __ostream_type&amp; 
   put(char_type __c);
</code></pre></li>
</ol>
</li>
<li><p>stream.getline()：接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</p>

<pre><code>   __istream_type&amp; 
   getline(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   getline(char_type* __s, streamsize __n)
</code></pre></li>
<li><p>stream.read/stream.write()： 二进制操作，读写一段数据。</p>

<pre><code>   __istream_type&amp; 
   read(char_type* __s, streamsize __n);

   streamsize 
   readsome(char_type* __s, streamsize __n);

   __ostream_type&amp; 
   write(const char_type* __s, streamsize __n);
</code></pre></li>
<li><p>输入输出运算</p></li>
</ol>


<h3>c大概有如下几个：</h3>

<ol>
<li> fgetc/fputc</li>
<li> fgets/fputs</li>
<li> fscanf/fprintf</li>
<li><p> fread/fwrite</p>

<pre><code>__STDIO_INLINE _IO_ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
</code></pre></li>
</ol>


<p>  另外，stdio.h里也有getline的实现，传入一个FILE指针。</p>

<p>  这里就不详述了，详见：
  <a href="http://zhaoyuqiang.blog.51cto.com/6328846/1296902">http://zhaoyuqiang.blog.51cto.com/6328846/1296902</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记工作中遇到的一个性能问题]]></title>
    <link href="http://cxh.me/2014/06/15/a-performance-problem/"/>
    <updated>2014-06-15T12:16:00+08:00</updated>
    <id>http://cxh.me/2014/06/15/a-performance-problem</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个问题，更新schema的过程发现耗时太长，30多s。导致其他一系列流程阻住。记录一下这个问题的分析解决。</p>

<p>  开始觉得估计是数据量大sql执行时间过长，整个过程分为3条sql，也就是schema被分表成为的三个表的查询：</p>

<ul>
<li> select * from __all_table;  //主键table_id</li>
<li> select * from __all_column; //主键table_id,column_id</li>
<li> select * from __all_join;//主键left_table_id, let_column_id</li>
</ul>


<p>   之后在内存里面做Join。由于是有序的，所以join过程直接采用了二分查找。之于没有用散列做Join或者直接
   SQL语句里做Join的原因，只能说是历史遗留问题了。</p>

<p>   在三个执行过程中加计时，跑一下，发现结果如下：</p>

<ul>
<li> all_table表查询，建立TableSchema对象并插入Array，20+s</li>
<li> all_column查询， 二分找到对应的TableSchema，填入Column，10+s</li>
<li> all_join查询，二分找到对应的TableSchema，填入JoinInfo，0.xs，忘了</li>
</ul>


<!--more-->


<p>   问题很明显出在第一个上面。Perf分析一下程序执行过程，发现大量时间耗费在TableSchema的Operator=上面。我们的编程习惯是自己实现Operator=，拷贝构造直接调用自己的=重载。所以要么是拷贝构造占用了大量时间，要么是赋值占用了大量时间。</p>

<p>   同时，在命令行执行一下SQL查询，发现第一条SQL查询花费1s左右，而第二条花费10s，第三条表里没有数据。从数据量来看，大概也是这个数量级，因为column表里面存放所有table的列信息，意味着平均每个表有10个列。这条SQL在客户端默认的超时时间下会直接Timeout。</p>

<p>   考虑这个过程里面，运算符=的调用确实也只可能发现在第一个过程，因为后面都是直接填充里面的属性值。赋值的操作只有可能发生在动态表扩展。为了屏蔽一下扩展再分析，我们直接在Array建立前Reserve一下内存空间。也就是考虑到有18000+张表，直接Reserve(20000)。</p>

<p>   重跑发现总时间直接降到了13s，去掉第二条sql的执行时间（第三个过程忽略），第一个过程在1s之内返回。所以问题就处在动态表扩展上。</p>

<p>   我们知道算法上的动态表设计，每次扩展的时候是两倍申请空间，拷贝之前的对象到新地址空间，再析构之前的对象。这也就意味着20000张表扩展了log2(20000)，15次的样子(可能有个默认reserve数值)。当然问题也可以通过reserve这么解决了，但是流式接口，不能在数据迭代完毕之前知道有多少行数据。所以需要额外发起一次count()查询。但是再查询一次的开销还不如浪费点空间。</p>

<p>   继续分析，减少reserve值到10000发现根本没有效果，还是一样的耗费20s，这就意味着之前的所有expand的影响都没有最后一次大。但是这个明显不合理，因为1+2+4+&hellip;2<sup>n</sup> = 2<sup>n+1</sup> &ndash; 1，意味着之前所有的拷贝合并起来一定跟最后一次拷贝数量相当。时间上也应该占用一半。考虑到大内存分配跟小内存分配在我们的内存池里面开销差异不大，所以还是扩展上的问题。</p>

<p>   在Array的extend上加日志，继续跑。发现问题就在这里了，有大量的expand，这就意味着扩展的开销远大于我们考虑的情形。看ObArray的源码，发现实现上并不是我们理解的二倍扩展，ObArray的实现是每次扩展一个固定的大小(block_size/元素大小） ，而这个blocksize默认值是64k，算算我们的TableSchema有3k大小，也就是每20个就扩展了一次。在18000+的表构建过程中，扩展了差不多1000次。</p>

<p>   针对这个问题，我们把ObArray的扩展大小从64k提升到2M，扩展次数降低到100次以内。时间上，虽然不如直接reserve（20000），但是已经回到2s，整个过程在14s内。基本达到要求。</p>

<p>   后续就需要分析SQL查询是否能加快了。当然我把_all_column加入TableSchema的那个过程也reserve了一下，避免TableSchema里面column数组在每次push一个列的时候引起扩展，因为平均看，一个table所包含的平均列数也就10左右。性能待测试。</p>

<p>   从这个问题吸取的教训就是，动态表能之前确定长度的最好直接Reserve，否则相当于有多次申请内存-析构-拷贝构造（或赋值，我们之前是赋值）-释放内存的开销。同时，Perf是个好工具，虽然我还不是很熟悉。</p>

<p>   关于vector的扩容见<a href="http://blog.csdn.net/sodickbird/article/details/4594907" title="深入浅出vector resize/reserve">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式选主-笔记]]></title>
    <link href="http://cxh.me/2014/06/10/distributed-selection/"/>
    <updated>2014-06-10T21:08:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/distributed-selection</id>
    <content type="html"><![CDATA[<h2>数据库主备复制</h2>

<p>同步模式</p>

<ul>
<li>备机是否写盘之后应答</li>
<li>性能收主备机之间通讯距离，网络抖动影响</li>
</ul>


<p>异步模式</p>

<ul>
<li>主机不等待备机的应答</li>
<li>性能最优，可能造成数据丢失不一致</li>
</ul>


<p>半异步</p>

<ul>
<li>超过多数成功则返回</li>
<li>奇数台机器才可以</li>
<li>3/5 > 2/3 > 2/2</li>
</ul>


<!--more-->


<h2>网络</h2>

<ul>
<li>任意两个进程可以传递消息</li>
<li>进程有本地物理时钟 时钟使用NTP同步</li>
<li>超时有上限</li>
<li>进程不会发错误的消息</li>
</ul>


<h2>分布式选举基本问题</h2>

<p>不可靠的机群实现可靠的协议，通过投票的方案</p>

<ul>
<li>任意时刻只能有一个主</li>
<li>要容忍网络分区</li>
<li>Leader Lease，选主要等待上个主的lease过期</li>
<li>Lease周期的长短</li>
</ul>


<p>Paxos要求</p>

<ol>
<li>成员不能说假话（非拜占庭）</li>
<li>单个成员说话不能相互矛盾（投票给A了不能投票给B）</li>
<li>修改需要多数成员同意</li>
</ol>


<p>实现</p>

<ol>
<li>记住自己在lease周期的投票</li>
<li>重启等待一个lease周期不投票</li>
<li>多个人都想成为主的时候</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase事务引擎-笔记]]></title>
    <link href="http://cxh.me/2014/06/10/o-transaction/"/>
    <updated>2014-06-10T19:39:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/o-transaction</id>
    <content type="html"><![CDATA[<h2>外存数据库的特点</h2>

<p>每次写入需要读取一个完整单元，不同的块做不同的修改，再写回硬盘</p>

<h2>oceanbase的特点</h2>

<p>本质上差不多，但是快大小不一样，但是增量数据(修改点)集中存储。可以更好的利用内存，利用低峰期合并到内存。但是每次需要读取静态数据和修改。</p>

<p>相对来讲，优化了写入，牺牲了部分读取（完全命中bloomfilter的可以不读静态，相当于内存数据库，不存在动态数据的查询相当于传统数据库）。</p>

<!--more-->


<h2>业界的内存数据库</h2>

<ul>
<li>VoltDB</li>
<li>MemSQL</li>
</ul>


<p>内存数据库很贵</p>

<h2>存储事务引擎</h2>

<ul>
<li>hash索引：散列存储，单点查询更快</li>
<li>B+树索引：顺序索引，范围查询</li>
</ul>


<h2>更新流程</h2>

<ul>
<li>根据主键找到行所在位置</li>
<li>加锁</li>
</ul>


<h3>多版本并发控制</h3>

<p>针对高并发的请求，分配在一个队列里面，排队，不需要抢锁。线程可以省下来给其他</p>

<p>通过 /<em>hot_spot</em>/的hint实现，交给用户决定</p>

<h3>写日志的性能瓶颈</h3>

<p>每次写两条日志，保证两台备机写成功，1333条每秒</p>

<p>只能通过软件上的改变，group commit</p>

<p>每次commit合并多个写日志请求。</p>

<p>条件：</p>

<ul>
<li>空闲的时候直接commit。有日志来的时候判断没有日志在写，就提交。</li>
<li>聚集到一个阈值的时候写。有日志在写，就放到buffer里面。直到达到阈值。</li>
<li>如果第一个写完日志，系统空闲，就写日志。</li>
</ul>


<h3>总结</h3>

<ul>
<li>内存数据库+分布式系统的设计</li>
<li>mvcc的实现</li>
<li>group commit</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一个实际中遇到的覆盖问题]]></title>
    <link href="http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus/"/>
    <updated>2014-06-10T19:32:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个继承结构如下：</p>

<pre><code>ObServerSchemaService : init_core_schema(const ObSchemaManagerV2 &amp;schema)
         |
ObRootSchemaSerivice : init_core_schema()
</code></pre>

<p>  基类的init_core_schema接收一个核心表的schema，而这个schema往往是从rootserver传过来的，所以下面的子类RootSchemaService不需要传参，直接自己生成就好了。</p>

<p>  问题是如果在ObRootSchemaService的对象上想要调用ObServerSchemaService的init_core_schema函数会报错。因为命名空间上Root的会覆盖Server的，哪怕只是同名的数据成员也会隐藏基类的成员函数。比如：</p>

<pre><code>struct TableSchema
{
  const static int version_ = 1;
  int mem_version()
  {
    return version_;
  }
};

struct ExTableSchema: TableSchema
{
  int mem_version;
};
int main(void)
{
  ExTableSchema schema;
  schema.mem_version();
}
</code></pre>

<p>  解决方法很简单，直接指明命名空间就行了</p>

<pre><code>schema.TableSchema::mem_version();
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oceanbase简介 - 笔记]]></title>
    <link href="http://cxh.me/2014/06/09/oceanbase-introduction-note/"/>
    <updated>2014-06-09T19:01:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/oceanbase-introduction-note</id>
    <content type="html"><![CDATA[<h1>数据库简介</h1>

<h2>数据库的特点</h2>

<ul>
<li>原子性 ： 一笔账，要么转了，要么没转</li>
<li>一致性 ： 出账入账必须一致</li>
<li>隔离性 ： 多人转账不得相互影响</li>
<li>持久性 ： 转账一旦发生，持久存在</li>
</ul>


<p>还有两个：</p>

<ul>
<li>高可用</li>
<li>高性能</li>
</ul>


<h2>数据库 vs 计算机</h2>

<p>服务器：处理器，内存，磁盘，网卡</p>

<ul>
<li>原子性：计算机只能保证寄存器的原子</li>
<li>一致性：单个服务器上数据一致性比较好做</li>
<li>隔离性：多个事务串行处理隔离性不好做</li>
<li>持久性：磁盘或者固态盘才有持久性</li>
<li>高可用：磁盘年均故障率1%-3%，单个磁盘可用率99%-99.9%</li>
<li>高性能：服务器性能</li>
</ul>


<!--more-->


<h1>数据库和互联网</h1>

<p>银行 + 商务</p>

<p>网购：一次商务+一次金融</p>

<p>双十一：一天350亿，55s超过1个亿，支付宝2亿笔交易，头一分钟一千万买家上线</p>

<p>黑色星期五：美国19.3亿美元</p>

<h2>互联网时代数据库的要求</h2>

<p>ACID无法取代</p>

<p>在线金融、网购需要数据库高可用99.999%</p>

<p>可扩展性，性价比</p>

<h1>oceanbase</h1>

<p>高档服务器，高档存储，高深的数据库软件</p>

<p>传统数据库的高可用：</p>

<p>主库+备库， 共享存储，数据同步备库</p>

<p>主备同步三种模式：</p>

<ul>
<li>最大同步，可用性太差</li>
<li>最高性能，一致性太差</li>
<li>最大可用，尽力同步，备库应答OK，超时则容错，有丢失风险</li>
</ul>


<p>银行可靠性依赖于物理可靠性</p>

<p>传统数据库性价比不高，硬件，软件很贵</p>

<p>oceanbase 用了普通服务器，水平扩展 = 云计算+关系数据库 ， 存储大部分是固态盘</p>

<p>性能+可用性+扩展性</p>

<h3>性能</h3>

<ul>
<li>机械盘读 ： 机械磁盘随机读 100-300次/秒（IOPS)</li>
<li><p>SSD随机读： 几万次每秒</p></li>
<li><p>机械盘写：100-300次/秒</p></li>
<li>数据库写入放大：每次修改100B导致4k块的修改，oracle 8k mysql 16k， 产生几十倍的放大效应</li>
<li>固态盘：写入放大，先擦后写，有时候一次擦十几兆，需要先读再迁再擦再写</li>
</ul>


<h3>全内存数据库</h3>

<ul>
<li>性能高，性价比低，容量小</li>
<li>适用需要极高性能且数据量小的业务</li>
</ul>


<h3>Oceanbase</h3>

<p>内外存混合数据库</p>

<p>内存：热数据，频繁修改</p>

<p>外存：冷数据</p>

<p>性能略逊，容量大，性价比高</p>

<p>消除传统数据库写入放大</p>

<p>高可用：如何以低可靠硬件实现</p>

<h3>oceanbase Milestone：</h3>

<p>淘宝收藏夹->双集群（可以升级改bug对业务透明）-> OLAP功能 &ndash;> SQL支持 &ndash;> 三集群（分布式投票）</p>

<h3>oceanbase应用</h3>

<ul>
<li>稳定可靠</li>
<li>可在线扩展，业务增长过快</li>
<li>高性能低成本</li>
<li>不锁表创建索引</li>
</ul>


<h3>oceanbase质量保证</h3>

<p> 严格的c/c++编码规范
&ndash; 资源申请者负责释放
&ndash; 单入口单出口
&ndash; 定长内存管理
&ndash; 禁用全局变量，goto
&ndash; 严格限制使用stl
&ndash; 统一编码风格</p>

<p>无处不在的crc</p>

<h3>oceanbase数据校验</h3>

<ul>
<li>磁盘读写，每个记录带64位CRC</li>
<li>网络传输：每个网络包带64位CRC</li>
<li>多副本多个crc</li>
<li>修改增量多副本：64位CRC校验</li>
<li>redolog：每条带64位crc</li>
<li>每个表每个列64位crc</li>
</ul>


<p>灰度升级</p>

<h2>小结：</h2>

<p>数据库是人类伟大智慧的结晶</p>

<p>机会：</p>

<ul>
<li>云计算技术</li>
<li>网购繁荣</li>
<li>中国经济腾飞</li>
<li>ssd普及</li>
<li>优秀技术人才</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见的防御性编程策略]]></title>
    <link href="http://cxh.me/2014/06/09/defensive-strategy/"/>
    <updated>2014-06-09T11:51:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/defensive-strategy</id>
    <content type="html"><![CDATA[<p>  针对出错之后不能恢复的情况，最好的办法是写另外一个对象，确认成功之后原子的交换对象。同时也能避免对一个对象的修改持锁时间过长。这种思路广泛用在很多地方。</p>

<ol>
<li> 保存备份文件，当前的文件有可能有人在读在写，所以每次线程都写一个单独的备份文件，最后原子的覆盖之前的文件。</li>
<li> 升级系统。自动升级的时候下载了新的可执行文件，然后删除原来的文件，替换成下载文件。当然估计不会有人直接覆盖之前的文件。</li>
<li> 一些NOSQL的冻结。OB里面比较典型的就是UpdateServer的内存冻结，当然是copy on write实现的，最后原子的切换B树的根指针。主要是为了minor fqreeze的时候依然能提供写入服务。</li>
<li> =运算符重载的时候，如果当前类持有的对象先释放了，但是又没能成功复制需要拷贝的对象，就会有悬空的风险。effective c++里面给了一种实现方式，就是先生成一份拷贝，再swap。</li>
</ol>


<p>一个简单的例子如下：</p>

<pre><code>int do_checkpoint()
{
  int ret = OB_SUCCESS;
  if (enable_backup_)
  {
    if (OB_SUCCESS != (ret = write_to_file(tmp_file_path_)))
    {
      TBSYS_LOG(WARN, "failed to write schema backup file:ret[%d]", ret);
    }
    else
    {
      //copy tmp to schema.ini
      unlink(schema_file_path_);
      if (0 == rename(tmp_file_path_, schema_file_path_))
      {
        TBSYS_LOG(INFO, "save schema to backup succ. refresh_times_:%ld", refresh_times_);
      }
      else
      {
        TBSYS_LOG(WARN, "rename new schema file failed:ret[%d]", ret);
        ret = OB_ERR_UNEXPECTED;
      }
    }
  }
  return ret;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim7.4 && vimgdb编译]]></title>
    <link href="http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile/"/>
    <updated>2014-06-09T10:52:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile</id>
    <content type="html"><![CDATA[<p>  首先，你下载的vim7.4代码的一般结构跟常见的工程是不一样的，主要体现在configure不会生成Makefile，make的时候是通过Makefile的配置生成config.h的，也就是说你想的好好的希望如下操作：</p>

<pre><code> ./configure --prefix=$HOME --with-features=huge --enable-multibyte --enable-pythoninterp --enable-cscope --enable-fontset --enable-gdb --enable-largefile \
 --enable-gui=gnome2 \
 --enable-luainterp \
 --enable-tclinterp \
 --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu  #编译配置
 --with-lua-prefix=/usr/local/bin/lua

    make &amp;&amp; make install
</code></pre>

<p>  来编译的话，那么实际配置跟上面configure里面是没有关系的。</p>

<p>  以你需要做的是修改Makefile，打开必要的开关，比如安装目录，lua支持什么的</p>

<pre><code># Uncomment the next line to install Vim in your home directory.
prefix = $(HOME)
# LUA
# Uncomment one of these when you want to include the Lua interface.
# First one is for static linking, second one for dynamic loading.
# Use --with-luajit if you want to use LuaJIT instead of Lua.
# Set PATH environment variable to find lua or luajit executable.
CONF_OPT_LUA = --enable-luainterp
#CONF_OPT_LUA = --enable-luainterp=dynamic
#CONF_OPT_LUA = --enable-luainterp --with-luajit
#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit
</code></pre>

<p>  其他的操作按如下步骤就行，摘自<a href="https://github.com/larrupingpig/vimgdb-for-vim7.4" title="vimgdb">larrupingpig/vimgdb-for-vim7.4</a>：</p>

<h3>vimgdb install</h3>

<p>  You need:</p>

<p>  vim-7.4.tar.bz2 <a href="http://www.vim.org/sources.php">http://www.vim.org/sources.php</a></p>

<p>  vimgdb-for-vim7.4 (this patch) <a href="https://github.com/larrupingpig/vimgdb-for-vim7.4">https://github.com/larrupingpig/vimgdb-for-vim7.4</a></p>

<p>  Untar all files, apply the patch and make Vim:</p>

<pre><code>tar xjvf vim-7.4.tar.bz2 -C /tmp

tar xzvf vimgdb-for-vim7.4.tar.gz -C /tmp

cd /tmp

patch -p0 &lt; vimgdb-for-vim7.4/vim74.patch

cd vim74/src

make

sudo make install
</code></pre>

<h3>Install vimGdb runtime:</h3>

<p>  Copy the file vimgdb_runtime found in the vimgdb tarball, to your runtime path. To find your runtime path location execute the vim command (this is usually $HOME/.vim): :set runtimepath?</p>

<pre><code>cp -rf /tmp/vimgdb-for-vim7.4/vimgdb_runtime/* ~/.vim
</code></pre>

<p>  Change to the doc directory, start Vim and run the &ldquo;:helptags .&rdquo; command to process the taglist help file. Without this step, you cannot jump to the taglist help topics. You can now use the &ldquo;:help vimgdb&rdquo; command to get the vimGdb documentation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[总结Oceanbase编码中需要注意的一些细节]]></title>
    <link href="http://cxh.me/2014/06/09/oceanbase-cplusplus-note/"/>
    <updated>2014-06-09T10:38:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/oceanbase-cplusplus-note</id>
    <content type="html"><![CDATA[<ol>
<li><p>所有指针使用之前都需要判断是否为NULL，尤其是如果有IF分支的情况下，如：</p>

<pre><code> if (it != NULL)
 {
     xxx
 }
 else
 {
     it不能再使用了
 }
</code></pre></li>
<li><p>不要使用strcpy而应该使用strncpy。</p></li>
<li><p>所有成员函数都应该考虑是否为const函数.</p></li>
<li><p>所有函数都需要判断传入值是否有效。</p></li>
<li><p>有返回值的函数，需要先定义返回值的默认值，不能直接返回中间结果。比如：</p>

<pre><code> //这样是很容易造成问题的
 int * xxx(xxx)
 {
     int* it = NULL;
     for(int * it =xxx;it != xxx; it ++)
     {}
 }
 //而应该这样
 int * xxx(xxx)
 {
     int* ret = NULL;
     for (int * it = xxx; it != xx; it++)
     {ret = it}
     return ret;
 }
</code></pre></li>
<li><p>所有的错误码都需要向上抛出。错误码不能被隐藏，任何语句执行的前提条件都是之前没有错误。循环尤其需要注意。如：</p>

<pre><code> for (int i = 0; i &lt; xx; i++)
 {
     xxx
 }
 //需要改成
 for (OB_SUCCESS == ret &amp;&amp; int i = 0; i &lt; xx; i++)
 {
     xxx
 }
</code></pre></li>
<li><p>ObArray等动态表结构使用前尽量reserve.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用树莓派和DS18B20监控温度变化]]></title>
    <link href="http://cxh.me/2014/05/25/pi-temperature-sensor/"/>
    <updated>2014-05-25T14:16:00+08:00</updated>
    <id>http://cxh.me/2014/05/25/pi-temperature-sensor</id>
    <content type="html"><![CDATA[<p>  基本的教程在这里:</p>

<blockquote><ol>
<li><a href="http://wemaker.cc/60" title="树莓派GPIO引脚详解">引脚定义</a></li>
<li> <a href="http://s.mile77.com/?p=2039" title="树莓派+多个DS18B20+Yeelink，全天候监测多个点的温度">传感器教程1</a></li>
<li> <a href="http://blog.sina.com.cn/s/blog_3cb6a78c0101a46w.html" title="Raspberry Pi 使用DS18B20温度传感器">传感器教程2</a></li>
</ol>
</blockquote>

<p>  鉴于我的硬件水平只限于插板子焊板子和对针脚，其他的都还给数电模电老师了，我还是老老实实买了模块，省的自己焊电阻。
芯片，模块都是淘宝买的，随便搜一家就行，几块钱的东西一般不会有假的。</p>

<p>  整个过程可以按照教程1，2 对应针脚完成，如果顺利基本一次成功。别人的知识产权我就不好摘录了。但是代码我优化了一下，硬件工程师的代码果然是写的异常粗犷。修改后的代码如下：</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:temperature.py
import os,datetime,time

def calc_temperature(filename):
    res = 0
    valid_count = 0
    for i in range(0,5):
        with open(filename) as tfile:
            text = tfile.read()
        lines = text.split("\n")
        firstline, secondline = lines[0], lines[1]
        crc = firstline.split(" ")[11]
        if crc == 'YES':
            temperaturedata = secondline.split(" ")[9]
            temperature = float(temperaturedata[2:])
            temperature = temperature / 1000
            valid_count += 1
            res += temperature
            print temperature
        else:
            with open(os.path.expanduser("~/sys.log"), "a") as err:
                err.write("CRC Error: %s\n%s\n" % (datetime.datetime.now().strftime("%Y/%M/%d-%H:%M:%S"), text))
        time.sleep(0.2)
    return res/valid_count if valid_count &gt; 0 else -1

#temperature = calc_temperature("input.txt")
temperature = calc_temperature("/sys/bus/w1/devices/28-000005e31fe6/w1_slave")
if temperature &gt; 0:
    res = '{"value":%f}' %temperature
    with open(os.path.expanduser('~/datafile.txt'), 'w') as output:
        output.write(res)
</code></pre>

<!--more-->


<p>  上传的脚本依然可以用教程里面的。Yeelink居然是一家青岛的公司，感慨省里总算有点互联网的公司了，当然网站做的是挺粗糙的。Yeelink的android手机端一直提示我登录密码出错。重置了也不行。后来发现登陆的时候不是邮箱&hellip;那你网站干嘛又能用邮箱登陆我擦&hellip;.</p>

<p>  温度曲线的图片如下：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014-5/before.png" title="温度曲线" alt="温度曲线"><p class="align-center">温度曲线</p></p>

<p>  开始的程序没有考虑求平均，不知道会不会有临时跳变的瞬间值。后来加了平均值之后发现多次取的结果是不一样，但是不清楚这个芯片采集的周期是多少。多次平均的结果如下所示：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014-5/data.png" title="多次平均的结果" alt="多次平均的结果"><p class="align-center">多次平均的结果</p></p>

<p>  ps: 公司周末真热&hellip;.</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 树莓派GPIO引脚详解, <a href="http://wemaker.cc/60">http://wemaker.cc/60</a></p>

<p>[2] 树莓派+多个DS18B20+Yeelink，全天候监测多个点的温度, <a href="http://s.mile77.com/?p=2039">http://s.mile77.com/?p=2039</a></p>

<p>[3] Raspberry Pi 使用DS18B20温度传感器, <a href="http://blog.sina.com.cn/s/blog_3cb6a78c0101a46w.html">http://blog.sina.com.cn/s/blog_3cb6a78c0101a46w.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OB的Offset和Limit]]></title>
    <link href="http://cxh.me/2014/04/18/offset-and-limit-in-ob/"/>
    <updated>2014-04-18T20:54:00+08:00</updated>
    <id>http://cxh.me/2014/04/18/offset-and-limit-in-ob</id>
    <content type="html"><![CDATA[<p>   数据库的实现里面很重要的两个功能就是Limit和Offset,在web里面，这是分页的基本功能依赖。对于用户来说，一屏不可能显示全部的数据，所以数据请求可以拆散成多个，每次从上次的offset开始读取下一个limit的数据。有些情况下， 我们不需要知道一共有多少数据，只需要循环获取并统计期望的数据和得到的数据，直到两个不匹配。在实际web使用中，这种策略一般不使用，因为预先知道分页数。当然我也真见过这么用的，这nm简直就是无底洞。不知道点到什么时候是个头。</p>

<p>   相应的，正常的策略我们是需要知道数据有多少页的。也就有如下几种策略：</p>

<ol>
<li>. 最烂的实现当然是直接刷出所有数据分页显示其他隐藏。其实数据量如果确实很小的情况下，这样也合理。提高响应速度。</li>
<li>. 发一条count()先统计所有数据，然后计算分页数。 很多分页控件都直接支持count参数，分页会计算offset。</li>
<li>. 数据量非常大的情况下，count()也会造成额外的开销。也就有如下几种方式优化。

<ol>
<li> 单独一张表存储count()，每次有插入数据的时候都同时更新count()，插入过程可以做成存储过程减少网络开销。或者其实我们需要的只是分页数，而每屏显示的数量往往又是固定的，可以直接存分页数。</li>
<li> 有时候自增长ID也可以直接用来做这个。当然问题是不能删数据。</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用来把一个线程的日志输出到单独文件的脚本]]></title>
    <link href="http://cxh.me/2014/02/14/vim-script-to-write-thread-log/"/>
    <updated>2014-02-14T21:32:00+08:00</updated>
    <id>http://cxh.me/2014/02/14/vim-script-to-write-thread-log</id>
    <content type="html"><![CDATA[<p>  很多开源项目的日志都是把多个线程的日志打印到一个文件的，有时候我们需要查看一个线程号下的所有日志，vim选中高亮线程号固然是一种方法，但是看起来不直观，以下脚本完成输出一个线程所有日志到一个文件的功能。</p>

<pre><code>"plugin-写一个线程的log到单独文件
function! ThreadLog()
    let file = readfile(expand("%:p"))
    let pattern = expand('&lt;cword&gt;')
    let matches = []
    for line in file
        let match = matchstr(line, pattern)
        if(!empty(match))
           call add(matches, line)
        endif
    endfor
    let s:filename= pattern . '.log'
    call writefile(matches, s:filename )
endf
nmap &lt;leader&gt;th :call ThreadLog()&lt;cr&gt;
</code></pre>

<p>  使用的时候把光标移动到线程号下面，然后,th就行了。实际上完成的是把所有包含当前单词的行都输出到一个文件的功能。文件名是当前单词。目测够用了。</p>

<p>  好久没写博客了，甚觉我已经离文人很远了。在这个欢乐祥和的日子里，实在是觉得生活充满了顾虑。人生就是这么多矛盾啊，不确定是种状态，确定也是种状态，想想之所以依然这么漂泊着，也就是应了一句话：青春逝去，认输之前。当然了，我觉得我还挺青春的。青春这东西，最重要的不是外表，阳光，积极向上什么的。这都是表面。青春是变革，至少是变革的勇气。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转载王垠的一段话]]></title>
    <link href="http://cxh.me/2014/01/06/wangyin-words/"/>
    <updated>2014-01-06T21:59:00+08:00</updated>
    <id>http://cxh.me/2014/01/06/wangyin-words</id>
    <content type="html"><![CDATA[<p>  王垠虽然挺扯，这段话还是有道理的：</p>

<p>  我对清华，还有 Princeton，Harvard，MIT，Stanford，Berkeley，CMU 等学校的学生都有了解。这些所谓的“世界一流大学”或者“世界一流大学 wannabee”差不多都是类似的气氛。你冲着它们的名气和“关系网”挤破了头皮进去，然后就每天有人在你耳边对其它人感叹：哇，他好牛啊！发了好多 paper，还得了XX奖。跟参加传销大会似的，让你怀疑这些人还有没有自尊。然后就是填鸭式的教育，无止境的作业和考试，让你感觉他们不是在“教育”你，而是在“筛选”你。这种筛选总是筛掉最差的，但也筛掉最好的。因为最好的学生能意识到你在干什么，他们不给你筛选他们的机会。一旦发现其实没学到东西，中途就辍学出去创业了。所以剩下来的就是最一般的，循规蹈矩听话的。在这样的环境里，你感觉不到真正的智慧和真知的存在。GRE 考试所鼓吹的什么“批判性思维”（critical thinking ）在美国大学里其实是相当缺乏的。学生们只不过是在被培训成为某些其他人的工具，他们具有固定的思维定势，像是一个模子倒出来的。他们不是真正的创造者和开拓者。</p>

<p>  原文出处： <a href="http://www.yinwang.org/blog-cn/2014/01/04/authority/">http://www.yinwang.org/blog-cn/2014/01/04/authority/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thinking In Java读书笔记]]></title>
    <link href="http://cxh.me/2013/11/24/thinking-in-java-notes/"/>
    <updated>2013-11-24T20:32:00+08:00</updated>
    <id>http://cxh.me/2013/11/24/thinking-in-java-notes</id>
    <content type="html"><![CDATA[<p>  静态成员只有被引用（首次生成所在类的对象或者被首次访问，即使从为生成过那个类的对象）的时候才会初始化。</p>

<p>  一般情况下Java成员变量初始化顺序是，静态成员/静态快->直接初始化的类成员->构造函数</p>

<p>  一个简单的例子如下:</p>

<!-- more -->


<p>  <strong>Cup.java</strong></p>

<pre><code>public class Cup {
    public Cup(int i)
    {
        System.out.println("constructor" + i);
    }
}
</code></pre>

<p>  <strong>TestJava.java</strong></p>

<pre><code>public class TestJava {
    public Cup cup;
    public Cup cup3 = new Cup(3);
    public static Cup cup1 = new Cup(1);
    public static Cup cup2;
    static{
        cup2 = new Cup(2);
    }
    public TestJava(){
        cup = new Cup(0);
    }
    public static void main(String[] args) {
        new TestJava();
    }
}
</code></pre>

<p>  <strong>执行结果是</strong></p>

<pre><code>constructor1
constructor2
constructor3
constructor0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective C++ 读书笔记]]></title>
    <link href="http://cxh.me/2013/11/23/effective-notes/"/>
    <updated>2013-11-23T16:41:00+08:00</updated>
    <id>http://cxh.me/2013/11/23/effective-notes</id>
    <content type="html"><![CDATA[<p>  Effective前面有几节是说构造析构赋值过程中基类和派生类的调用关系的，做了一个综合一点的例子，来验证一下这个问题。代码如下，话说贴代码是在是很没溜的做法，尤其是如果在出版的书中看到的话，这种行为基本属于骗稿费的&hellip;</p>

<!-- more -->


<p>  <strong>object.h</strong></p>

<pre><code>#ifndef OCEANBASE_OBJECT_H_
#define OCEANBASE_OBJECT_H_

#include "base_object.h"
class Object: public BaseObject
{
  public:
    Object ();
    Object (int magic);
    Object (const Object &amp; obj);
    virtual ~Object ();
    virtual void print_info();
    Object&amp; operator= (const Object&amp; obj);
    const int &amp; get_magic() const;
    const int &amp; get_magic();
  private:
    /* data */
    int magic_;
};

#endif //OCEANBASE_OBJECT_H_
</code></pre>

<p>  <strong>object.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "object.h"

Object::Object():magic_(0)
{
  printf("construct in derived \n");
}

Object::Object (int magic):magic_(magic), BaseObject(magic)
{
  printf("construct in derived with magic\n");
}

Object::Object (const Object &amp; obj)
  : BaseObject(obj)
{
  printf("copy construct in derived\n");
  magic_ = obj.magic_;
}

Object::~Object()
{
  printf("destructor in derived\n");
}

const int &amp; Object::get_magic() const
{
  printf("const\n");
  return magic_;
}

const int &amp; Object::get_magic()
{
  printf("non const\n");
  return magic_;
}

Object&amp; Object::operator= (const Object&amp; obj)
{
  printf("operator = in derived\n");
  //BaseObject::operator =(obj);
  magic_ = obj.magic_;
}

void Object::print_info()
{
  BaseObject::print_info();
  printf("derived:magic_%d\n", magic_);
}
</code></pre>

<p>  <strong>base_object.h</strong></p>

<pre><code>#ifndef OCEANBASE_BASE_OBJECT_H_
#define OCEANBASE_BASE_OBJECT_H_
class BaseObject
{
  public:
    BaseObject ();
    BaseObject (int base_magic);
    BaseObject (const BaseObject &amp;obj);
    virtual ~BaseObject ();
    //BaseObject &amp; operator= (const BaseObject &amp; obj);
    virtual void print_info();
  private:
    /* data */
    int base_magic_;
};

#endif //OCEANBASE_BASE_OBJECT_H_
</code></pre>

<p>  <strong>base_object.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "base_object.h"
BaseObject::BaseObject():base_magic_(0)
{
  printf("construct in base\n");
}

BaseObject::BaseObject(int base_magic):base_magic_(base_magic)
{
  printf("construct in base with magic\n");
}

BaseObject::BaseObject (const BaseObject &amp;obj)
{
  printf("copy construct in base\n");
  base_magic_ = obj.base_magic_;
}

BaseObject::~BaseObject()
{
  printf("destructor in base\n");
}

//BaseObject &amp; BaseObject::operator= (const BaseObject &amp; obj)
//{
  //printf("operator = in base\n");
  //base_magic_ =  obj.base_magic_;
//}

void BaseObject::print_info()
{
  printf("base_object: base_magic_%d\n", base_magic_);
}
</code></pre>

<p>  <strong>main.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "object.h"
int main(int argc, const char *argv[])
{
  printf("\n");
  printf("obj1\n");
  Object obj1(1);

  printf("\n");
  printf("obj2\n");
  Object obj2(2);

  printf("\n");
  obj2=obj1;

  printf("\n");
  printf("obj1.print_info()\n");
  obj1.print_info();

  printf("\n");
  printf("obj2.print_info()\n");
  obj2.print_info();

  printf("\n");
  return 0;
}
</code></pre>

<p>  <strong>Makefile</strong></p>

<pre><code>objects= main.o object.o base_object.o
outfile= out
flag= -g
cc= g++

$(outfile):$(objects)
    $(cc) $(flag) -o $(outfile) $(objects)

object.o:object.h
base_object.o:base_object.h
main.o:object.h base_object.h


.PHONY:clean
clean:
    -rm -f $(outfile) $(objects)
</code></pre>

<p>执行结果是：</p>

<pre><code>obj1
construct in base with magic
construct in derived with magic

obj2
construct in base with magic
construct in derived with magic

operator = in derived

obj1.print_info()
base_object: base_magic_1
derived:magic_1

obj2.print_info()
base_object: base_magic_2
derived:magic_1

destructor in derived
destructor in base
destructor in derived
destructor in base
</code></pre>

<p>  可以自行调整并执行，主要说明几个问题而已：</p>

<ol>
<li> Object c2=c1;这种会被编译器优化成拷贝构造，中间不会有=运算符的调用。</li>
<li> 没有显式声明的时候编译器为类生成默认构造函数，没有显示指明的情况下派生类构造函数自动调用基类的默认构造函数，如果基类有需要初始化的一定要手动声明并调用带参构造函数。</li>
<li> 没有显式声明的时候编译器为类生成默认拷贝构造函数，没有指明的情况下拷贝构造的时候派生类不会调用基类的拷贝构造，只会调用基类的默认构造函数来内部的基类对象，所以需要自己调用基类的拷贝构造。</li>
<li> 编译器不会为=运算符自动生成重载，=运算符也不调用基类的=运算符重载，所以需要自己声明并调用，这也是书中强调的。</li>
<li> 没有=运算符重载的情况下遇到=操作，拷贝对象每个字段。</li>
</ol>


<p>  总结一下如下表：</p>

<p>   <table>
<caption>表1 总结下对象生成类的函数的编译器行为</caption>
<thead>
<tr class="header">
<th align="center">函数</th>
<th align="center">没有声明的情况下是否自动生成</th>
<th align="center">是否默认调用基类的对应函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">构造函数</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr class="even">
<td align="center">拷贝构造</td>
<td align="center">是</td>
<td align="center">否,调用基类默认构造函数构造基类对象</td>
</tr>
<tr class="odd">
<td align="center">等号运算符重载</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody>
</table></p>

<p>  注：虽然应该是c++标准，但是还是限制一下编译器版本吧，在gcc4.4.6下验证通过（ob的编译器版本）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式调试系列之行为模拟]]></title>
    <link href="http://cxh.me/2013/11/21/use-mock-to-debug/"/>
    <updated>2013-11-21T17:31:00+08:00</updated>
    <id>http://cxh.me/2013/11/21/use-mock-to-debug</id>
    <content type="html"><![CDATA[<p>  最近调试分布式系统，感觉实际上什么看日志的方式都不如带集群调试，当然有些行为是比较难以模拟的，可能的情况下，要么重现环境，要么对部分模块做mock。单测带来的便利性是远超过不做mock省下的时间的，比如与sql相关的逻辑完全可以启动一个完整的sql环境，然后把请求发过去，看回来的响应。至于其他的部分，基本的原则是减少变量。比如两个server之间的通信，同时检测两个server只能看日志，所以最好能mock一个server的行为，这样减少调试的不确定性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于ob代码规范里面的行末空格]]></title>
    <link href="http://cxh.me/2013/11/20/method-to-deal-with-blanks-at-line-end/"/>
    <updated>2013-11-20T10:50:00+08:00</updated>
    <id>http://cxh.me/2013/11/20/method-to-deal-with-blanks-at-line-end</id>
    <content type="html"><![CDATA[<p>  行尾的空格在post-review的时候会被标识成红色，其实可以通过如下vim配置直接显示出来并全部去掉：</p>

<pre><code>" 删除所有行未尾空格
nnoremap &lt;C-f12&gt; :%s/[ \t\r]\+$//g&lt;cr&gt;''
"显示空格
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
augroup ExtraWhitespaceGroup
    autocmd!
    autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
    autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@&lt;!$/
    autocmd InsertLeave * match ExtraWhitespace /\s\+$/
    autocmd BufWinLeave * call clearmatches()
augroup END
</code></pre>

<p>  这样打开所有文件（其实可以只处理cpp)的时候行尾空格都会变成红色，&lt;Ctrl-F12>可以统一去掉所有的空格。这么做唯一不爽的是如果有未遵从代码规范的文件那么就满篇的红色。比如多隆大神早期的代码&hellip;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于得到当前执行文件所在的目录]]></title>
    <link href="http://cxh.me/2013/11/19/method-to-get-absolute-path-of-current-program/"/>
    <updated>2013-11-19T21:47:00+08:00</updated>
    <id>http://cxh.me/2013/11/19/method-to-get-absolute-path-of-current-program</id>
    <content type="html"><![CDATA[<p>  今天遇到一个问题，程序里面用相对路径引用了同一级目录下的一个文件，shell在上一级目录调用程序的时候，发现当前目录变成了上一级目录，于是程序在上一级目录找那个文件。最简单的办法当然是shell脚本里面加cd操作，但是暂时不方便修改脚本。所以直接通过程序获取绝对路径好了。</p>

<p>  首先，直接 realpath(&ldquo;./&rdquo;) 和 getcwd 获取的都是当前路径，也就是当前shell所在的路径。<strong>FILE</strong>获取的是文件名，不包含路径，而且是编译过程确定的，最简单的办法当然是argv[0]，但是在test_case(gtest)里面不方便传来传去，后来发现最好的办法是这样的：</p>

<pre><code>#include "libgen.h"
#define MAX_PATH_SIZE 100
char current_absolute_path[MAX_PATH_SIZE] = {'\0'};
if (readlink("/proc/self/exe", current_absolute_path, MAX_PATH_SIZE - 1) &lt; 0)
{
  //error
}
else
{
  sprintf(current_absolute_path, "%s/%s", dirname(current_absolute_path), schema_file_name);
}
</code></pre>

<p>  这样就可以拼合当前程序所在目录和schema_file_name得到这个文件的绝对路径了。这里/proc/self/exe是运行时的当前执行程序软链接。看来proc目录下要好好研究一下啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式调试之导入import文件]]></title>
    <link href="http://cxh.me/2013/11/19/vim-script-to-find-import-file/"/>
    <updated>2013-11-19T17:41:00+08:00</updated>
    <id>http://cxh.me/2013/11/19/vim-script-to-find-import-file</id>
    <content type="html"><![CDATA[<p>  最近看元启师兄写了一个脚本更新所有重构之后的include引用，我暂时没有需要如此伤筋动骨的代码，所以暂时用不上。但是有时候引用一个类要去找所在的文件，而有时候经常会记错地方。写了一个简单的vim插件依赖ctags来找对象或函数所在的位置。代码如下：</p>

<!-- more -->


<pre><code>if !exists('g:base_dir_mark')
    "set base_dir_mark to indicate where to generate post-review.sh
    let g:base_dir_mark = 'tags'
endif

if !exists('g:strip_prefix_arr')
    "set base_dir_mark to indicate where to generate post-review.sh
    let g:strip_prefix_arr = ['rootserver', 'root_table']
endif

if !exists('g:import_token')
    "set base_dir_mark to indicate where to generate post-review.sh
    let g:import_token = 'import "%s"'
endif

function! GetImportFile()
    let filepath = expand("%:p")
    let base_dir = GetBaseDirectory() . 'src/'
    let idx = stridx(filepath, base_dir)
    if idx == 0
        let import_file_name = strpart(filepath, len(base_dir))
        let import_cmd = substitute(g:import_token, '%s', import_file_name, 'g')
        for prefix in g:strip_prefix_arr
            let import_cmd = substitute(import_cmd, prefix.'/', '', 'g')
        endfor
        let @" = import_cmd
        echo import_cmd
    endif
endf

function! GetBaseDirectory()
    let max = 5
    let dir = getcwd()
    let i = 0
    while isdirectory(dir) &amp;&amp; i &lt; max
        if filereadable(dir .'/'. g:base_dir_mark)
            return dir.'/'
        endif
        let idx = strridx(dir, '/')
        let dir = dir[:idx-1]
        let i = i + 1
    endwhile
    return ''
endf
</code></pre>

<p>  前提是配置好你的ctags，然后在系统根目录下用</p>

<pre><code>ctags -R * //其他语言
ctags -R  -c++-kinds=+p --fields=+iaS --extra=+q . //c++
</code></pre>

<p>  生成tags，插件会去去找tags文件，然后把找到的位置定义为项目目录，之后的引用路径会按照这路径来生成相对路径。strip_prefix_arr制定要去掉的前缀，比如我们的路径是/home/dev/src/rootserver/xxx.h，tags生成在dev下，按照base_dir_mark/src去掉项目路径得到 rootserver/xxx.h，根据strip_prefix_arr去掉rootserver，最后得到import &ldquo;xxx.h&#8221;。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式调试系列：关于日志的比对]]></title>
    <link href="http://cxh.me/2013/11/17/method-to-diff-log/"/>
    <updated>2013-11-17T22:00:00+08:00</updated>
    <id>http://cxh.me/2013/11/17/method-to-diff-log</id>
    <content type="html"><![CDATA[<p>  有时候我们其实会遇到这种情况，本地修改了一点东西，然后发现跑跟预期结果不一致，这时候去看日志发现各种日志里面有各种ERROR，但是这些ERROR实际上并不是这个问题导致的，因为你回滚修改之后发现这些ERROR依然存在。如果有core文件当然最好，但是如果没有或者core里面并看不出问题就比较纠结了。前面一篇文章我们探讨了如何<a href="http://qianjigui.iteye.com/blog/368449" title="Vim日志定位解决方案">写个插件通过log来定位源码行</a>，这篇日志我们讨论一下如何快速定位自己的错误日志。</p>

<p>  首先，前面的状况至少可以保证一点，你check一份新的代码或者回滚本地修改然后运行，得到的错误日志和你当前的错误日志是可比较的。也就是说，你的错误至少不会导致错误日志之中有巨大的变化。这样的话我们可以采取如下的策略比较错误日志。</p>

<ol>
<li> 得到当前的错误日志，假使命名为log.core</li>
<li> check一份新的代码或者回滚本地修改，得到之前的错误日志，假使命名为log.ok</li>
<li> 比较log.ok和log.core，分析日志的差别，得到本地修改导致的真实错误日志。</li>
</ol>


<p>  想法是很简单的，唯一的问题是OB日志里面是有时间戳的，这就导致没一行都有差异，那就太纠结了。我们可以用如下vim命令来去掉所有的时间戳。vim正则的转义规则见<a href="http://qianjigui.iteye.com/blog/368449" title="Vim 中的正则表达式">参考文献</a>。</p>

<pre><code>map :lg :%s/\(^\[.\{-}\]\)\\|\(\[\d\+\]\)\\|\(0x\w\+\)//g
</code></pre>

<p>  这里面唯一的风险是比如我们在中括号里面写的数字也会被剔除，好在我们只是比较日志差异，想要看原始日志大不了根据行号到完整版里面找去，而且这个概率不大。</p>

<p>  <!-- more --></p>

<p>  实际的效果是这样的。<s>我在考虑要不要把所有的tsi错误都去掉。</s> tsi的错误可以直接剔除0x\w+这些16进制数。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2013-11/logdiff.png" title="日志比较" alt="日志比较"><p class="align-center">日志比较</p></p>

<h3>参考文献:</h3>

<blockquote><p>[1] Vim 中的正则表达式, <a href="http://qianjigui.iteye.com/blog/368449">http://qianjigui.iteye.com/blog/368449</a></p>

<p>[2] Vim日志定位解决方案, <a href="http://cxh.me/2013/11/08/solution-to-locate-log-in-src/">http://cxh.me/2013/11/08/solution-to-locate-log-in-src/</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
