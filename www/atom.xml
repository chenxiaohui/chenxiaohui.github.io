<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-11-27T21:25:33+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[跨浏览器cookie]]></title>
    <link href="http://cxh.me/2014/11/25/flash-shared-cookie/"/>
    <updated>2014-11-25T16:57:00+08:00</updated>
    <id>http://cxh.me/2014/11/25/flash-shared-cookie</id>
    <content type="html"><![CDATA[<p>  有时候为了标识一个用户，我们需要跨浏览器的cookie，这样用户在一个浏览器的行为可以被另一个浏览器读取。当然这种行为也备受争议，对于保护用户隐私来讲，这简直是后门。所以cookie里面一定不要存任何重要数据。</p>

<p>  不过这么做也不完全是为了用户数据跟踪。从用户体验的角度看，可以这么实现跨浏览器甚至跨域的session。具体实现上有如下几种方法：</p>

<ol>
<li><p> Local Shared Objects (Flash Cookies)</p></li>
<li><p> Silverlight Isolated Storage</p></li>
<li><p> 使用HTML5客户端储存数据方法。</p></li>
<li><p> evercookie</p></li>
</ol>


<p>  关于第二种有一个解释：一般装了silverlight的人都装了flash，想想真是呵呵了。第三种参见<a href="http://www.zhangxinxu.com/wordpress/2011/09/html5-localstorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/" title="HTML5 localStorage本地存储实际应用举例">参考文献</a>。</p>

<p>  <a href="https://github.com/samyk/evercookie" title="EverCookie">evercookie</a>原则上讲不能算一种方法，而是一种实现。每次写入的时候都会把cookie写到多个地方，下次读取的时候如果发现cookie有丢失，就通过还存在cookie副本来恢复cookie。乍一看原理跟3721那个进程交叉保护差不多，也算是流氓软件了。</p>

<p>  这里我们重点讲第一种。</p>

<!--more-->


<p>  flash cookie使用的是flash自己的本地存储，所以决定于flash实例。大部分浏览器使用的是系统的flash实例，所以flash cookie能跨浏览器存在。但是有几个例外。</p>

<p>  目前实测IE/Maxthon/Firefox/Safari/360浏览器都是采用系统的Flash实例，所以能够共享flash cookie，目前测到的几个特例是chrome/搜狗/百度浏览器，分别采用了自己浏览器内部打包的flash实例。另外不同系统用户的cookie不共享。从下面一张图可以清晰看出：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/flash_cookie.png"></p>

<p>  flash cookie的写入可以参考如下项目&#8220;，作者在<a href="http://nfriedly.com/techblog/2010/07/swf-for-javascript-cross-domain-flash-cookies/" title="JavaScript library and .swf for cross-domain flash cookies">主页</a>详细说明了使用方法。需要注意的是swf_url控制的写入路径会包含在cookie的namespace里面，也就是说会有如下的目录结构：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/tree.png"></p>

<p>  另外关于跨域，作者说不同域的js需要使用同一个swf，猜测是js请求swf的时候浏览器不判断在哪个域。swf内部是有跨域安全机制的，如果关闭掉的话，是可以实现请求跨域的。但是js请求其他域的数据会被浏览器拒绝。</p>

<p>  测试如下：</p>

<p>  在两台机器上部署相同的Flash Cookie测试项目，其中61域和74域的js都请求74域的swf：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/cross.png"></p>

<p>  在74的机器上写入flash cookie: &ldquo;74 write&rdquo;</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/74write.png"></p>

<p>  在61的机器上load:</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/61load.png"></p>

<p>  证明可以跨域读取cookie。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] JavaScript library and .swf for cross-domain flash cookies, <a href="http://nfriedly.com/techblog/2010/07/swf-for-javascript-cross-domain-flash-cookies/">http://nfriedly.com/techblog/2010/07/swf-for-javascript-cross-domain-flash-cookies/</a></p>

<p>[2] Javascript-Flash-Cookies, <a href="https://github.com/nfriedly/Javascript-Flash-Cookies">https://github.com/nfriedly/Javascript-Flash-Cookies</a></p>

<p>[3]  How Facebook Sets and uses cross-Domain cookies, <a href="http://nfriedly.com/techblog/2010/08/how-facebook-sets-and-uses-cross-domain-cookies/">http://nfriedly.com/techblog/2010/08/how-facebook-sets-and-uses-cross-domain-cookies/</a></p>

<p>[4] HTML5 localStorage本地存储实际应用举例, <a href="http://www.zhangxinxu.com/wordpress/2011/09/html5-localstorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/">http://www.zhangxinxu.com/wordpress/2011/09/html5-localstorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</a></p>

<p>[5] EverCookie, <a href="https://github.com/samyk/evercookie">https://github.com/samyk/evercookie</a></p>

<p>[6] Anehta的水印(Watermark)机制, <a href="http://hi.baidu.com/aullik5/item/89496d121de969041894ecdd">http://hi.baidu.com/aullik5/item/89496d121de969041894ecdd</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[node_zk_browser安装时的一个问题]]></title>
    <link href="http://cxh.me/2014/11/19/error-with-node-zk-browser/"/>
    <updated>2014-11-19T18:56:00+08:00</updated>
    <id>http://cxh.me/2014/11/19/error-with-node-zk-browser</id>
    <content type="html"><![CDATA[<p>  zookeeper基本是基于API和console进行znode的操作，并没有一个比较方便的操作界面，taobao 伯岩大神写过一个工具node_zk_browser，可以比较方便的查询zookeeper信息。地址在</p>

<pre><code>https://github.com/killme2008/node-zk-browser
</code></pre>

<p>  界面如下所示：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/zk_browser.png" title="zk_browser" alt="zk_browser"><p class="align-center">zk_browser</p></p>

<p>  安装的时候遇到一个问题</p>

<pre><code>Downloading zookeeper-3.4.3 from http://apache.mirrors.tds.net/zookeeper/zookeeper-3.4.3/zookeeper-3.4.3.tar.gz
</code></pre>

<p>  这个地址是找不到的。apache的这个mirror上只有3.4.6的包了。改package.json也没用。表示不懂node.js，不知道npm去哪里找的url。</p>

<p>  但是我们可以这样绕过去。先到其他的路径下：</p>

<pre><code>npm install zookeeper
</code></pre>

<p>  这会安装最新的node-zookeeper，安装完毕之后生成一个node_modules目录，下面有一个zookeeper目录，直接复制这个目录到node-zk-browser下面的node_modules目录里。</p>

<p>  搞定。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Zookeeper的web管理应用, <a href="http://www.blogjava.net/killme2008/archive/2011/06/06/351793.html">http://www.blogjava.net/killme2008/archive/2011/06/06/351793.html</a></p>

<p>[2] node-zookeeper安装小记, <a href="http://blog.izturn.mobi/post/15025383777/node-zookeeper-install-note">http://blog.izturn.mobi/post/15025383777/node-zookeeper-install-note</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[du显示只显示一层子目录/文件的大小]]></title>
    <link href="http://cxh.me/2014/11/13/du-to-display-one-level/"/>
    <updated>2014-11-13T17:55:00+08:00</updated>
    <id>http://cxh.me/2014/11/13/du-to-display-one-level</id>
    <content type="html"><![CDATA[<p>  经常需要看当前目录下的子目录大小，比如开发机被人占满的情况，<code>du -lh</code>显示的是递归的所有文件大小，<code>du -s</code>又只统计了所有文件/文件夹合起来的大小。正常情况下需要执行：</p>

<pre><code>du -lh --max-depth=1
</code></pre>

<p>  未免太过麻烦。后来肖总提示发现这样就行了：</p>

<pre><code>du -sh *
</code></pre>

<p>  果然是学无止境啊</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚函数模板和模板类中的虚函数]]></title>
    <link href="http://cxh.me/2014/10/29/cpp-virtual-template-function/"/>
    <updated>2014-10-29T21:05:00+08:00</updated>
    <id>http://cxh.me/2014/10/29/cpp-virtual-template-function</id>
    <content type="html"><![CDATA[<p>  自从知道了C++不支持虚函数模板之后就觉得相关的一概不支持，今天写程序的时候想把基类做成模板，然后继承基类。以为也不支持，写了一下才发现支持的，无论是非模板类继承一个特化之后的模板还是模板类继承包含虚函数的模板基类都是没问题的。从实现上看，反正使用的时候都会特化的，特化之后虚函数表指针是固定的。不存在像函数模板这种类生成的时候无法确定虚函数表的情况。</p>

<p>  例子如下：</p>

<!--more-->


<pre><code>enum SessionType
{
  ROSession,
  RWSession,
  RPSession
};
class BaseTransCtx
{
  public:
    BaseTransCtx (){}
    virtual ~BaseTransCtx (){}
};
template&lt;typename Type&gt;
class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
typedef ISessionCtxFactory&lt;SessionType&gt; SessionMgr;
class TransSessionMgr: public SessionMgr
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    BaseTransCtx *alloc(const SessionType type)
    {
      return NULL;
    }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
int main(int argc, const char *argv[])
{
  TransSessionMgr trans;
  BaseTransCtx* ctx = trans.alloc(RWSession);
  trans.free(ctx);
  return 0;
}
</code></pre>

<p>  模板类继承虚基类也可以。</p>

<pre><code>template&lt;typename Type&gt;
class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
template&lt;typename Type&gt;
class TransSessionMgr: public ISessionCtxFactory&lt;Type&gt;
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    BaseTransCtx *alloc(const Type type)
    {
      return NULL;
    }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
</code></pre>

<p>  但是这样就不行了</p>

<pre><code>class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    template&lt;typename Type&gt;
      virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
class TransSessionMgr: public ISessionCtxFactory
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    template&lt;typename Type&gt;
      BaseTransCtx *alloc(const Type type)
      {
        return NULL;
      }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[澄清几个关于C++继承的问题]]></title>
    <link href="http://cxh.me/2014/10/28/cpp-derive-problems/"/>
    <updated>2014-10-28T15:56:00+08:00</updated>
    <id>http://cxh.me/2014/10/28/cpp-derive-problems</id>
    <content type="html"><![CDATA[<p>  之前讨论编码规范的时候遇到过一个问题，继承的类覆盖基类的虚函数，不写virtual关键字是否依然有覆盖（override)的效果。是个基础问题，但是大家的理解好像都不一样。验证如下：</p>

<pre><code>#include &lt;stdio.h&gt;
class Base
{
  public:
    Base (){}
    virtual ~Base (){}
    virtual void print() {printf("Base\n");}
};

class Middle : public Base
{
  public:
    Middle(){}
    virtual ~Middle(){}
    void print() {printf("Middle\n");}
};

class Derived : public Middle
{
  public:
    Derived(){}
    virtual ~Derived(){}
    void print() {printf("Derived\n");}
};

int main(int argc, const char *argv[])
{
  Base * p = NULL;
  Base b;
  Middle m;
  Derived d;
  p = &amp; b;
  p-&gt;print();
  p = &amp; m;
  p-&gt;print();
  p = &amp; d;
  p-&gt;print();
  return 0;
}
</code></pre>

<!--more-->


<p>  结果是</p>

<pre><code>Base
Middle
Derived
</code></pre>

<p>  可见只要定义了virtual关键字，在整个继承体系中这个函数都会成为虚函数。第二个问题是作为一个中间类（Middle)不想覆盖基类的虚函数，默认的情况下有什么影响。猜想应该就默认用了基类的虚函数。不影响后面的继承关系。注释掉Middle的print函数实现。结果如下：</p>

<pre><code>Base
Base
Derived
</code></pre>

<p>  跟预想一致。水文一篇，可忽略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[析构函数和成员析构的先后顺序]]></title>
    <link href="http://cxh.me/2014/10/22/destruct-and-member-destruct/"/>
    <updated>2014-10-22T17:57:00+08:00</updated>
    <id>http://cxh.me/2014/10/22/destruct-and-member-destruct</id>
    <content type="html"><![CDATA[<p>  肖总问到这个问题，写了个程序验证：</p>

<pre><code>class Member
{
 public:
   Member (){}
   virtual ~Member (){printf("member destruct\n");}
};
class Base
{
  public:
    Base (){}
    virtual ~Base (){ printf("destruct\n");}
  private:
    Member member_;
};
int main(int argc, const char *argv[])
{
  Base c;
  return 0;
}
</code></pre>

<p>  结果是：</p>

<pre><code>  destruct
  member destruct
</code></pre>

<p>  可见析构的时候先调用析构函数，最后析构成员对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统/NOSQL入门书单]]></title>
    <link href="http://cxh.me/2014/10/20/distribute-system-guide/"/>
    <updated>2014-10-20T11:26:00+08:00</updated>
    <id>http://cxh.me/2014/10/20/distribute-system-guide</id>
    <content type="html"><![CDATA[<p>  简单记一下我看过的和觉得值得看的。主要是给@赵龙作为参考。</p>

<ul>
<li>分布式相关</li>
</ul>


<blockquote><p>[1] 大规模分布式存储系统, <a href="http://book.douban.com/subject/25723658/">http://book.douban.com/subject/25723658/</a>
  阿里日照的书，全面介绍了分布式系统的原理和实践，入门不可多得的书</p>

<p>[2] 分布式系统原理介绍, <a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=31413">http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=31413</a>
  百度刘杰的，讲基本的分布式原理，有些笔误什么的。</p>

<p>[3] paxos算法相关, <a href="http://cxh.me/2014/08/26/paxos-study/">http://cxh.me/2014/08/26/paxos-study/</a>
  总结了paxos算法一些资料。</p>

<p>[5] 分布式数据库系统原理, <a href="http://product.dangdang.com/23466507.html">http://product.dangdang.com/23466507.html</a>
  分布式数据库的一本教材。</p>

<p>[6] The Raft Consensus Algorithm, <a href="http://raftconsensus.github.io/">http://raftconsensus.github.io/</a>
  raft相关的资料，论文和一些实现都能在里面找到，另外有一个图形化的展示很方便。</p>

<p>[7] Raft介绍, <a href="http://www.slideboom.com/presentations/956855/Raft%E4%BB%8B%E7%BB%8D">http://www.slideboom.com/presentations/956855/Raft%E4%BB%8B%E7%BB%8D</a>
  raft的一个ppt。</p></blockquote>

<ul>
<li>数据库相关</li>
</ul>


<blockquote><p>[1] 数据库系统实现, <a href="http://item.jd.com/10060181.html">http://item.jd.com/10060181.html</a>
  数据库的一本教材，偏重于实现。</p>

<p>[2] 数据挖掘概念与技术, <a href="http://book.douban.com/subject/2038599/">http://book.douban.com/subject/2038599/</a>>[3] 事务相关, <a href="http://cxh.me/2014/07/02/article-on-transaction/">http://cxh.me/2014/07/02/article-on-transaction/</a></p>

<p>[3] 事务相关, <a href="http://cxh.me/2014/07/02/article-on-transaction/">http://cxh.me/2014/07/02/article-on-transaction/</a>
  总结了事务相关的一些资料。</p></blockquote>

<ul>
<li>NOSQL相关</li>
</ul>


<blockquote><p>[1] Dynamo论文, <a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a></p>

<p>[2] bigtable论文, <a href="http://research.google.com/archive/bigtable-osdi06.pdf">http://research.google.com/archive/bigtable-osdi06.pdf</a></p>

<p>[3] gfs论文, <a href="http://research.google.com/archive/gfs-sosp2003.pdf">http://research.google.com/archive/gfs-sosp2003.pdf</a></p>

<p>[4] map reduce论文, <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf">http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf</a></p>

<p>[5] Redis 设计与实现, <a href="http://redisbook.com/en/latest/">http://redisbook.com/en/latest/</a>
  一本不错的讲redis的书。</p>

<p>[6] 数据分析与处理之二（Leveldb 实现原理）, <a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html</a>
  leveldb的实现。</p>

<p>[7] Memcached 源码剖析笔记, <a href="http://files.cppblog.com/xguru/Memcached.pdf">http://files.cppblog.com/xguru/Memcached.pdf</a>
  memcache的源码。</p></blockquote>

<ul>
<li>基础</li>
</ul>


<blockquote><p>[1] UNIX环境高级编程, <a href="http://book.douban.com/subject/1788421/">http://book.douban.com/subject/1788421/</a></p>

<p>[2] UNIX网络编程, <a href="http://book.douban.com/subject/1500149/">http://book.douban.com/subject/1500149/</a></p></blockquote>

<ul>
<li>一些博客</li>
</ul>


<blockquote><p>[1] 银河里的星星的博客, <a href="http://duanple.blog.163.com/">http://duanple.blog.163.com/</a>
  主要是分布式领域的论文和翻译。</p>

<p>[2] 章炎的技术博客, <a href="http://dirlt.com/">http://dirlt.com/</a></p>

<p>[3] 何登成的技术博客, <a href="http://hedengcheng.com/">http://hedengcheng.com/</a> 大牛不解释</p>

<p>[4] 淘宝核心系统团队博客, <a href="http://csrd.aliapp.com/">http://csrd.aliapp.com/</a></p>

<p>[5] 吴镝 <a href="http://www.cnblogs.com/foxmailed/">http://www.cnblogs.com/foxmailed/</a> 专注系统，基础架构，分布式系统</p></blockquote>

<p>  都看还是需要时间的，我只是读完了一部分翻完了一部分，很多还需要再看一遍。分布式系统最好的学习方法当时是实现一个分布式系统，像晓楚<a href="https://github.com/raywill/macraykv" title="Macrakv">macrakv</a>这样，但是工程量和难度比较大，退而求其次的办法是看源码，redis/hbase/leveldb/memcached都是不错的例子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动生成ifdef标记和作者信息的插件]]></title>
    <link href="http://cxh.me/2014/10/11/ifdef-generator/"/>
    <updated>2014-10-11T14:28:00+08:00</updated>
    <id>http://cxh.me/2014/10/11/ifdef-generator</id>
    <content type="html"><![CDATA[<p>  针对团队开发为了统一代码风格往往有比较严格的代码规范。为了自动化的生成一些不变的内容，写了如下两个插件（有的是改动）：</p>

<blockquote><ol>
<li>ifdef.vim 生成ifndef标记，防止重复包含。</li>
<li>author_info.vim 生成更新作者信息版权声明</li>
</ol>
</blockquote>

<p>  详见<a href="https://github.com/chenxiaohui/ifdef_generator">https://github.com/chenxiaohui/ifdef_generator</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夜景几张]]></title>
    <link href="http://cxh.me/2014/09/08/ffc-pictures/"/>
    <updated>2014-09-08T21:25:00+08:00</updated>
    <id>http://cxh.me/2014/09/08/ffc-pictures</id>
    <content type="html"><![CDATA[<p>  实在是镜头决定了成败，套头拍月亮基本是对不上焦的节奏，只能拍拍旁边的楼了。财富金融中心，应该是北京最高的写字楼了。貌似有跑焦。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/ffc_dark.jpg" title="FFC" alt="FFC"><p class="align-center">FFC</p></p>

<!--more-->


<p>  再贴一张曝光长一点的。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/ffc_light.jpg" title="FFC" alt="FFC"><p class="align-center">FFC</p></p>

<p>  以及裤衩沐浴在月光中的&hellip;</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/moon.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[永不分开，世界的爱]]></title>
    <link href="http://cxh.me/2014/09/08/the-love-of-the-world/"/>
    <updated>2014-09-08T20:03:00+08:00</updated>
    <id>http://cxh.me/2014/09/08/the-love-of-the-world</id>
    <content type="html"><![CDATA[<p>  这应该算是很古老很古老的一首歌了，当时赵薇还是个青涩的小燕子。2000年的时候还在上初中，实在不理解新千年的意义。现在回想起来，新千年的到来，对人类来说，实在是个有着难以名状的意义。20世纪前半叶的多灾多难，后半叶的冷战阴云，没有哪个世纪会产生如此重大的人类群体性灾难。旧的秩序被打破，核战争的阴云，武器发展到批量化的收割人命，20世纪可能是人类历史上绝无仅有一个世纪。</p>

<p>  从这个角度想，这首歌真是充满了感慨。停留在20世纪的末尾，回首这一个多灾多难的世纪，看人类从错误中反省，最终一起站在新千年的入口展望未来。某种意义上说，人类第一次站在一起迎接和平，憧憬未来。这其中的意味可能只有经历过苦难的人才体会的出来，虽然2000年的时候局部战争依然在进行着。</p>

<p>  一首歌的意味只有联想到背景才体会得到啊，不知道有多少人还记得这首歌了。不妨回味。</p>

<p>  <embed src="http://player.yinyuetai.com/video/player/438643/v_0.swf" quality="high" width="480" height="334" align="middle"  allowScriptAccess="sameDomain" allowfullscreen="true" type="application/x-shockwave-flash"></embed></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用google来验证一下Maclaurin展开式]]></title>
    <link href="http://cxh.me/2014/09/07/using-google-verify-maclaurin-series/"/>
    <updated>2014-09-07T15:35:00+08:00</updated>
    <id>http://cxh.me/2014/09/07/using-google-verify-maclaurin-series</id>
    <content type="html"><![CDATA[<p>  偶然发现google可以直接画出函数图像来，精准度极高，于是想起来用这个功能来看一下Maclaurin展开是如何随精度增加而逼近展开式的。从某种角度上讲，这是一个极好的拟合过程，相对于梯度下降的逐步拟合来讲，泰勒公式或者麦克劳林展开直接推导出了每一个拟合因子。</p>

<p>  泰勒级数的定义如下：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/taylor.png" title="Taylor公式" alt="Taylor公式"><p class="align-center">Taylor公式</p></p>

<p>  不过这是带拉格朗日余项的形式。让基准值=0可以得到 Maclaurin 展开式，当然这也就意味着Maclaurin展开式在0附近的拟合是最精确的。定义如下：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/Maclaurin.png" title="Maclaurin展开式" alt="Maclaurin展开式"><p class="align-center">Maclaurin展开式</p></p>

<!--more-->


<p>  几个重要的Maclaurin展开如下：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/sinx.png">
  <img class="center" src="http://cxh.me/images/2014/cosx.png" title="几个重要的Maclaurin展开" alt="几个重要的Maclaurin展开"><p class="align-center">几个重要的Maclaurin展开</p></p>

<p>  这里我们验证一下sinx的逼近随着级数的增加而增加的情况。这也对应于拟合过程拟合维度的增加，相对于一元的拟合，二元或者多元就是会精确一些，但是会带来过拟合的风险。</p>

<p>  首先是sinx的图像</p>

<p>  <img class="center" src="http://cxh.me/images/2014/sin_x.png"></p>

<p>  一元函数拟合的时候，y=x</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_1.png"></p>

<p>  二元拟合的时候，y=x-x<sup>3</sup>/3!</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_2.png"></p>

<p>  三元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_3.png"></p>

<p>  四元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!-x<sup>7</sup>/7!</p>

<p>  <img class="center" src="http://cxh.me/images/2014/x_4.png"></p>

<p>  合并起来的图像大致如此：</p>

<p>  <img class="center" src="http://cxh.me/images/2014/combine.png"></p>

<p>  再高阶的图像就不画了，上面基本保证了坐标系缩放比例是一致的(sinx的图像由于y轴比例没有跟其他的x轴保持一样的缩放比例），可以看到随着拟合维度的升高，拟合曲线越来越逼近sinx，这也直观体现了Maclaurin展开式的意义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《改善C++程序的150个建议》勘误]]></title>
    <link href="http://cxh.me/2014/09/06/error-in-cpp-150-notes/"/>
    <updated>2014-09-06T11:41:00+08:00</updated>
    <id>http://cxh.me/2014/09/06/error-in-cpp-150-notes</id>
    <content type="html"><![CDATA[<p>  翻了一下编写高质量代码：改善C++程序的150个建议，感觉一般，主要是能下到pdf。看到两个错误。</p>

<p>  第一个错误是内存池的那里，内部类使用了外部类的成员变量，这是C++啊，不是java，内部类默认不持有外部类指针。</p>

<pre><code>class MemPool
{
  public:
    MemPool (int nItemSize, int nMemBlockSize = 2048):
      m_nItemSize(nItemSize),
      m_nMemBlockSize(nMemBlockSize),
      m_pMemBlockHeader(NULL),
      m_pFreeNodeHeader(NULL)
    {}
    virtual ~MemPool (){}
    void * Alloc();
    void Free();
  private:
    /* data */
    const int m_nMemBlockSize;
    const int m_nItemSize;
    struct _FreeNode
    {
      _FreeNode* pPrev;
      char data[m_nItemSize - sizeof(_FreeNode*)];
    };
    struct _MemBlock
    {
      _MemBlock * pPrev;
      _FreeNode data[m_nMemBlockSize/m_nItemSize];
    };
    _MemBlock* m_pMemBlockHeader;
    _FreeNode* m_pFreeNodeHeader;
};
</code></pre>

<p>  第二个错误是作者强调nocopyable基类是需要私有继承的，其实不需要，public继承足够了，public继承又不会把基类的private成员继承下来。</p>

<pre><code>class nocopyable
{
  public:
    nocopyable (){}
    virtual ~nocopyable (){}

  private:
    /* data */
    nocopyable (const nocopyable&amp;);
    nocopyable&amp; operator=(const nocopyable&amp;);
};
class Base : public nocopyable
</code></pre>

<p>  太tm不严谨了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paxos算法学习]]></title>
    <link href="http://cxh.me/2014/08/26/paxos-study/"/>
    <updated>2014-08-26T20:53:00+08:00</updated>
    <id>http://cxh.me/2014/08/26/paxos-study</id>
    <content type="html"><![CDATA[<p>  本来想写点东西，后来觉得都是一知半解。这里转载一点学习资料吧。</p>

<p>  一个是知行学社的分布式系统与Paxos算法视频课程，循序渐进，讲解地比较浅显易懂。</p>

<p>  <embed src="http://www.tudou.com/v/e8zM8dAL6hM/&bid=05&rpid=51943457&resourceId=51943457_05_05_99/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"></embed></p>

<p>  另一个是百度刘杰<a href="http://www.valleytalk.org/2012/07/12/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%8B-%E3%80%82%E7%99%BE%E5%BA%A6-%E3%80%82%E5%88%98%E6%9D%B0/" title="《分布式系统原理介绍》">《分布式系统原理介绍》</a>。当然Lamport的几篇论文是不能不看的，虽然都不太好懂。</p>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" title="The Part-Time Parliament">The Part-Time Parliament</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" title="paxos made simple">Paxos Made Simple</a></li>
<li><a href="https://www.andrew.cmu.edu/course/15-749/READINGS/required/resilience/lamport82.pdf" title="The Byzantine Generals Problem">The Byzantine Generals Problem</a></li>
</ul>


<p>  相比较而言，<a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)" title="Paxos (computer science)">paxos的wiki</a>可能更好懂一些。有余力的同学可以做一下<a href="http://css.csail.mit.edu/6.824/2014/" title="MIT Distributed Systems Labs">MIT Distributed Systems Labs</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++的限制拷贝]]></title>
    <link href="http://cxh.me/2014/08/24/no-copy-restrict/"/>
    <updated>2014-08-24T12:44:00+08:00</updated>
    <id>http://cxh.me/2014/08/24/no-copy-restrict</id>
    <content type="html"><![CDATA[<p>  如果需要禁止一个类的拷贝（多鉴于RAII的资源类），按习惯我们会把拷贝构造函数和赋值运算符重载设置为私有的。比如：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base (){}

  private:
    Base(const Base&amp; b)
    Base &amp; operator=(const Base&amp; b)
};

int main(int argc, const char *argv[])
{
  Base b(1);//ok
  Base c=1;//error[1]
  Base d=c;//error
  c = d;//error
  return 0;
}
</code></pre>

<p>  但是问题在于[1]这里没有道理被屏蔽掉，应该会被优化成Base c(1)。如下代码可以证明：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base ()
    {
    }
    Base(const Base&amp; b)
    {
      cout&lt;&lt;"copy consturct" &lt;&lt;endl;
    }
};

int main(int argc, const char *argv[])
{
  Base c=1;
  return 0;
}
</code></pre>

<p>  运行结果：</p>

<pre><code>construct
</code></pre>

<p>  后来我试了一下才发现，首先这个优化是编译器层面的，所以不同的编译器处理应该是不一样的，虽然我们见到的编译器应该都支持。其次这个优化不是语法检查前做的，也就意味着，在<strong>构造函数没有被声明为explicit的时候</strong>，语法检查会把这个认为是先做了类型转换，然后调用拷贝构造函数，也就是如下：</p>

<pre><code>Base c = Base(1);
</code></pre>

<p>  这就在编译的时候报错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[暴力街区13]]></title>
    <link href="http://cxh.me/2014/08/17/brick-mansions/"/>
    <updated>2014-08-17T20:39:00+08:00</updated>
    <id>http://cxh.me/2014/08/17/brick-mansions</id>
    <content type="html"><![CDATA[<p>   <img class="img-polaroid center" src="http://cxh.me/images/2014/brick_mansions.jpg"></p>

<p>   虽说是翻拍，但是也不能一模一样啊，这剧情的相似度不是一般的高啊&hellip;.</p>

<p>   而且第二部的时候我就不理解，如果要引爆一个炸弹，直接倒计时爆炸就行了，干嘛要派一个人进去再输入一个引爆密码？剧情可从来没说炸弹送进去的时候就知道会被发射回来。</p>

<p>   还有，不要黑我大底特律&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[沉默地与这个世界对抗]]></title>
    <link href="http://cxh.me/2014/07/26/against-the-world-in-silence/"/>
    <updated>2014-07-26T18:59:00+08:00</updated>
    <id>http://cxh.me/2014/07/26/against-the-world-in-silence</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="http://cxh.me/images/2014/road.jpg"></p>

<p>  去看了《后会无期》。是我心里的样子。</p>

<p>  踏上旅途，遇到形形色色的人，停留而又离开，坚持或者放弃，很真实，不是么？都说小孩才看对错，成年人只看利弊，其实成年人也不是只看利弊，但是成年人的世界的确不能只用对错衡量了。</p>

<p>  When I was a little boy，当我还是一个小男孩的时候，我想，这个世界该是什么样子的呢？是西游记那样，哆啦a梦那样，还是圣斗士星矢那样呢？后来才发现，都不是。当我们经历了一些事情，我们知道了付出并不一定有回报，正义并不一定能战胜邪恶，甚至大部分情况下看，邪恶总比正义强大一点的时候，是否还相信对错呢？不知道。</p>

<p>  电影其实一直在问这个问题，当你还在东极岛的时候，对错是直接的，是非是明确的，每个人活的像胡生一样简单。但是家乡不在了，你被迫上路，被骗，被偷，看到大部分人活的不如意，小部分人似乎如意，内心里承受坚持与放弃的碰撞，最后连胡生也丢了。老师讲的那些东西已经不足以解释这些问题，但是内心里又有一个声音告诉你不能沉沦。生活不就是这样么。</p>

<p>  我们中大部分人是不会很成功，也不会很顺利的。所以这是个十分现实的问题，如果几十年后再问我们这些人的当初的理想，那么情况应该惨烈过台风后的海南。所以理想破灭似乎是跟更年期一样普遍的问题，以至于我们要考虑考虑如何平静度过这段时间。对中国人这样一个没有信仰的民族，我觉得这尤其重要了。</p>

<p>  那么问题就在于，现实如此，该去向哪里。步入这个年纪，已经不会有人指导你该做什么，也明白了抱怨其实没什么用。平凡是常态，希望仍渺茫，青春已逝，认输之前。</p>

<p>  但是理想还在路上，只不过孤独前行着罢了。人生总有那么几年，甚至几十年是默默无闻的。有一个意义支撑着，是很好的事情。淡出焦点之外，才是行路的最好状态。迷失了，就找另外的路，跌倒了，就爬起来继续沉默前行。理想破灭，就沉默着与这个世界对抗。纵使没有改变什么，至少给自己一个意义，让所有的前行都变得值得。</p>

<blockquote><ul>
<li>我曾经毁了我的一切 只想永远地离开</li>
<li>我曾经堕入无边黑暗 想挣扎无法自拔</li>
<li>我曾经象你象他象那野草野花</li>
<li>绝望着 渴望着 哭着笑着平凡着</li>
</ul>
</blockquote>

<p>  于是你可以说，嗯，是我心里的样子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[平凡之路]]></title>
    <link href="http://cxh.me/2014/07/20/normal-roads/"/>
    <updated>2014-07-20T10:06:00+08:00</updated>
    <id>http://cxh.me/2014/07/20/normal-roads</id>
    <content type="html"><![CDATA[<p>  朴树的《后会无期》主题曲：平凡之路</p>

<p><embed src="http://player.youku.com/player.php/sid/XNzQxMjU2ODI0/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<ul>
<li>我曾经跨过山和大海</li>
<li>也穿过人山人海</li>
<li>我曾经拥有着一切</li>
<li>转眼都飘散如烟</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[后会无期]]></title>
    <link href="http://cxh.me/2014/07/19/continent/"/>
    <updated>2014-07-19T14:34:00+08:00</updated>
    <id>http://cxh.me/2014/07/19/continent</id>
    <content type="html"><![CDATA[<p><embed src="http://player.video.qiyi.com/df60feaccd8d18df45ae5f84d10fd39e/0/0/w_19rsfwiyk1.swf-albumId=2338708509-tvId=2338708509-isPurchase=0-cnId=5" allowFullScreen="true" quality="high" width="480" height="350" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<ul>
<li>当一艘船沉入海底</li>
<li>当一个人成了谜</li>
<li>你不知道</li>
<li>他们为何离去</li>
<li>那声再见竟是他最后的一句</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c/c++的不定参数]]></title>
    <link href="http://cxh.me/2014/07/17/c-variable-argument/"/>
    <updated>2014-07-17T14:42:00+08:00</updated>
    <id>http://cxh.me/2014/07/17/c-variable-argument</id>
    <content type="html"><![CDATA[<p>  c/c++可以通过va_arg等宏实现不定参数。一个例子如下(c++)：</p>

<pre><code>void ar_cnt(int cnt,...);
int main(int argc, char* argv[])
{
    ar_cnt(4,1,2,3,4);
    return 0; 
}
void ar_cnt(int cnt,...)
{
    int arg_cnt = cnt;
    va_list arg_ptr;
    va_start(arg_ptr, cnt);
    for(int i=0; i &lt; cnt;i++)
    {
        int value=va_arg(arg_ptr,int);
        printf("posation %d=%d\n", value, i+1);
    }
    va_end(arg_ptr);
}
</code></pre>

<p>  其实原理是比较简单的，依赖于编译器对函数调用的压栈顺序，但是目测现有的调用方式压栈都是从右向左，所以va_start定位第一个参数的位置，va_arg每次在之前的位置上加一个偏移值，从而得到每个传入参数。这就是说va_start要求传入不定参数的函数不能只传入一个&hellip;，至少要有一个固定的参数，用来获取栈指针位置。</p>

<!--more-->


<p>  调用方式这个东西好像只有在VC里才探讨，不太清楚gcc这里的处理是怎么样的，vc下主要分了如下几种：</p>

<ul>
<li><p>STDCALL/PASCAL/WINAPI/CALLBACK</p>

<ol>
<li>参数从右向左压入堆栈</li>
<li>函数自身修改堆栈</li>
<li>函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li>
</ol>
</li>
<li><p>CDECL</p>

<ol>
<li>调用约定的参数压栈顺序是和stdcall是一样的，参数由右向左压入堆栈。</li>
<li>调用者负责清理堆栈。</li>
<li>由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。</li>
</ol>
</li>
<li><p>FASTCALL</p>

<ol>
<li>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</li>
<li>被调用函数清理堆栈</li>
<li>函数名修改规则同stdcall</li>
</ol>
</li>
<li><p>THISCALL</p>

<ol>
<li>参数从右向左入栈</li>
<li>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li>
</ol>
</li>
<li><p>NAKEDCALL</p>

<ol>
<li>这是一个很少见的调用约定，一般程序设计者建议不要使用。</li>
<li>编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果</li>
<li>这一般用于实模式驱动程序设计</li>
</ol>
</li>
</ul>


<h3>参考文献:</h3>

<blockquote><p>[1] cdecl、stdcall、fastcall函数调用约定区别 , <a href="http://blog.csdn.net/fly2k5/article/details/544112">http://blog.csdn.net/fly2k5/article/details/544112</a></p>

<p>[2] 函数调用的区别：<em>cdecl以及</em>stdcall, <a href="http://www.cppblog.com/kenny/archive/2011/04/19/144539.html">http://www.cppblog.com/kenny/archive/2011/04/19/144539.html</a></p>

<p>[3] 透析C语言可变参数问题, <a href="http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html">http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java/c++变量作用域的一点小区别]]></title>
    <link href="http://cxh.me/2014/07/17/java-c-plus-plus-variable-scope-diff/"/>
    <updated>2014-07-17T11:16:00+08:00</updated>
    <id>http://cxh.me/2014/07/17/java-c-plus-plus-variable-scope-diff</id>
    <content type="html"><![CDATA[<p>  偶然遇到一个问题，java里面这么写是有问题的</p>

<pre><code>int x = 1;
    {
        int x = 2;
    }
</code></pre>

<p>  作为一个写了多年C++的人，不能忍啊。java子域里的变量看样子不会覆盖父域。但是这样是没问题的，可见子域的生命周期还是局限于子域里面。</p>

<pre><code>    {
        int x = 2;
    }
int x = 1;
</code></pre>

<p>  C++里面这样是没问题的</p>

<pre><code>  int x = 1 ;
  {
    int x  = 2;
  }
</code></pre>

<p>  相对于脚本语言，这种限制似乎就宽多了。这样都可以。</p>

<pre><code>for i in range(1,10):
    pass
print i
</code></pre>
]]></content>
  </entry>
  
</feed>
