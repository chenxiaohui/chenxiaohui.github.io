<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-01-30T16:22:13+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://cxh.me/2015/01/29/java-compare-strategy/"/>
    <updated>2015-01-29T20:42:00+08:00</updated>
    <id>http://cxh.me/2015/01/29/java-compare-strategy</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eclipse多命令行窗口]]></title>
    <link href="http://cxh.me/2015/01/29/eclipse-multi-console/"/>
    <updated>2015-01-29T20:41:00+08:00</updated>
    <id>http://cxh.me/2015/01/29/eclipse-multi-console</id>
    <content type="html"><![CDATA[<p>   有时候需要在eclipse中同时运行客户端程序和服务器程序，开始都是一个在eclipse里面运行，另一个在命令行单独启动，未免不方便。后来发现，其实可以直接在eclipse中运行两次。调试视图会有两个显示，同时新建一个console窗口，关联另一个实例的显示就可以同时监视两个程序的输出了。</p>

<p>   <img class="img-polaroid center" src="http://cxh.me/images/2015/eclipse_instance.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协变返回类型]]></title>
    <link href="http://cxh.me/2015/01/27/convariant-return-type/"/>
    <updated>2015-01-27T15:48:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/convariant-return-type</id>
    <content type="html"><![CDATA[<p>  协变返回类型（Convariant Return Type）是指override的函数，返回值有继承关系（子类函数返回类型是父类返回类型的子类）。例子如下：</p>

<!--more-->


<pre><code>class Base
{
  public:
    Base (){}
    virtual void print(){
      printf("Base");
    }
};

class Derived : public Base
{
  public:
    Derived(){}
    virtual ~Derived (){}
    void print(){
      printf("Derived");
    }
};

class TestBase
{
  public:
    TestBase (){}
    virtual Base* getObject(){
      return new Base();
    }
};

class TestDerived : public TestBase
{
  public:
    TestDerived (){}
    virtual ~TestDerived (){}
    Derived* getObject(){
      printf("invoke here\n");
      return new Derived;
    }
};

int main(int argc, const char *argv[])
{
  TestBase * base = new TestDerived();
  Base* b = base-&gt;getObject();
  b-&gt;print();
  return 0;
}

结果：
invoke here
Derived
</code></pre>

<p>  java同理，只不过验证起来比较容易。直接打印对象就行。</p>

<pre><code>public class BaseClass {
}
public class DerivedClass extends BaseClass{
}

public class TestBase {
    public BaseClass getObject(){
        return new BaseClass();
    }
}

public class TestDerived extends TestBase{
    public DerivedClass getObject(){
        return new DerivedClass();
    }
    public static void main(String[] args) {
        TestBase base = new TestDerived();
        System.out.println(base.getObject());
    }
}

返回值：
test.server.others.DerivedClass@5d1eb50b
</code></pre>

<p>  这里想验证的其实是返回引用是可以的。返回对象是不行的。java只有返回引用，所以都可以。可自行验证。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java和C++继承上的一点不同]]></title>
    <link href="http://cxh.me/2015/01/27/java-cpp-derive-difference/"/>
    <updated>2015-01-27T14:51:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/java-cpp-derive-difference</id>
    <content type="html"><![CDATA[<p>   之前没注意过这里：</p>

<p>   java继承的时候只会隐藏父类同名同类型的函数。C++直接隐藏了同名的所有函数，如下：</p>

<pre><code>public class BaseClass {
    public void Print(String str){
        System.out.println("String" + str);
    }
    public void Print(int num){
        System.out.println(num);
    }
}
public class TestDerived extends BaseClass {
    public void Print(String str) {
        System.out.println("String" + str);
    }
    public static void main(String[] args) {
        new TestDerived().Print(121);
    }
}
</code></pre>

<p>  输出结果是121</p>

<p>  而同样的实现C++中直接会找不到父类的函数。</p>

<!--more-->


<pre><code>#include &lt;stdio.h&gt;
class Base
{
  public:
    Base (){}
    void Print(const char* str);
    void Print(int num);
};
void Base::Print(const char* str)
{
  printf(str);
}
void Base::Print(int num)
{
  printf("%d", num);
}

class Derived : public Base
{
  public:
    Derived(){}
    void Print(const char* str);
};
void Derived::Print(const char* str)
{
  printf("%s", str);
}

int main(int argc, const char *argv[])
{
  Derived d;
  d.Print(11);
  return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用shadow socks翻墙]]></title>
    <link href="http://cxh.me/2015/01/26/shadow-socks-proxy/"/>
    <updated>2015-01-26T15:39:00+08:00</updated>
    <id>http://cxh.me/2015/01/26/shadow-socks-proxy</id>
    <content type="html"><![CDATA[<p>  shadowsocks作为一个开源软件提供了可靠的翻墙途径，而最近红杏各种不稳定，digital ocean的相应太慢，于是考虑买shadowsocks的账号。</p>

<p>  <a href="https://portal.shadowsocks.com/aff.php?aff=483" title="shadow socks">这里</a>购买服务，一年99，这个优惠码可以再打一点折<code>imouto985</code>。之后进入后台可以看到分配给自己的密码，服务器主要是日本，美国和新加坡的，实测貌似日本的响应更快一点。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/shadow_mac.png"></p>

<p>  mac下下载了客户端直接打开配置好地址就能用，linux下需要自己配置代理。</p>

<p>  首先下载安装node.js</p>

<pre><code>wget http://nodejs.org/dist/v0.10.35/node-v0.10.35.tar.gz
tar zxvf node-v0.10.35.tar.gz 
cd node-v0.10.35
./configure &amp;&amp; make 
sudo make install
</code></pre>

<p>  然后安装npm和shadowsocks</p>

<pre><code>sudo apt-get install npm
sudo apt-get install shadowsocks
</code></pre>

<p>  apt-get安装的nodejs好像有问题，所以用源码安装。编辑配置文件，默认是<code>/usr/local/lib/node_modules/shadowsocks/config.json</code>，启动之后就可以连上服务器了。</p>

<p>  之后需要配置proxy。以chrome为例，如果之前配置过goagent的话，基本配置一样。不过proxy switch sharp终于升级到了proxy switch omega了。需要注意的是shadowsocks是socks代理，选择的时候不要选择http。gfwlist 可用如下：</p>

<pre><code>https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt
</code></pre>

<p>  之后就可以翻墙了。最后说一句：<strong>Fxxk GFW，祝病魔早日战胜方校长，所有参与GFW的人都将钉在历史的耻辱柱上</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java中重用对象的bug]]></title>
    <link href="http://cxh.me/2015/01/23/java-reuse-bug/"/>
    <updated>2015-01-23T11:15:00+08:00</updated>
    <id>http://cxh.me/2015/01/23/java-reuse-bug</id>
    <content type="html"><![CDATA[<p>  首先这不是java编译器的问题，就是写代码的时候大意了。</p>

<p>  有这样一个函数</p>

<pre><code>int parse(String msg, Message out)；
</code></pre>

<p>  解析一个String，返回一个结构体。这么做的目的主要是避开try catch的性能问题，通过返回码来处理异常。这里就很容易出现这样的用法了：</p>

<pre><code>Message msg = new Message();
for (xxxx){
    if (0 == parse(str, msg))

}
</code></pre>

<p>  当时觉得还挺好，复用了一个对象。实际明显有问题的，这个对象的生命周期不见得只在for循环内部，一旦引用被传递出去，就会有悬挂（java里是不是不这么叫）的问题。多个引用指向了一个对象，计算结果是不可预测的。</p>

<p>  主要问题是java里面默认都是传引用的，所以要时刻保持对gc机制的警惕。或者直接实现clone接口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash下模拟group by功能]]></title>
    <link href="http://cxh.me/2015/01/22/simulate-group-by-in-bash/"/>
    <updated>2015-01-22T15:56:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/simulate-group-by-in-bash</id>
    <content type="html"><![CDATA[<p>  遇到这样一个问题：有一堆数据，需要统计相同key下相同的column的重复出现次数，实际上就是数据库里面的group by功能，但是建表导入然后计算未免麻烦，何况数据是临时数据，导入计算完毕之后就不需要了。这里用shell下的一些命令来完成。</p>

<p>  数据格式</p>

<pre><code>user            tag_id  type        time
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    EXPOSURE    2015:13:37:16
</code></pre>

<p>  目的：</p>

<pre><code>统计同一个用户下，同一个tag的点击次数：
</code></pre>

<p>  实现如下：</p>

<ol>
<li><p> 排序</p>

<p>首先对数据进行排序。这是最基本的，见<a href="http://cxh.me/2015/01/22/sort-using-multiple-columns/" title="Sort多列排序">上篇文章</a>。</p>

<pre><code>sort -k 1 
</code></pre></li>
<li><p> 过滤不需要的行和列。</p>

<pre><code>awk '{print $1, $2, $3}' |grep "Click" 
</code></pre></li>
<li><p> 这时候出现了一些重复列了，这也就是我们要做group by的数据。</p>

<pre><code>uniq -c | awk {'print $2, $3, $1'} 
</code></pre></li>
</ol>


<p>  后面awk只是调了一下位置。合并起来就是：</p>

<pre><code>sort -k 1  test.txt|awk '{print $1, $2, $3}' |grep "Click"|uniq -c | awk {'print $2, $3, $1'} 
</code></pre>

<p>  输出结果：</p>

<pre><code>AAAAAAAAAAA tag1 2
AAAAAAAAAAA tag2 1
BBBBBBBBBBB tag2 2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sort多列排序]]></title>
    <link href="http://cxh.me/2015/01/22/sort-using-multiple-columns/"/>
    <updated>2015-01-22T13:38:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/sort-using-multiple-columns</id>
    <content type="html"><![CDATA[<p>  遇到这样一个需求，希望按照第二列排序，第二列相同的情况下按照第一列排序，数据如下：</p>

<pre><code>b   2   c
c   2   b
a   1   b
</code></pre>

<p>  习惯性的用:</p>

<pre><code>sort -k 2 -k 1 input.txt
</code></pre>

<p>  输出结果是：</p>

<pre><code>a   1   b
c   2   b
b   2   c
</code></pre>

<p>  可以看到实际上先按照第二列排序，第二列相同按照第三列排序了。问题在于sort -k默认是按照顺序排序到末尾的。如果要打破默认，需要指定从哪个列到哪个列。</p>

<pre><code>sort -k 2，2 -k 1 input.txt
</code></pre>

<p>  换个角度说，<code>sort -k 1 -k 2</code> 的效果跟 <code>sort -k 1</code> 是一样的。所以最好还是让数据按照排序列生成，这样看起来也最直观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Django下获取checkbox的返回值]]></title>
    <link href="http://cxh.me/2015/01/19/django-checkbox/"/>
    <updated>2015-01-19T16:46:00+08:00</updated>
    <id>http://cxh.me/2015/01/19/django-checkbox</id>
    <content type="html"><![CDATA[<p>  HTML中我们可以在form中这样写复选框：</p>

<pre><code>&lt;form action="demo_form.asp"&gt;
  &lt;input type="checkbox" name="vehicle" value="Bike"&gt; I have a bike&lt;br&gt;
  &lt;input type="checkbox" name="vehicle" value="Car" checked&gt; I have a car&lt;br&gt;
  &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;
</code></pre>

<p>  但是作为服务端处理起来未免不变，尤其是checkbox list是自动生成的时候。此时可以用group方式把form value组合起来。如下：</p>

<pre><code>{\% for item in items \%}
    &lt;td&gt;&lt;input type="checkbox" name="selected_push[]" value=""&gt;&lt;/td&gt;
{\% endfor \%}
</code></pre>

<p>  服务端从命令行可以看到收到的post里面是有&#8217;selected_push[]&lsquo;变量的。但是直接get的结果只有一个。查阅stackoverflow发现RequestContext有单独的getlist函数来处理。果然还是跟PHP不一样啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python编码]]></title>
    <link href="http://cxh.me/2015/01/19/python-encoding/"/>
    <updated>2015-01-19T14:34:00+08:00</updated>
    <id>http://cxh.me/2015/01/19/python-encoding</id>
    <content type="html"><![CDATA[<p>  众所周知Python的内码编码是Unicode，所有输入的编码都需要转换成unicode然后转出成为其他编码。Python2中存在unicode对象和str对象两种，在中文处理的时候很容易出问题，而Python3直接全部统一了编码到unicode。</p>

<p>  举一个例子说明编码的转换，首先我们的环境是utf-8</p>

<pre><code>LANG=zh_CN.UTF-8
LANGUAGE=zh_CN:zh
LC_CTYPE="zh_CN.UTF-8"
LC_NUMERIC="zh_CN.UTF-8"
LC_TIME="zh_CN.UTF-8"
LC_COLLATE="zh_CN.UTF-8"
LC_MONETARY="zh_CN.UTF-8"
LC_MESSAGES="zh_CN.UTF-8"
LC_PAPER="zh_CN.UTF-8"
LC_NAME="zh_CN.UTF-8"
LC_ADDRESS="zh_CN.UTF-8"
LC_TELEPHONE="zh_CN.UTF-8"
LC_MEASUREMENT="zh_CN.UTF-8"
LC_IDENTIFICATION="zh_CN.UTF-8"
LC_ALL=zh_CN.UTF-8
</code></pre>

<p>  然后测试一个从环境的输入和写回到环境。</p>

<pre><code>文件编码gbk:
print '中文'
print u'中文'
输出
    ����
    中文

文件编码utf-8
print '中文'
print u'中文'

输出
    中文
    中文
</code></pre>

<p>  说明print输出的时候按照default encoding进行了编码。所以只有gbk的编码乱码了。同样对输入的判断，环境如果是utf8，输出不变的话，不会有乱码。但是如果从文件里读取了字符串或者代码里有硬编码字符，就需要考虑编码了。另外，unicode和str相加会有编码问题。比如：</p>

<pre><code>文件编码gbk:    
value = raw_input()
print value + "中文"
输入
    中文
输出
    中文����

value = raw_input()
print value + u"中文"
输入
    en
输出
    en中文
输入
    中文
输出
    UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)
</code></pre>

<p>  str+str输出肯定是str，所以需要适配环境的编码，第一个乱码可以理解。而str+unicode的时候，str会被按default encoding解码。utf8无法按照python default encoding ascii解码。utf8文件编码下的情况类似。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[保存知乎日报到pocket]]></title>
    <link href="http://cxh.me/2015/01/18/send-zhihu-to-pocket/"/>
    <updated>2015-01-18T15:30:00+08:00</updated>
    <id>http://cxh.me/2015/01/18/send-zhihu-to-pocket</id>
    <content type="html"><![CDATA[<p>  知乎日报是中国人民喜闻乐见的资讯类应用，Pocket是深受世界人民喜爱的阅读工具。鉴于反碎片化阅读的个人习惯，决定把散落在各个地方的有价值咨询集中到一个应用里面，于是有了如下的工具。</p>

<p>  首先我们要parse知乎日报的URL。按照官方的说法每天三次投放，那抓一次就行了。直接用了<a href="http://coolshell.cn/articles/9104.htm" title="sed 简明教程">sed工具</a>。</p>

<pre><code>curl -s http://daily.zhihu.com | sed 's/&lt;a href="\(http:\/\/daily.zhihu.com\/story[^"]*\)"/\n\1\n/g' |grep 'http://daily.zhihu.com/story'
</code></pre>

<!--more-->


<p>  然后需要打通跟Pocket的渠道。首先去注册Pocket SDK <a href="http://getpocket.com/developer/">http://getpocket.com/developer/</a></p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/pocket.png"></p>

<p>  将会得到如下的几个授权码。我只注册了Web和Desktop</p>

<pre><code>NAME    PLATFORM    CONSUMER KEY
ZhihuDaily2Pocket   Web xxxx-xxxxxxxxxxxxxxxxxxxx
ZhihuDaily2Pocket   Desktop (other) xxxx-xxxxxxxxxxxxxxxxxxxx
</code></pre>

<p>  之后先请求pocket的consumer key：</p>

<pre><code>curl -s -X POST  -H "X-Accept: Application/json" -H "Content-Type: application/json"  -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxxx","redirect_uri":"http://google.com"}'  https://getpocket.com/v3/oauth/request | grep '}' | python -mjson.tool
</code></pre>

<p>  这里需要注意Accept头部使用的是X-Accept，这是我之前死活得不到相应的原因。</p>

<p>  返回结果类似于：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/x-www-form-urlencoded
Status: 200 OK

code=dcba4321-dcba-4321-dcba-4321dc
</code></pre>

<p>  如果是web应用，这里可以把用户导向一个授权页面了。</p>

<pre><code>https://getpocket.com/auth/authorize?request_token=dcba4321-dcba-4321-dcba-4321dc&amp;redirect_uri=http://google.com
</code></pre>

<p>  授权后，我们把code和consumerkey转换成access token：</p>

<pre><code>curl -s http://getpocket.com/v3/oauth/authorize -X POST -H "Content-Type: application/json" -H "X-Accept: application/json" -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxxx","code":"dcba4321-dcba-4321-dcba-4321dc"}'
</code></pre>

<p>  得到类似如下的结果：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/x-www-form-urlencoded
Status: 200 OK

access_token=5678defg-5678-defg-5678-defg56&amp;
username=pocketuser
</code></pre>

<p>  根据这个access_token可以添加新的url了。</p>

<pre><code>curl -s http://getpocket.com/v3/add -X POST -H "Content-Type: application/json" -H "X-Accept: application/json" -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxxx", "access_token":"yyyy-yyyy-yyyy-yyyy-yyyy","url":"http://daily.zhihu.com/story/4437286"}'
</code></pre>

<p>  之前授权流程完成之后，作为某个特定用户，之后的请求指令就不会变话了。所以程序可以简化到如下：</p>

<pre><code>curl -s http://daily.zhihu.com | sed 's/&lt;a href="\(http:\/\/daily.zhihu.com\/story[^"]*\)"/\n\1\n/g' |grep 'http://daily.zhihu.com/story' |
while read line
do
    curl -s http://getpocket.com/v3/add -X POST -H "Content-Type: application/json" -H "X-Accept: application/json" -d '{"consumer_key":"xxxx-xxxxxxxxxxxxxxxxxxx", "access_token":"yyyy-yyyy-yyyy-yyyy-yyyy","url":"'$line'"}'|python -mjson.tool| grep 'resolved_url'
done 
</code></pre>

<p>  添加个定时任务到cron中就行了。</p>

<p>  <strong>当然最后我发现IFTTT是个更简单的方案&hellip;..</strong></p>

<h3>参考文献:</h3>

<blockquote><p>[1] sed 简明教程, <a href="http://coolshell.cn/articles/9104.htm">http://coolshell.cn/articles/9104.htm</a></p>

<p>[2] Pocket API Documentation, <a href="http://getpocket.com/developer/docs">http://getpocket.com/developer/docs</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转载：生活不是眼前的苟且，生活有诗和远方——高晓松]]></title>
    <link href="http://cxh.me/2015/01/17/life-has-peom-and-distance/"/>
    <updated>2015-01-17T18:41:00+08:00</updated>
    <id>http://cxh.me/2015/01/17/life-has-peom-and-distance</id>
    <content type="html"><![CDATA[<p>  “我妈说生活不是眼前的苟且，生活有诗和远方。我 和我妹妹深受这教育。谁要觉得你眼前这点儿苟且就是你的人生，那你这一生就完了。生活就是适合远方，能走多远走多远；走不远，一分钱没有，那么就读诗，诗 就是你坐在这，它就是远方。”</p>

<p>  关于房子，我跟大多数人概念不一样。我从小住在清华校园里，家是那种二层的小楼，外表看起来很普通，面积也不是特大，但是特别安静。</p>

<p>  这地儿都没动过，也没装修之说，从我生下来就是这样红色的，很老很旧。但我在那儿真觉得挺好，有一个家，但我在那儿真觉得挺好，有一个家，不仅仅是睡觉的 地方，我自己也不知道这房子多少年了，我们也在感慨：后边的院子多好啊，出门就是操场、游泳馆，还有漂亮的女生，白发的先生；四周的邻居，随便踹开一家的 门，里面住的都是中国顶级的大知识分子，进去聊会儿天怎么都长知识，梁思成林徽因就住我前面的院子。小时候有什么问题家里老人就写一张字条，说这问题你问 谁谁谁。我找到人家家里，打开字条一看，哦，你是那谁家的孩子，那你讲吧，都是中国头把交椅啊。这才是住处真正的意义吧，它让你透气，而不是豪华的景观、 户型和装修什么的。</p>

<!--more-->


<p>  2007年， 我们搬了出来，因为家人都在国外，我又不在清华教书，学校就把房子收回去了，后来我去了洛杉矶。</p>

<p>  去了美国，我一样是无房户，坚定的无房主义者。刚去美国的时候，我做编剧和开发，只卖出了两首电影歌曲。美国流行音乐是草根文化，美国卖吉他的黑人当我师 傅都有富余，不是说他弹得比我好，是同样一个琴我们弹的都不是一个级别，出的声音都不一样。国外很多伟大的乐队，都是一个班的同学，在中国整个高校也选拔 不出一个牛的乐队。为啥？国内很多年轻人的热情都分散了，赚钱的热情大过音乐本身，比如买房。</p>

<p>  郑钧有一天跟我说，有些艺术家被抓进精神病院，成了精神病；有些精神病人从精神病院逃出来，成为艺术家，你就是那后者，你的生活就像行为艺术。不过，我肯 定不属于时尚人士，因为从来不关注别人的流行趋势，也算不上中产阶级，如果我的钱只够旅行或是买房子，那我就去旅行。</p>

<p>  平时除了听听歌，看看电影，我最大的爱好就是满世界跑着玩。大概去过三十多个国家了，到一个地方就买一辆车，然后玩一段时间就把车卖了，再去下一个地方。</p>

<p>  经常在旅途中碰上一堆人，然后很快成为朋友，然后喝酒，然后下了火车各自离去。之前还在欧洲碰见一个东欧乐队，我帮人弹琴，后来还跟人卖艺去了，跟着人到 处跑到处弹唱，到荷兰，到西班牙，到丹麦……我妈也是，一个人背包走遍世界，我妈现在还在流浪，在考察美国天主教遗址。</p>

<p>  我妹也是，也没有买房，她挣的钱比我多得多。之前她骑摩托横穿非洲，摩托车在沙漠小村里坏了，她索性就在那里生活两个月等着零件寄到。然后在撒哈拉沙漠一 小村子里给我写一个明信片，叫做“彩虹之上”，她在明信片里告诉我说，哥，我骑了一个宝马摩托，好开心。我看到沙漠深处的血色残阳，与酋长族人喝酒，他们 的笑容晃眼睛……因为我跟我妹都不买房，你知道你只要不买房，你想开什么车开什么车。你想，你一个厕所的面积就恨不得能买一奔驰。然后她就开一宝马摩托， 坏了，说整个非洲都没这零件，她说你知道我现在在做什么吗？我在撒哈拉一个小村子里给人当导游。</p>

<p>  我妈从小就教育我们，不要被一些所谓的财产困住。所以我跟我妹走遍世界，然后我俩都不买房，就觉得很幸福。我妈说生活不是眼前的苟且，生活有诗和远方。我 和我妹妹深受这教育。谁要觉得你眼前这点儿苟且就是你的人生，那你这一生就完了。生活就是适合远方，能走多远走多远；走不远，一分钱没有，那么就读诗，诗 就是你坐在这，它就是远方。越是年长，越能体会我妈的话。</p>

<p>  美国人平均31岁才第一次购房，德国人42岁，比利时人37岁，欧洲拥有独立住房的人口占50%，剩下都是租房。为什么现在中国的年轻人一毕业就结婚？一 结婚就买房？怎样才能买到房？一套房子会限制你所有的行为和决定。因为你知道，要一提裸婚，没有人愿意嫁给你。即使老婆愿意，他们家人呢？别人会怎么看？ 孩子以后怎么办？以今天的房价，普通人买房只有两种情况，一种是双方父母出钱资助，这种人基本上前途和发展被父母控股。第二种人是牺牲了太多的发展机会， 典当梦想来成就一套房子。他们购买的，其实是自己内心深处的“安全感”。他们觉得，有一套房子，会让自己内心安全一点儿。但是安全感真的可以来自于一套房 子吗？归根结底，还是价值观的问题。世界再怎么变，还是要有坚持，即使它是落后。我不入流，这不要紧。我每一天开心，这才是重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理Django的自增字段]]></title>
    <link href="http://cxh.me/2015/01/15/django-assign-autoincrement-field/"/>
    <updated>2015-01-15T22:00:00+08:00</updated>
    <id>http://cxh.me/2015/01/15/django-assign-autoincrement-field</id>
    <content type="html"><![CDATA[<p>  有时候需要手动构造一个Django model对象并保存，遇到如下的情况：</p>

<pre><code>model定义如下：
class AuthHistory(models.Model):
user_name = models.CharField(max_length=100, default=None)
item_id = models.CharField(max_length=100)
datetime = models.DateTimeField()
url = models.CharField(max_length=1000)
title = models.CharField(max_length=1000)
operation = models.CharField(max_length=100, default=None)

构造对象如下：
history = AuthHistory("cxh", tid, datetime.datetime.now(), item['url'], item['title'], operation)
</code></pre>

<p>  报错:<code>django title invalid literal for int() with base 10:cxh</code>，明显是把第一个字段赋给自增长id了，因为Django会给没有主键的表直接加上id字段作为主键。</p>

<p>  手动指定域当然是可以的：</p>

<pre><code>history = AuthHistory( user_name="cxh", item_id=tid, datetime=datetime.datetime.now(), url=item['url'], title=item['title'], operation=operation)
</code></pre>

<p>  但是未免很麻烦。传值肯定不合理，毕竟id是数据库记录的。试了一下，给id域直接传NULL就行了。</p>

<pre><code>history = AuthHistory(None, "cxh", tid, datetime.datetime.now(), item['url'], item['title'], operation)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用maven执行java程序]]></title>
    <link href="http://cxh.me/2015/01/15/maven-execute-java-program/"/>
    <updated>2015-01-15T17:08:00+08:00</updated>
    <id>http://cxh.me/2015/01/15/maven-execute-java-program</id>
    <content type="html"><![CDATA[<p>  Eclipse中需要执行一个java程序的之后只需要在入口类Run就行，但是有时候需要同时开两个程序，尤其对C/S模式的应用来说。针对这种情况，可以分如下三种方式启动另一个程序：</p>

<ol>
<li><p> java -cp 指定的类。shell（或者ZSH才有）下貌似是会有提示如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/javacp.png"></p>

<p>以上方式至少需要保证用到的jar都在classpath中。</p></li>
<li><p> 从eclipse中copy执行命令。去调试页面，查看刚才执行的command的属性页面。会看到如下界面，copy命令到shell中执行即可。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/eclipse_command.png"></p></li>
<li><p> maven execute。 命令类似：</p>

<pre><code>mvn exec:java -Dexec.mainClass=boot.BootStrap
</code></pre>

<p>注意是第二个exec后是点，不是：，另外如果有多模块，在root project下需要加module:</p>

<pre><code>mvn exec:java -pl xxx -Dexec.mainClass=boot.BootStrap 
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django自定义Filter]]></title>
    <link href="http://cxh.me/2015/01/14/django-custom-filter/"/>
    <updated>2015-01-14T13:29:00+08:00</updated>
    <id>http://cxh.me/2015/01/14/django-custom-filter</id>
    <content type="html"><![CDATA[<p>  遇到这样一个问题：Django中有字段是根据位来存储信息的，并且不是对应Model数据库中的字段，BitField使用起来比较不太适合。这样就得在模板中根据位来显示不同的内容。查Django并试验，好像位操作不能直接写在if操作符中，同时django也不支持在模板直接调用函数。一个合理的选择是建立自定义的Filter。详见<a href="https://docs.djangoproject.com/en/1.7/howto/custom-template-tags/" title="Custom template tags and filters">参考文献</a>。基本代码如下：</p>

<pre><code>配置：
mSohuConf={
    "A_mask" : 0x04,
    "B_mask" : 0x02,
    "C_mask" : 0x01,
}

Filter代码：
from django import template
from django.utils.safestring import mark_safe
from .. import config
register = template.Library()
mask_html = (
    (config.mSohuConf['A_mask'], '&lt;span class="label label-danger"&gt;A&lt;/span&gt;'),
    (config.mSohuConf['B_mask'], '&lt;span class="label label-warning"&gt;B&lt;/span&gt;'),
    (config.mSohuConf['C_mask'], '&lt;span class="label label-info"&gt;C&lt;/span&gt;'),
)
default_html = '&lt;span class="label label-default"&gt;D&lt;/span&gt;'
@register.filter()
def news_tag(value):
    output = default_html
    for mask, html in mask_html:
        if value &amp; mask:
            output += html +'\n'
    return mark_safe(output)

模板：
{\% load news_tag \%}
&lt;td&gt;&lt;/td&gt;
</code></pre>

<!--more-->


<p>  需要注意的有：</p>

<ol>
<li> mark_safe是必须的，否则会被自动escape。</li>
<li> 使用的时候需要load。写的时候需要register声明或者手动声明。</li>
<li> 文档说必须重启才能使用新的标签。目测不用。</li>
</ol>


<p>  多参数的列子如下：</p>

<pre><code>@register.filter()
def news_op(status, id):
    if status &amp; config.mSohuConf['A_mask']:
        output = '&lt;a href="http://cxh.me/xxx/%d/%d/" title="xxx"&gt;xxx&lt;/a&gt;'%(news_id, status)
    else:
        output = '&lt;a href="http://cxh.me/xxx/%d/%d/" title="xxx"&gt;xxx&lt;/a&gt;'%(news_id, status)
    return mark_safe(output)

模板：
</code></pre>

<p>   毕竟还是不太方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的征途]]></title>
    <link href="http://cxh.me/2015/01/12/new-startup/"/>
    <updated>2015-01-12T23:17:00+08:00</updated>
    <id>http://cxh.me/2015/01/12/new-startup</id>
    <content type="html"><![CDATA[<p>  晚上去看了《一代宗师》3D。3D效果比较一般，基本是字幕3D。但是感觉依然是王家卫那种感觉。故事讲的更清楚了，但是也就少了很多想象的空间。</p>

<p>  突然觉得嘉华还不错，会员生日可以免费观影一场，还有爆米花套餐。最近心情抑郁，突然收到这个gift，觉得幸福感好高。就像昨天收到快递里面有个卖家送的幸运豆就高兴了好久。不是低潮的时候往往忽视这些细小的幸福。</p>

<p>  最近总在回想人生走过的路，觉得多走了好多弯路。说人生无悔，都是赌气的话。人生若是真的无悔，那该多无趣啊。宫二的这句话，确实勾起了很多感触。27岁的生日，新的开始。全新的自己，打点行装，坚定的走下去。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/yidaizongshi.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的治牙经历]]></title>
    <link href="http://cxh.me/2015/01/12/perience-of-curing-my-teeth/"/>
    <updated>2015-01-12T17:02:00+08:00</updated>
    <id>http://cxh.me/2015/01/12/perience-of-curing-my-teeth</id>
    <content type="html"><![CDATA[<p>  2015.1.12，生日，去做了第一轮刮治的第一次治疗。痛不欲生啊。</p>

<p>  11月的时候查出来牙周有问题，其实很早就觉得不好了，洗牙之前没去看。洗牙的时候拍了牙片，槽骨吸收的很厉害了。中间又拖了两个月，一个是忙，一个是没挂上号，终于上周去北大口腔挂了号。医生说很严重，侵袭性牙周炎，牙周袋太深，可能还是得手术。</p>

<p>  今天第一次刮治。感慨牙这个东西，不意识到的时候不会觉得他的重要，上周探完牙周袋深度就疼了一个周，这次更是痛不欲生的感觉，打了麻药还是这样。而且奇怪的是手刮并不怎么疼，疼的还是超声洗牙石的部分。唯一的安慰是大夫态度都不错。牙科的大夫mm居多，虽然带着口罩都看不清楚长相&hellip;</p>

<p>  以前还是不重视啊。家庭上也整体不重视。中国还是有很多落后的地方，理念上这么多年都没有更新过来。联想到公务员热和中国父母普遍的求稳定，觉得理念真是落后太多了。至于过年各种嘘寒问暖的亲戚&hellip;哎，你们没有隐私这个观念么&hellip;还好我家人父母不太执着这些事情，就是说说算了&hellip;或者我压根没当真过..</p>

<p>  总的来说。长大了，要慢慢消除家庭的影响。有独立的思考了，就要慢慢消除教育的影响。离开了熟悉的环境，就要慢慢消除文化的影响。保持一个open的心态，不断质疑以前形成的思维定势，才能走出去，走的远。</p>

<hr />

<p>  此贴持续更新，毕竟还有四到五轮的刮治，每轮又要分多次，之后如果做牙周手术，又有得受了。立贴为记录吧。</p>

<p>  今天才注意到北大口腔的字还是老江题的。联想到今天疼爽了的经历，真是excited啊</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/excited.png"></p>

<hr />

<p>  第二次刮治，右上右下。倒是比第一次疼痛减轻多了，不过上次刮治之后都是臼齿吃饭，这下吃饭比较成问题。另外麻药的持久感好强，感觉右半边脸好像不存在一样。</p>

<p>  下周继续。第一轮三次完成。大夫比较辛苦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[致我的生日]]></title>
    <link href="http://cxh.me/2015/01/12/to-my-birthday/"/>
    <updated>2015-01-12T00:11:00+08:00</updated>
    <id>http://cxh.me/2015/01/12/to-my-birthday</id>
    <content type="html"><![CDATA[<p>  要27了。</p>

<p>  突然有很多感慨，自从不怎写字之后也不怎么愿意表达了。习惯了工作占据大部分时间。好在工作也不见得完全是工作，还是有兴趣的成分在里面，重合度就看心情了。但是工作多了就有种麻木的感觉，觉得似乎不是我想要的人生。</p>

<p>  时代发展好快。这似乎已经不是个小资的时代。从学生时代走过来，毕业的热闹一过去，感觉立马进入了快车道。这一年马不停蹄，一身风尘一身疲惫。去阿里就不是什么明智的选择，当时可能是头脑一热吧，也可能是觉得很不屑研究生跟着导师做的东西，非要找一个技术上（看起来）高深莫测的地方。一年下来觉得开始是有兴趣，后来感觉是个挑战，最后感觉就是负担的。跳槽之后心境平和多了，现在至少已经不恨或者不黑什么了，这点还是挺感激张老板和我们组的。人嘛，到了奔三的年纪，还是要客观一些。</p>

<p>  最近过得有些抑郁。以前无论什么事情都没觉得怎么样，牙这个事情真是无力吐槽。明天去定治疗方案。所以牙好的亲们，这是一笔财富啊，想吃点好的就吃吧，不要在乎钱。</p>

<p>  晚上在搜狐的楼上，看着夕阳晚霞雾霾，觉得真是感慨。从毕业过来快十年了，似乎有所收获，又似乎一事无成。被卷在时代的洪流里面，想抓住什么又没有方向。不过也正常。鸡汤的东西读多了，就不容易被忽悠了，这个时代哪有那么多高大上的故事，每一点成长都是在无比纠结里面过来的。</p>

<p>  不过好在还年轻，心态还年轻。慢慢终于可以把自己放到一个独立的位置上，觉得如此就自由了很多。想走什么路，不用在瞻前顾后。总想着回来，就走不远哪。</p>

<p>  好没有逻辑。</p>

<p>  不过也不需要逻辑了。该治牙治牙，该工作工作，该生活生活。本来就没有什么逻辑。趁年轻，想做什么就去做。</p>

<p>  嗯。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redhat下升级python]]></title>
    <link href="http://cxh.me/2015/01/11/redhat-upgrade-python/"/>
    <updated>2015-01-11T18:56:00+08:00</updated>
    <id>http://cxh.me/2015/01/11/redhat-upgrade-python</id>
    <content type="html"><![CDATA[<p>  偶然发现服务器上的python是2.4的，好多语法都不支持。遂决定升级。</p>

<p>  首先yum升级是可以升级到2.6的：</p>

<pre><code>yum install python26
yum install python26-devel
yum install python26-setuptools
ln -s /usr/bin/python2.6 /usr/bin/python
</code></pre>

<p>  升级之后发现yum不能用了。yum应该是跟python版本绑定了，于是把yum头部改成：</p>

<pre><code>#!/bin/python2.4
</code></pre>

<p>  之后发现2.6还是不行&hellip;我是用了多新的语法啊&hellip;就是几个dict comprehension。于是决定升级到2.7。源里面没有，只能手动。</p>

<pre><code>#wget http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2  
#tar -jxvf Python-2.7.3.tar.bz2
#cd Python-2.7.3  
#./configure  
#make all             
#make install
#ln -s /usr/local/bin/python2.7 /usr/bin/python  
</code></pre>

<p>  安装setup-tools</p>

<pre><code>wget https://pypi.python.org/packages/source/s/setuptools/setuptools-11.3.1.zip --no-check-certificate
unzip setuptools-11.3.1.zip
cd setuptools-11.3.1
python setup.py install
</code></pre>

<p>  yum不用动了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过搭建代理来共享网络]]></title>
    <link href="http://cxh.me/2015/01/11/linux-proxy-setup/"/>
    <updated>2015-01-11T17:16:00+08:00</updated>
    <id>http://cxh.me/2015/01/11/linux-proxy-setup</id>
    <content type="html"><![CDATA[<p>   遇到这样一个问题，开发机只有一台能上外网，其他的机器上手动更新依赖包简直是要死的感觉。尝试了如下几种方式：</p>

<ol>
<li>. vpn

<ol>
<li><a href="http://5323197.blog.51cto.com/5313197/1285738" title=" centos6.4 安装配置 pptp vpn">pptp</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-setup-and-configure-an-openvpn-server-on-centos-6" title="How to Setup and Configure an OpenVPN Server on CentOS 6 | DigitalOcean">openvpn</a></li>
</ol>
</li>
<li>. ssh反向代理（其实不是干这个事情的貌似）</li>
<li>. proxy</li>
</ol>


<p>   开始一直不想用proxy，毕竟需要为yum什么的单独配置，不是所有的程序都会去读shell的http_proxy配置。但是vpn配置搞了一天都不成功。openvpn能连接，但是不能共享网络，大概是路由配错了，pptp linux下直接链接不上，可能是只用了chap的握手？反正没成功。最后还是配了proxy，配完才觉得proxy简单易行啊，大部分问题能解决，出现了特别的需求就单独为其设置代理好了。问题不大。</p>

<p>   tinyproxy的配置如下：</p>

<pre><code>yum install tinyproxy

# vi /etc/tinyproxy/tinyproxy.conf
Allow 192.168.1.0/24 # 限制可以使用Proxy的来源网段

service tinyproxy start

shell配置：
export http_proxy='xxx:8888'
export https_proxy='xxx:8888'

yum配置：
vi /etc/yum.conf
  proxy=http://xxxx:8888
ConnectPort 443     
</code></pre>

<p>  配置难度真不是一个数量级的，可见有时候能满足大部分情况，就是最好的解决方案了。</p>

<p>  <strong>补充：easy_install和pip是默认读取http_proxy的，但是一直不能连接。尝试了很久之后发现是sudo的问题，sudo环境没有执行.bashrc，所以root的http_proxy和当前用户的http_proxy都没有生效。su到root下就可以了。</strong></p>
]]></content>
  </entry>
  
</feed>
