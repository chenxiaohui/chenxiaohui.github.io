<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-12-27T19:52:01+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[libev源码分析]]></title>
    <link href="http://cxh.me/2015/12/19/libev-source-analysis/"/>
    <updated>2015-12-19T16:29:00+08:00</updated>
    <id>http://cxh.me/2015/12/19/libev-source-analysis</id>
    <content type="html"><![CDATA[<p>  本文源码以libev4.20为准，其他版本大同小异。</p>

<p>  libev是广泛使用的事件库，是一个功能强大的reactor，可以把Timer、IO、进程线程事件放在一个统一的框架下进行管理。如果有其他的事件触发需求也可以改libev源码把该事件加入libev的框架中（当前前提是得理解libev的设计）。有文章说libev性能比libevent好，没实验过，但是从源码角度看，libev要更简洁，当然更费解一点。作者为了追求代码的整洁和统一使用了大量的宏，造成了阅读的不便。这里我们从宏观分析一下libev的设计实现，然后穿插分析一些小的trick。旨在学习总结libev设计中优雅的地方。</p>

<h2>基本概念</h2>

<p>  首先是一些主要的概念和数据结构。</p>

<p>  libev通过定义watcher来关注一个事件，并且把事件类型和对应的毁回调函数关联起来。libev定义了多种事件类型，同时可以在框架中自己添加感兴趣的事件，libev保证了事件触发的顺序性，并在多线程环境下保证事件的串行触发。</p>

<p>  每一种类型的watcher都包含几个基本的成员，通过EV_WATCHER和EV_WATCHER_LIST宏实现。EV_WATCHER_LIST比EV_WATCHER多了一个纸箱下一个watcher的指针。EV_WATCHER_TIMER是定时器的基类，多一个timestamp。这几个宏这里留一个小的trick分析，在后面阐述。</p>

<pre><code>/* shared by all watchers */
#define EV_WATCHER(type)            \
  int active; /* private */         \
  int pending; /* private */            \
  EV_DECL_PRIORITY /* private */        \
  EV_COMMON /* rw */                \
  EV_CB_DECLARE (type) /* private */

#define EV_WATCHER_LIST(type)           \
  EV_WATCHER (type)             \
  struct ev_watcher_list *next; /* private */

#define EV_WATCHER_TIME(type)           \
  EV_WATCHER (type)             \
  ev_tstamp at;     /* private */
</code></pre>

<p>   举一个例子，IO事件watcher：ev_io</p>

<pre><code>/* invoked when fd is either EV_READable or EV_WRITEable */
/* revent EV_READ, EV_WRITE */
typedef struct ev_io
{
  EV_WATCHER_LIST (ev_io)

  int fd;     /* ro */
  int events; /* ro */
} ev_io;
</code></pre>

<p>  可以看到ev_io相当于继承了基类ev_watcher_list，并派生出自己的成员，fd和events，分别用来存储文件描述符和事件标识。类似的watcher有：</p>

<ol>
<li> 基类ev_watcher，ev_watcher_list, ev_watcher_time.</li>
<li> io：ev_io</li>
<li> 周期触发定时器：ev_periodic</li>
<li> 定时器：ev_timer</li>
<li> 信号：ev_signal</li>
<li> 子进程：ev_child</li>
<li> 文件stat：ev_stat</li>
<li> 一些内部流程watcher：ev_idle，ev_prepare，ev_check， ev_fork, ev_cleanup</li>
<li> 异步触发：ev_async</li>
</ol>


<h2>使用流程</h2>

<p>  libev库的基本使用流程是：</p>

<ol>
<li> 生成一个循环(loop)对象，单线程情况下直接使用default_loop，多线程的情况下使用ev_loop_new来创建。</li>
<li> 调用ev_xx_init先注册一个感兴趣的watcher。把这个watcher跟事件、回调关联起来。</li>
<li> 调用ev_xx_start把事件添加到loop的待处理（后述）列表中。</li>
<li> 调用ev_run执行循环。</li>
</ol>


<p>  一个简单的使用例程如下（来自官方sample，可见官方风格是大括号换行的&hellip;.鄙视）：</p>

<pre><code>// a single header file is required
#include &lt;ev.h&gt;

#include &lt;stdio.h&gt; // for puts

// every watcher type has its own typedef'd struct
// with the name ev_TYPE
ev_io stdin_watcher;
ev_timer timeout_watcher;

// all watcher callbacks have a similar signature
// this callback is called when data is readable on stdin
static void
stdin_cb (EV_P_ ev_io *w, int revents)
{
  puts ("stdin ready");
  // for one-shot events, one must manually stop the watcher
  // with its corresponding stop function.
  ev_io_stop (EV_A_ w);

  // this causes all nested ev_run's to stop iterating
  ev_break (EV_A_ EVBREAK_ALL);
}

// another callback, this time for a time-out
static void
timeout_cb (EV_P_ ev_timer *w, int revents)
{
  puts ("timeout");
  // this causes the innermost ev_run to stop iterating
  ev_break (EV_A_ EVBREAK_ONE);
}

int
main (void)
{
  // use the default event loop unless you have special needs
  struct ev_loop *loop = EV_DEFAULT;

  // initialise an io watcher, then start it
  // this one will watch for stdin to become readable
  ev_io_init (&amp;stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
  ev_io_start (loop, &amp;stdin_watcher);

  // initialise a timer watcher, then start it
  // simple non-repeating 5.5 second timeout
  ev_timer_init (&amp;timeout_watcher, timeout_cb, 5.5, 0.);
  ev_timer_start (loop, &amp;timeout_watcher);

  // now wait for events to arrive
  ev_run (loop, 0);

  // break was called, so exit
  return 0;
}
</code></pre>

<h2>实现分析：</h2>

<p>  下面我们针对上述程序分析一下libev的实现。</p>

<p>  首先直接采用了default_loop，这里没有使用多线程支持。如果需要开启的话，记得define一下EV_MULTIPLICITY，源码中有大量的对EV_MULTIPLICITY的判断，如果define了则增加一个loop入参来指定运行的线程，否则就直接用默认的。源码实现如下（这里只给出了ev_loop定义）：</p>

<pre><code>#if EV_MULTIPLICITY

  struct ev_loop
  {
    ev_tstamp ev_rt_now;
    #define ev_rt_now ((loop)-&gt;ev_rt_now)
    #define VAR(name,decl) decl;
      #include "ev_vars.h"
    #undef VAR
  };
  #include "ev_wrap.h"

  static struct ev_loop default_loop_struct;
  EV_API_DECL struct ev_loop *ev_default_loop_ptr = 0; /* needs to be initialised to make it a definition despite extern */

#else

  EV_API_DECL ev_tstamp ev_rt_now = 0; /* needs to be initialised to make it a definition despite extern */
  #define VAR(name,decl) static decl;
    #include "ev_vars.h"
  #undef VAR

  static int ev_default_loop_ptr;

#endif
</code></pre>

<p>  var这里留一个小trick分析，在后面来阐述。</p>

<p>  sample之后调用了两个init来关联事件、watcher和回调函数。对应的定义如下：</p>

<pre><code>/* these may evaluate ev multiple times, and the other arguments at most once */
/* either use ev_init + ev_TYPE_set, or the ev_TYPE_init macro, below, to first initialise a watcher */
#define ev_init(ev,cb_) do {            \
  ((ev_watcher *)(void *)(ev))-&gt;active  =   \
  ((ev_watcher *)(void *)(ev))-&gt;pending = 0;    \
  ev_set_priority ((ev), 0);            \
  ev_set_cb ((ev), cb_);            \
} while (0)

#define ev_io_set(ev,fd_,events_)            do { (ev)-&gt;fd = (fd_); (ev)-&gt;events = (events_) | EV__IOFDSET; } while (0)
#define ev_timer_set(ev,after_,repeat_)      do { ((ev_watcher_time *)(ev))-&gt;at = (after_); (ev)-&gt;repeat = (repeat_); } while (0)

#define ev_io_init(ev,cb,fd,events)          do { ev_init ((ev), (cb)); ev_io_set ((ev),(fd),(events)); } while (0)
#define ev_timer_init(ev,cb,after,repeat)    do { ev_init ((ev), (cb)); ev_timer_set ((ev),(after),(repeat)); } while (0)
</code></pre>

<p>  可以看到，每种类型的init都是定义了一些赋值操作，由于各种watcher都是从ev_watcher &ldquo;派生&rdquo; 而来的，所以可以用ev_watcher向上转换来访问公共成员。这里只是定义了对象，不涉及事件的注册等操作。</p>

<p>  之后sample通过调用xx_start把事件添加到了关注列表中。ev_io_start的源码如下：</p>

<pre><code>void noinline
ev_io_start (EV_P_ ev_io *w) EV_THROW
{
  int fd = w-&gt;fd;

  if (expect_false (ev_is_active (w)))//当前watcher是否已经active
    return;

  assert (("libev: ev_io_start called with negative fd", fd &gt;= 0));
  assert (("libev: ev_io_start called with illegal event mask", !(w-&gt;events &amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));

  EV_FREQUENT_CHECK;//周期性的检查

  ev_start (EV_A_ (W)w, 1);
  array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
  wlist_add (&amp;anfds[fd].head, (WL)w);//添加到watcher list

  /* common bug, apparently */
  assert (("libev: ev_io_start called with corrupted watcher", ((WL)w)-&gt;next != (WL)w));

  fd，change (EV_A_ fd, w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY);//加入事件变更
  w-&gt;events &amp;= ~EV__IOFDSET;

  EV_FREQUENT_CHECK;//周期检查
}
</code></pre>

<p>  代码主要的逻辑在三个地方，ev_start、wlist_add和fd_change。ev_start的比较简单，主要是标记了一下当前watcher已经actived，这是所有的xx_start函数都有的逻辑。</p>

<pre><code>  inline_speed void
ev_start (EV_P_ W w, int active)
{
  pri_adjust (EV_A_ w);
  w-&gt;active = active;
  ev_ref (EV_A);
}
</code></pre>

<p>  之后的部分每个不同的watcher实现不同。针对io_watcher，由于fd分配是连续的，所以这个长度可以进行大小限制的，我们用一个连续的数组来存储fd/watcher信息，如<a href="https://cnodejs.org/topic/4f16442ccae1f4aa270010a3" title="libev 设计分析">下图所示</a>，用anfd[fd] 就可以找到对应的fd/watcher信息，如果遇到anfd超出我们的buffer长度情形，可以动态扩容。这里直接用了文献2里面的图。</p>

<p>  <img class="img-polaroid center" src="http://static.data.taobaocdn.com/up/nodeclub/2011/09/seQHQpwHRHOicrTFuDaCs8w.png"></p>

<p>  wlist_add完成向anfd数组对应位置的链表增加事件的工作。更详细的过程可以参考文献2。</p>

<p>  最后fd_change完成增加事件变更的任务。libev会根据之前的wlist来判断一个事件是否需要调用对应的处理函数向系统添加监听，比如针对epoll，如果第一次在一个watcher(fd）上调用io_start，那么fdchanges数组中会增加一项，表明下个事件循环周期内需要调用epoll_ctl增加监听。如果之前已经有对应的事件监听存在，则判断是否要替换，不需要再调用epoll_ctl更改epoll的事件注册。源码如下：</p>

<pre><code>/* something about the given fd changed */
inline_size void
fd_change (EV_P_ int fd, int flags)
{
  unsigned char reify = anfds [fd].reify;
  anfds [fd].reify |= flags;

  if (expect_true (!reify))
    {
      ++fdchangecnt;
      array_needsize (int, fdchanges, fdchangemax, fdchangecnt, EMPTY2);
      fdchanges [fdchangecnt - 1] = fd;
    }
}
</code></pre>

<p>  到底位置libev只是完成了一些初始化操作，表明需要对什么事件进行什么处理，但事件流程并没有run起来，最后需要做的是调用ev_run来起线程，并进入事件循环。整个ev_run函数较长，大概有两百多行，这里就不列出代码了，只把程序的主要逻辑列出来。</p>

<pre><code>  int
ev_run (EV_P_ int flags)
{
  ...
  do
    {
      ...
      //如果这个进程是新fork出来的，执行ev_fork事件的回调
      ...
      //执行ev_prepare回调，也就是每次poll前执行的函数
      ...
      //执行监听有改变的事件
      ...
      //计算poll应该等待的时间,这个时间和设置以及定时器超时时间有关
      ...
      //调用后台I/O复用端口等待事件触发
      backend_poll (EV_A_ waittime);
      ...
      //将定时器事件放入pending数组中
      ...
      //将ev_check事件翻入pending数组中
      ...
      //执行pending数组中所有的回调
      EV_INVOKE_PENDING;
    }
  while (调用了stop);
}
</code></pre>

<p>  backend_poll封装了不同系统的多路复用机制，在不同的情况下会映射成不同的实现，如epoll、kequque等。对于epoll而言，在每次epoll_wait之前会执行fd_reify(loop)。 fd_reify中会遍历fdchanges数组，把对fd事件的修改通过调用epoll_modify来做真正的修改，这里才真正完成了事件监听向系统的注册。这里有个小的trick再后面分析。</p>

<p>  具体的代码中，程序使用queue_events将要运行的事件放入一个叫做pending的二维数组中，其第一维是优先级，第二维是动态分配的，存放具体事件。之后程序会在适当的地方调用宏EV_INVOKE_PENDING，将pending数组中的事件按优先级从高到低依次执行。</p>

<p>  基本流程图可以看这里，转自<a href="http://csrd.aliapp.com/?p=1604" title="libev ev_io源码分析">阿里核心系统团队博客</a>：</p>

<p>  <img class="img-polaroid center" src="http://csrd.aliapp.com/wp-content/plugins/libev_loop2.png"></p>

<p> ## 一些技巧</p>

<ol>
<li><p>首先是通过define来模拟了继承。libev用宏定义了ev_watcher等基类的成员，实现派生类的时候只需要先用宏把公共成员包含进来，然后定义各个子类自己的成员即可。这种技巧也广泛用在其他一些开源项目中。</p></li>
<li><p>通过重新define var关键字和重新包含vars头文件的方式，可以把一组变量变换成不同的形式：</p>

<p> #define VAR(name,decl) decl;
   #include &ldquo;ev_vars.h&rdquo;
 #undef VAR</p>

<p> #define VAR(name,decl) static decl;
   #include &ldquo;ev_vars.h&rdquo;
 #undef VAR</p></li>
</ol>


<p>  这个技巧也被用在s3_error.h里面，用来同时生成一个错误码的定义和其字符串描述。</p>

<ol>
<li>最后编译libev的时候会发现像epoll.c poll.c等平台相关的backend定义实际上没有加入Makefile。libev实现的时候其实直接在源码里面根据define来包含了c文件。大部分时候我们都是只include头文件，所以这里在使用的时候需要稍加注意。</li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] libev ev_io源码分析, <a href="http://csrd.aliapp.com/?p=1604">http://csrd.aliapp.com/?p=1604</a></p>

<p>[2] libev 设计分析, <a href="https://cnodejs.org/topic/4f16442ccae1f4aa270010a3">https://cnodejs.org/topic/4f16442ccae1f4aa270010a3</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh绑定其他端口]]></title>
    <link href="http://cxh.me/2015/11/01/ssh-bind-other-port/"/>
    <updated>2015-11-01T14:14:00+08:00</updated>
    <id>http://cxh.me/2015/11/01/ssh-bind-other-port</id>
    <content type="html"><![CDATA[<p>  首先修改/ssh/sshd_config，把Port 22解注释，然后加一行Port xx。之后修改 /etc/sysconfig/iptables，加入该端口的Rules:</p>

<pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport xx -j ACCEPT  
</code></pre>

<p>  重启即可。</p>

<pre><code>/etc/init.d/sshd restart
</code></pre>

<p>  这么做的目的是如果出现问题，还有一个端口可以上去修改。登录的时候需要对应的指定一下端口：</p>

<pre><code>ssh -p xx user@host
scp -P xx ... user@host
</code></pre>

<p>  补充两个SSH技巧：</p>

<ol>
<li><p> 客户端配置中转，主要是通过跳板机登录：</p>

<pre><code>Host xx
HostName 192.168.1.1
User xx
ProxyCommand ssh -q xxx@login2.xxx.xx nc %h %p
</code></pre></li>
<li><p> 保持会话。 ssh会在.ssh目录下生成一个会话选项，下次登录同一个server公用会话，不需要验证。</p>

<pre><code>Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
</code></pre>

<p>上面会话共享，所以不能关闭会话。可以通过 <code>ssh -fN xxx</code> 把第一个会话放到后台不退出</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RBTools兼容的问题]]></title>
    <link href="http://cxh.me/2015/08/31/rbtools-compatible-problems/"/>
    <updated>2015-08-31T15:26:00+08:00</updated>
    <id>http://cxh.me/2015/08/31/rbtools-compatible-problems</id>
    <content type="html"><![CDATA[<p>  某天ReviewBoard客户端突然用不了，使用    <code>rbt post</code>的时候报错:</p>

<pre><code>from six.moves.urllib.parse import quote
ImportError: No module named urllib.parse
</code></pre>

<p>  乍一看以为什么包被卸载了。于是pip install six &mdash;upgrade，无果。pip uninstall RBTools再重新安装RBTools，也无效。</p>

<p>  查了一下six是python2、python3的兼容包，直接修改源码，不要兼容了，发现用到的地方好多，改不过来（ps，兼容python2、python3真不容啊）。</p>

<p>  查看six的版本，发现跟本地一样的，本地没什么问题。说明不是six的问题。直接在命令行from six.moves.urllib.parse import quote，发现本地ok，服务器上不行。</p>

<p>  这就比较扯了，同样的版本，本地可以服务器不行。直接卸了重装：</p>

<pre><code>pip uninstall six #注，这里卸载了1.9的six
pip uninstall six #日，还有一个1.2的six，不知道pip list为啥显示不出来。
pip install six
easy_install RBTools
</code></pre>

<p>  然后就ok了。所以还是要习惯在virtualenv下搞啊&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[paxos的一些case分析]]></title>
    <link href="http://cxh.me/2015/08/28/paxos-case-analysis/"/>
    <updated>2015-08-28T11:34:00+08:00</updated>
    <id>http://cxh.me/2015/08/28/paxos-case-analysis</id>
    <content type="html"><![CDATA[<p>acceptor: a([epoc:4, value:n])  b[epoc:3,value:y]  c[epoc:6,:value:y]</p>

<p>proposor:  x5, x7,   (x4, x3, x6)</p>

<p>prepare:x5[a, b], x7[b, c]</p>

<p>commit:x[4,n] y[6, y]</p>

<p>一共有5个proposer,</p>

<p>1）初始时 x4 (prepare)&ndash;> a, x3 (prepare)&ndash;> b,x6 (prepare)&ndash;> c,
2） x4, x3, x6 挂掉
3）x5(prepare)&ndash;> a, b
4）x5(commit[epoc:4, value:n])&ndash;>a, b
5) x7(prepare) &ndash;>b, c
6) x7(commit[epoc:6, value:y])&ndash;>b, c</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gitbook使用指导]]></title>
    <link href="http://cxh.me/2015/08/23/gitbook-guide/"/>
    <updated>2015-08-23T16:23:00+08:00</updated>
    <id>http://cxh.me/2015/08/23/gitbook-guide</id>
    <content type="html"><![CDATA[<p>  gitbook是nodejs实现的用来帮助书写电子书的，很多开源的书籍项目是基于gitbook的。gitbook的编写语言是markdown，书籍遵循一定的格式完成之后可以通过gitbook发布为各种版本，比如pdf，mobi等电子书格式，或者发布为静态的website，挂到github pages上，对于一些开源项目来说，这是很方便的书写帮助文档的方式。gitbook同样有一个<a href="https://www.gitbook.com/" title="A modern publishing toolchain. Simply taking you from ideas to finished, polished books.">paas的平台</a>，可以允许多人协作在线完成一部电子书</p>

<p>  首先安装gitbook</p>

<pre><code>npm -g install gitbook
npm -g install gitbook-cli
npm -g install ebook-convert
</code></pre>

<p>  第三个是安装生成电子书的插件，但是这里并不会安装bin文件，需要手动安装<a href="http://calibre-ebook.com/" title="calibre: The one stop solution for all your e-book needs. Comprehensive e-book software.">Calibre</a>。Mac下可以安装Calibre的app然后链接一下bin：</p>

<pre><code>ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin
</code></pre>

<p>  这样就可以生成pdf/mobi等格式的电子书了。</p>

<p>  使用方式可以通过gitbook help来查看。主要是如下几个：</p>

<pre><code>gitbook build [book] [output]   生成电子书，通过--format指定输出格式，默认输出为website
gitbook pdf [book] [output]     生成pdf电子书
gitbook epub [book] [output]    生成epub电子书
gitbook mobi [book] [output]    生成mobi电子书
serve [book]                    生成并开启http server预览
init [directory]                根据summary建立基本目录结构
install [book]                  安装依赖和插件
</code></pre>

<p>  Summary的基本样子见这里：</p>

<pre><code># Summary
* [Introduction](README.md)
* [入门](getting_started/README.md)
   * [初识](getting_started/what_is_it.md)
   * [安装](getting_started/installing_es.md)
   * [API](getting_started/api.md)
   * [文档](getting_started/document.md)
   * [索引](getting_started/tutorial_indexing.md)
   * [搜索](getting_started/tutorial_search.md)
   * [汇总](getting_started/tutorial_aggregations.md)
   * [小结](getting_started/tutorial_conclusion.md)
   * [分布式](getting_started/distributed.md)
   * [本章总结](getting_started/conclusion.md)
* [分布式集群](distributed_cluster/README.md)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工作周年总结]]></title>
    <link href="http://cxh.me/2015/08/07/work-anniversary-note/"/>
    <updated>2015-08-07T15:50:00+08:00</updated>
    <id>http://cxh.me/2015/08/07/work-anniversary-note</id>
    <content type="html"><![CDATA[<p>  工作两周年了，感觉这两年走了不少弯路，也学到不少东西，最近看到日照的<a href="http://www.nosqlnotes.net/archives/128" title="2010年度总结">周年总结</a>，觉得也应该写写。而且看看日照当时的情况，觉得跟我现在也差不多，同样处在职业的选择期，一个明确的规划还是很重要的。</p>

<h3>总结</h3>

<p>  2013年进入支付宝Oceanbase组，待了一年半的时间吧，第一年主要在0.5上修修改改，第二年换到了UPS组，参与1.0的设计。从第一年的情况看，基本是完成了一个不错的职业素养培训，有了分布式的基本概念，处于了解熟悉的阶段。第二年开始对分布式协议有了一些认识，算是入门了吧。总结两年还是学到了一些东西，但是也算是付出了一些代价。出来之后看之前的组，觉得对应届生还是个不错的选择，ob有点像一个学校，闲的时候有不错的学习机会，就是加班太多了。</p>

<p>  后来身体原因离职，来搜狐大数据中心，开始做推荐系统相关的东西。从那个时候想做算法，搞了半年多吧，有些了解，不算入门，大概处于这样一个状态。对我来说，兴趣总归是第一位的，然而在一个方向上有所积累更重要。这样容易过了几年发现什么都会点什么都不精通。互联网发展这么快，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log4cxx安装]]></title>
    <link href="http://cxh.me/2015/07/30/log4cxx-setup/"/>
    <updated>2015-07-30T15:55:00+08:00</updated>
    <id>http://cxh.me/2015/07/30/log4cxx-setup</id>
    <content type="html"><![CDATA[<p>  log4cxx是apache基金会的log开源项目，log4j的c++实现，安装的时候遇到一个小问题：</p>

<p>  首先正常安装：</p>

<pre><code>wget http://mirrors.cnnic.cn/apache/logging/log4cxx/0.10.0/apache-log4cxx-0.10.0.tar.gz
tar zxvf apache-log4cxx-0.10.0.tar.gz
cd apache-log4cxx-0.10.0
./configure
make
</code></pre>

<p>   报错libdb-4.3.so 格式错误。开始以为是文件损坏了，查了一下这个文件</p>

<pre><code>yum provides */libdb-4.3.so
</code></pre>

<p>   提示在db4里面，重新安装db4</p>

<pre><code>yum reinstall db4
</code></pre>

<p>   回去还是报错。后来看了一下格式，貌似链接到了32位版本。修改软连接：</p>

<pre><code>cd /usr/lib/
rm libdb-4.3.so
ln -s ../../lib64/libdb-4.3.so .
</code></pre>

<p>   同样处理另外一个库</p>

<pre><code>rm libexpat.so
ln -s ../../lib64/libexpat.so.0.5.0 libexpat.so
</code></pre>

<p>   应该就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于group commit]]></title>
    <link href="http://cxh.me/2015/07/29/group-commit/"/>
    <updated>2015-07-29T17:25:00+08:00</updated>
    <id>http://cxh.me/2015/07/29/group-commit</id>
    <content type="html"><![CDATA[<p>  最近突然想到这个东西，以前Oceanbase的UpdateServer提交的时候是做了group commit的。基本思路如下：</p>

<ol>
<li> 并发小的时候，超过一个时间窗口就直接提交</li>
<li> 并发大的时候，等请求填满一个buffer再一起提交。</li>
</ol>


<p>  实现上可以考虑如下伪代码：</p>

<pre><code>while true:
    start timer
    if buffer full or timer reach limit:
        commit
        reset timer
    else
        wait and receive
</code></pre>

<p>  广泛运用在一些需要组合请求的地方，比如一些rpc因为历史原因（嗯）一直单条请求，不能改协议的情况下，可以考虑转发一下，做个缓冲。当然这种情况下一般是通过队列来缓冲请求压力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[带小团队的一点思考]]></title>
    <link href="http://cxh.me/2015/07/28/something-about-guide-a-team/"/>
    <updated>2015-07-28T13:56:00+08:00</updated>
    <id>http://cxh.me/2015/07/28/something-about-guide-a-team</id>
    <content type="html"><![CDATA[<p>  事实上我也只是带实习生而已。但是感觉上之前更多的是把自己的任务分出去，而现在是开始跟一些人一起完成一个任务。主要的不同是之前做的事情是在个人工作量里面，自己做也只是慢一点，有时候甚至自己做反倒比分出去更快。现在做的事情已经超过一个人工作量了，必须发挥团队的能动性了，而且之前也只是对自己的工作负责，现在你要负责的是一个团队的KPI了。</p>

<p>  主要有几点感觉：</p>

<ol>
<li> 分配好工作。需要能力的，需要经验的，需要稳定细心的，每个人的风格不一样，应该做的工作也不一样。</li>
<li> 规范流程。大部分加班或者事故都是能从流程上避免的，在设计开发测试上省下来的时间最终都会在上线修bug处理问题的过程中补回来。</li>
<li> 做好计划和项目管理。做一个包含不确定性和风险的事情最重要的是路线图。实现的过程就是把抽象的东西一点点具象化的过程。所以计划上要能够自顶向下，逐步求精。把写程序的思路用进来。</li>
<li> 最后就是能力的问题了。统筹考虑是种需要一点点培养的能力。这个也就只能慢慢来了。何况只要不是纯做管理，你就一定有自己的工作，自己的KPI，协调好自己工作和他人工作安排的关系，还是非常重要的。</li>
</ol>


<p>  最后补一个我理解的开发流程图：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/dev-flow.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过父子关系构建话题树]]></title>
    <link href="http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation/"/>
    <updated>2015-07-18T11:35:00+08:00</updated>
    <id>http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation</id>
    <content type="html"><![CDATA[<p>  一道题目，本来觉得挺简单的，后来卡在一个小问题上。mark一下：</p>

<p>  给定一个数据库表，存了所有话题的关系，形式是：parent->child，表示前面是后面话题的父话题。根据这个关系构建出话题树并打印。</p>

<pre><code>eg:
输入：
    a b
    c a
    d e
    e f
    r c
    r d
输出：
     r
       c
         a
           b
       d
         e
           f
题目隐含：
    1. DAG：有向无环
    2. 节点不重复
</code></pre>

<p>  直观看类似于Graphviz的算法，只不过保证了是棵树。C++实现上可以直接通过树来做，这里用了Python。</p>

<!--more-->


<p>  思路上先找到父节点，再找到子节点，如果都找到，那么移动子节点到父节点下形成一个新的成员，如果父节点没找到，让其成为root节点（加一个叫root的dummynode，反正是话题，我们保证这个话题是保留字）的子节点，如果子节点没找到，让其形成一个新的空节点。</p>

<p>  Python下数据结构类似于：</p>

<pre><code>ret = {
    "root": {
        "r": {
            "c": {
                "a":{
                    "b":{}
                    },
            },
            "d":{
                "e":{
                    "f":{}
                }
            }
        }
    }
}
</code></pre>

<p>  叶节点都保留了一个空的子节点集合。</p>

<p>  代码如下：</p>

<pre><code>default_indent = 2
filename='topic'

def print_result(tree, indent):
    """"""
    for key, value in tree.items():
       if key:
           print ' ' * indent, key
       if value:
           print_result(value, indent + default_indent)


def find_node(tree, element):
    """"""
    for key, value in tree.items():
        if key == element:
            return tree, tree[key]
        elif value:
            parent, child = find_node(value, element)
            if parent:
                return parent, child
    return None, None

def parse_file(ret, fp):
    """"""
    for pair in fp:
        pair = pair.strip("\n")
        if pair:
            parent, child = pair.split()
            _, parent_element = find_node(ret, parent)
            child_parent, child_element = find_node(ret, child)

            if parent_element == None:
                ret["root"][parent] = {}
                parent_element = ret["root"][parent]
            if child_element == None:
                child_element = {}

            parent_element[child] = child_element
            if child_parent:
                del child_parent[child]

if __name__ == '__main__':
    ret = {"root":{}}
    try:
        with open(filename, 'r') as fp:
            parse_file(ret, fp)
    except Exception:
        raise

    print_result(ret['root'], 0)
</code></pre>

<p>  之前出的错误是：</p>

<ol>
<li>python毕竟是引用计数，把一个节点变成另外一个节点的子节点的时候忘了remove旧的节点</li>
<li>深度优先搜索找节点的时候直接return find_node(xxx)了，这样的话深度完一个子节点，不会再继续本层循环了。这个也是大意了，随手一测这个find_node函数就没再看。</li>
</ol>


<p>  性能提升的办法主要是：</p>

<ol>
<li>hash一下所有的节点。把遍历查找的复杂度降下来</li>
<li>先排序（按照parent)，然后把reduce，这样会先把相同的部分生成一个集合，比如a:[b,c,d]这种。</li>
</ol>


<p><strong>事实上，这个题目可以直接用邻接表表示数据结构，然后DFS来打印就好了&hellip;</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phibricator搭建过程总结]]></title>
    <link href="http://cxh.me/2015/07/07/phibricator-setup/"/>
    <updated>2015-07-07T17:45:00+08:00</updated>
    <id>http://cxh.me/2015/07/07/phibricator-setup</id>
    <content type="html"><![CDATA[<p>  <a href="http://phabricator.org/" title="Phibricator官网">Phibricator</a>是Facebook开源的一体化项目管理、代码review工具，主要特点是集成度高、界面漂亮。根据搭建的经验看，确实做的非常完善，各种细节用起来像是商业产品，不会像其他的开源产品那么难以配置。这里把配置过程根据回忆写一下：</p>

<p>  官方给出过一个一键安装的脚本，但是下载的时候感觉有点问题吧，下载完不是sh而是网页，而且我只有一台机器，环境都已经预先有了，也不想再搭一套LAMP。这里我们以centos5为例：</p>

<p>  首先安装httpd + mysql + php，由于centos5的版本太低，yum源里的mysql和php均低于phibricator要求的版本，我们需要先升级yum源，参见<a href="http://zengrong.net/post/1595.htm" title="升级CentOS 5.x中的PHP 5.1到5.3">参考文献</a>， 不过好像安装的时候没有php53u，而是直接php53</p>

<p>  之后把对应的扩展也装了:</p>

<pre><code>yum install php53-mbstring
yum install php53-mysql
</code></pre>

<!--more-->


<p>  升级mysql到mysql5.5，参见<a href="http://www.ha97.com/4145.html" title="RHEL/CentOS 5.x使用yum快速安装MySQL 5.5.x">参考文献</a>。中间遇到两个问题:</p>

<ol>
<li><p>mysql 启动失败，提示没有权限创建pid。su到mysql用户下发现/var/run目录mysql用户没有execute的权限：</p>

<p> usermod +x /var/run</p>

<p> 给目录加execute的权限</p></li>
<li><p>mysql_upgrade失败，直接提示FATAL ERROR:Upgrade failed，发现用户名密码的问题，root@localhost密码没变，root@127.0.0.1在升级之后好像没有密码了</p>

<p> SET PASSWORD FOR &lsquo;root&rsquo;@&lsquo;127.0.0.1&rsquo; = PASSWORD(&lsquo;newpass&rsquo;);</p>

<p> 重新设置密码。</p></li>
</ol>


<p>  之后去/var/www/html安装源码:</p>

<pre><code>$ git clone https://github.com/phacility/libphutil.git
$ git clone https://github.com/phacility/arcanist.git
$ git clone https://github.com/phacility/phabricator.git
</code></pre>

<p>  顺便装上一些别的php扩展：</p>

<pre><code>sudo yum install pcre-devel
sudo yum install php-pear
sudo yum install php53-process
sudo pecl install apc
</code></pre>

<p>  主要是提升性能的。然后配置httpd.conf</p>

<pre><code>&lt;VirtualHost *&gt;
  # Change this to the domain which points to your host.
  ServerName phabricator.example.com

  # Change this to the path where you put 'phabricator' when you checked it
  # out from GitHub when following the Installation Guide.
  #
  # Make sure you include "/webroot" at the end!
  DocumentRoot /path/to/phabricator/webroot

  RewriteEngine on
  RewriteRule ^/rsrc/(.*)     -                       [L,QSA]
  RewriteRule ^/favicon.ico   -                       [L,QSA]
  RewriteRule ^(.*)$          /index.php?__path__=$1  [B,L,QSA]
&lt;/VirtualHost&gt;
</code></pre>

<p>  最后一个Rule的B在我的httpd下不识别，所以直接去掉了，貌似没什么影响&hellip;重启之后到phibricator的源码目录执行：</p>

<pre><code>phabricator/ $ ./bin/storage upgrade
</code></pre>

<p>  按照提示可以配置mysql 用户名密码，之后可以看到建立了数据库结构。这时候访问host就能看到界面了。先注册管理员进去，能够看到一系列的TIPs，说明需要配置的地方。Phibricator在这方面非常人性化，按照提示一点点配置就可以了。直到解决大部分的warning。剩下的问题就是注册用户和邮件了。</p>

<p>  首先在auth上开启认证方式，这里我们还是比较传统，选择了用户名密码的方式，你也可以选择其他账号体系打通的方式。一个用户注册之后，管理员需要批准用户，这个用户才能登陆。我找了好久，才发现原来批准在这位置：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/approval-queue.png"></p>

<p>  最后是配置邮件服务器。首先你需要有个本地的或者其他提供商提供的邮件服务器。可以参考<a href="http://blog.csdn.net/lihongxun945/article/details/9030753" title="phabricator 邮件服务配置 备忘">这里</a>，PHP Mailer设置：</p>

<pre><code>phpmailer.mailer: set to "smtp".
phpmailer.smtp-host: smtp.xxx.com
phpmailer.smtp-port: 25
phpmailer.smtp-user: xxxx
phpmailer.smtp-password: xxxx
</code></pre>

<p>  之后重启daemon应该就能发送邮件了。删除用户非常有意思，ph只允许从命令行删除</p>

<pre><code>phabricator/ $ ./bin/remove destroy @harrychen
</code></pre>

<p>  之后会有一个有意思的界面：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/delete-user.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简历生成器（基于moderncv+latex）]]></title>
    <link href="http://cxh.me/2015/06/26/resume-generator-using-latex-and-moderncv/"/>
    <updated>2015-06-26T15:47:00+08:00</updated>
    <id>http://cxh.me/2015/06/26/resume-generator-using-latex-and-moderncv</id>
    <content type="html"><![CDATA[<p>项目地址: <a href="https://github.com/chenxiaohui/resume">https://github.com/chenxiaohui/resume</a></p>

<h3>说明</h3>

<p>  通过文本文件生成简历tex的generator。最终生成pdf还是要靠Latex+Moderncv，环境请自行配置。</p>

<ul>
<li>windows下：<a href="http://www.ctex.org/HomePage">http://www.ctex.org/HomePage</a></li>
<li>Linux下：<a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></li>
<li><p>Mac下：<a href="https://tug.org/mactex/">https://tug.org/mactex/</a></p>

<p>需要的包都通过sudo tlmgr install package来安装。字体主要使用了Times New Roman（西文）和 Kaiti SC（中文）。可根据喜好换。</p></li>
</ul>


<h3>模板配置</h3>

<p>  config.tex 定义了公共头文件，包括包含的宏包，版面的布置和字体语言。</p>

<p>  xxtemplate.tex定义了模板。模板语法比较简单，不给出严谨的语法定义了，主要如下两点：</p>

<ol>
<li>%xxx% 表示一个变量，将来会从cv文件中查找对应名字的变量，找到之后替换这个%xxx%</li>
<li><p>%for=>xx% %endfor%表示一个循环，xx是section的name，将来会从cv文件中找到对应的section，然后parse section下的每个单独的项目，用结果替换for循环中的内容</p>

<ol>
<li>for循环中{0}{1}..表示一个for循环变量，cv中section下的条目会被分割成多个变量，顺序依次是0，1，2..，渲染的时候会对应的替换上述{0}{1}变量。如果数量不匹配会报错。</li>
</ol>
</li>
<li><p>如上语法部分关键字可以配置，在config.py中。可以酌情修改。</p></li>
</ol>


<p>  xx.cv包含了简历内容，格式上参考了ini文件格式，但是略有不同。</p>

<ol>
<li>[section name]顶一个了一个section，对应简历中一个部分。section name的显示名称是在template里面写好的。这里的name只是给程序使用的，可以跟显示名称一致也可以不同。</li>
<li>不包含在某个section下的条目通过 key = value的方式定义。不能跨行，程序parse的时候只找第一个等号，后面有空格等符号都不影响。</li>
<li>section下的条目每条可以包含多个字段，字段之间默认用竖线（|）分割（可修改）。字段的数量需要跟模板中对应section下for循环体中变量的数量一致。</li>
</ol>


<p>  程序中给出了几个实例，分别是英文、中文简历的template和cv文件，供参考。</p>

<h3>使用</h3>

<p>  写好对应的cv和模板之后，make就行。open命令可能在mac之外的系统不能使用，建议注掉。</p>

<p>  make distclean清空所有文件包括pdf</p>

<p>  make again 是为了生成页码，xelatex跑第一遍的时候页码是乱码。</p>

<p>  gen.py 文件格式如下：</p>

<pre><code>./gen.py &lt;template-file&gt; &lt;cvfile&gt; &lt;output-file&gt;
</code></pre>

<h3>参考文献:</h3>

<p>  [1] http moderncv 的笔记（支持中文）, <a href="http://www.xiangsun.org/tex/notes-on-moderncv">http://www.xiangsun.org/tex/notes-on-moderncv</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于zookeeper的配置管理客户端]]></title>
    <link href="http://cxh.me/2015/06/16/sohu-zk-client-document/"/>
    <updated>2015-06-16T16:28:00+08:00</updated>
    <id>http://cxh.me/2015/06/16/sohu-zk-client-document</id>
    <content type="html"><![CDATA[<h3>名词解释：</h3>

<p>  SeviceConfig:</p>

<pre><code>一个服务的所有配置存在一个目录下
</code></pre>

<p>  BucketConfig:</p>

<pre><code> Bucket的配置存在一个单独的子目录中
</code></pre>

<h3>配置项类型：</h3>

<ul>
<li>Integer</li>
<li>Long</li>
<li>Short</li>
<li>Float</li>
<li>Double</li>
<li>Byte[]</li>
<li>Boolean</li>
<li>String</li>
<li>自定义配置项 ConfigObject</li>
</ul>


<h3>使用说明：</h3>

<h4>POM：</h4>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.sohu.adrd&lt;/groupId&gt;
  &lt;artifactId&gt;sohu-zk-client&lt;/artifactId&gt;
  &lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h4>初始化</h4>

<p>  ServiceConfig.Instance().init(&ldquo;ConnectString&rdquo;, &ldquo;serviceName&rdquo;);//如果做测试可以用10.16.3.61:2181</p>

<p>  ServiceConfig.Instance().init(&ldquo;serviceName&rdquo;); 默认使用肖永磊的zk地址</p>

<h4>配置项使用</h4>

<p>  先给默认值</p>

<pre><code>private static long exploitDiscardTimespan = 7 * 86400L;
</code></pre>

<p>  可以保存个Instance()的引用</p>

<pre><code>private ServiceConfig serviceConfig = ServiceConfig.Instance();
</code></pre>

<p>  所有引用到的地方，通过如下方式取配置项（这是默认config）：</p>

<p>   serviceConfig.getLong(&ldquo;exploitDiscardTimespan&rdquo;, exploitDiscardTimespan)</p>

<p>  如果是BucketConfig(bucketConfig会在zookeeper上根目录下再增加一个Node，名字是bucket的名字，在此之下存储config)</p>

<p>   serviceConfig.Bucket(&ldquo;bucketName&rdquo;).getLong(&ldquo;exploitDiscardTimespan&rdquo;, exploitDiscardTimespan)</p>

<p>  这样server端更新配置的时候，serviceConfig会根据通知刷新自己的配置缓存，下次使用getLong的时候就得到了新的配置。</p>

<p>  上述getLong的过程包含了：</p>

<ol>
<li><p> 如果是Bucket配置，从Bucket中获取，如果找不到，从Service的配置获取，如果还是没有，返回默认值。</p></li>
<li><p> 对于返回默认值的情况，写回Zookeeper。</p></li>
<li><p> 如果Zookeeper端有修改，Zkclient会收到消息，重新update本地配置项的缓存。</p></li>
<li><p> 如果定义了handler调用handler，如下所述：</p></li>
</ol>


<p>  如果需要根据配置修改的通知来做出响应（这是默认事件，node_data_change)：</p>

<pre><code>ServiceConfig.Instance().addEventListener("task_period", new IEventHandler() {
  @Override
  public void process(ZkEvent event) {
    logger.info("update task period.");
    setDeclaredField(TimerTask.class, ServerTasks.this, "period", ServiceConfig.Instance().getLong("task_period", period));  
  }
});
</code></pre>

<p>  如果需要删除的通知：</p>

<pre><code>  ServiceConfig.Instance().addEventListener("task_period", EventType.NodeDeleted, new IEventHandler() {
  @Override
  public void process(ZkEvent event) {
    logger.info("update task period.");
    setDeclaredField(TimerTask.class, ServerTasks.this, "period", ServiceConfig.Instance().getLong("task_period", period));  
  }
});
</code></pre>

<h4>结合SpringFramework：</h4>

<pre><code>基本不变，只不过SpringFramework会先填充InitializingBean的域，这些值只有在出默认值的时候才会被采用。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些python小技巧]]></title>
    <link href="http://cxh.me/2015/05/27/python-tricks/"/>
    <updated>2015-05-27T10:54:00+08:00</updated>
    <id>http://cxh.me/2015/05/27/python-tricks</id>
    <content type="html"><![CDATA[<ol>
<li><p>生成一个重复列表可以通过如下语句:</p>

<pre><code> [i] * n #这比[ i for _ in range(0,n) ]简洁太多
 同样可以"i" * n来生成字符串
</code></pre></li>
<li><p>map函数。</p>

<p> 可以用来分类函数和其调用参数，对于线程池比较有用。比如</p>

<pre><code> import urllib2 
 from multiprocessing.dummy import Pool as ThreadPool 

 urls = [
         'http://www.python.org', 
         # etc.. 
         ]

 pool = ThreadPool(4) 
 results = pool.map(urllib2.urlopen, urls)
 pool.close() 
 pool.join() 
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git远程分支不存在的问题]]></title>
    <link href="http://cxh.me/2015/05/11/git-remote-branch-not-exists/"/>
    <updated>2015-05-11T12:11:00+08:00</updated>
    <id>http://cxh.me/2015/05/11/git-remote-branch-not-exists</id>
    <content type="html"><![CDATA[<p>  建立了一个远程分支，提交到origin上之后，发现之前有一个同样的远程Repository存在，而且名字一样，这就比较D疼了，git branch -a 显示的分支里面的分支提交到了另一个Repository，但是这个Repository已经改名字了，虽然地址一样。</p>

<p>  搞来搞去之后发现git checkout远程分支的时候报不存在的问题，删除这个分支的时候同样有这个问题：</p>

<pre><code>unable to delete 'refactor': remote ref does not exist
</code></pre>

<p>  导致这个分支就这么存在着删不掉了。查stackoverflow有人给出<a href="http://stackoverflow.com/questions/10292480/when-deleting-remote-git-branch-error-unable-to-push-to-unqualified-destinatio" title="When deleting remote git branch “error: unable to push to unqualified destination”">如下的方案</a>：</p>

<pre><code>git fetch -p origin
</code></pre>

<p>  问题是能解决了，但是不太理解为什么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac下多屏幕移动窗口的快捷键]]></title>
    <link href="http://cxh.me/2015/05/10/mac-multi-screen-shortcut/"/>
    <updated>2015-05-10T15:50:00+08:00</updated>
    <id>http://cxh.me/2015/05/10/mac-multi-screen-shortcut</id>
    <content type="html"><![CDATA[<p>  mac下使用多屏幕的话，经常需要把一个窗口移动到另一个窗口，windows下有快捷键win+shift+左右，linux下貌似可以通过xdotool实现，绑定一个快捷键，xdotool帮助你移动窗口到一个绝对位置。如下：</p>

<pre><code>xdotool getactivewindow windowmove 0 y windowactivate windowfocus
xdotool getactivewindow windowmove 1280 y windowactivate windowfocus
</code></pre>

<p>  mac下没有找到对应的系统快捷键，虽然可以设定一个zoom键来完成窗口最适化，但是没有快捷键来完成窗口的移动。这里我们通过<a href="http://manytricks.com/moom/" title="Moom">Moom</a>实现。</p>

<p>  Moom是一个窗口管理工具，安装之后只有一个配置页面，但是你会发现鼠标移动到左上角窗口最适化的按钮上的时候会弹出一个窗口管理的提示框。如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_tooltip.png"></p>

<p>  然后我们配置窗口移动的功能，首先需要一个全局快捷键：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_shortcut.png"></p>

<p>  之后可以设置按下全局快捷键之后上下左右键的功能。有移动窗口，半最大化窗口，缩小放大和移动窗口到一个屏幕。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_config.png"></p>

<p>  这样就可以先按下全局快捷键，如下：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2015/moom_press_shortcut.png"></p>

<p>  再通过你定义的快捷键来移动窗口了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins 安装配置]]></title>
    <link href="http://cxh.me/2015/04/23/jenkins-setup/"/>
    <updated>2015-04-23T13:57:00+08:00</updated>
    <id>http://cxh.me/2015/04/23/jenkins-setup</id>
    <content type="html"><![CDATA[<p>  首先介绍一下Jenkins，如果你熟悉自动化构建的话，那么肯定听说过hudson。Jenkins是hudson的开发者跟Oracle撕bi之后，另立门户的一个hudson分支。当然这么说似乎不太靠谱，目前hudson已经不维护了毕竟，而Jenkins的开发社区还是很活跃的，各种插件层出不穷。总的来说，如果你不是已经习惯了hudson并且有一个能用的副本，都应该迁移到Jenkins。</p>

<p>  下面说一下如何配置。</p>

<p>  Jenkins的安装非常简单，只需要从Jenkins的<a href="https://jenkins-ci.org/" title="Jenkins">主页</a>上下载最新的jenkins.war文件然后运行 java -jar jenkins.war。如果需要配置运行参数可以如下设置一些环境变量。</p>

<pre><code>JENKINS_ROOT=/home/harrychen/share/jenkins
export JENKINS_HOME=$JENKINS_ROOT/jenkins_home
java -jar $JENKINS_ROOT/jenkins.war --httpPort=8080 &gt;&gt;output.log 2&gt;&amp;1 &amp;
</code></pre>

<p>  打开对应url可以看到如下界面</p>

<!--more-->


<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins.png"></p>

<p>  系统管理里面有一些需要配置的项，比如JDK：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_jdk.png"></p>

<p>  GIT</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_git.png"></p>

<p>  MAVEN</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_maven.png"></p>

<p>  ssh-key</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_sshkey.png"></p>

<p>  ssh-server</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_sshserver.png"></p>

<p>  装一下slack的插件可以配置slack</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_slack.png"></p>

<p>  然后是建立项目的配置，Jenkins把每个自动发布的项目作为一个单独的配置，主要是如下几个：</p>

<p>  指定代码路径：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_gitclone.png"></p>

<p>  部署前事件：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_deploy_pre.png"></p>

<p>  部署后事件:</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_after_deploy.png"></p>

<p>  最后保证这些事件是在之前配置的ssh-server上执行的。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/jenkins_enent_server.png"></p>

<p>  细节请看<a href="http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf" title="Jenkins 入门">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些瞬间]]></title>
    <link href="http://cxh.me/2015/04/22/some-moments/"/>
    <updated>2015-04-22T22:08:00+08:00</updated>
    <id>http://cxh.me/2015/04/22/some-moments</id>
    <content type="html"><![CDATA[<p>  回想一些事情的时候感觉印象最深刻的往往不是一段时间，而是一些瞬间。比如大学毕业晚会的那个晚上，大家喝的一塌糊涂，早晨醒来，看依然灿烂的阳光，那种孤独感是能镌刻很久的。再比如在北航的时候，那时候习惯晚上看书，安静，一个人在三号楼前的空地走走，听学院路上的川流不息的车声。事情已经远去，感觉依然清晰。每个片段好像人生路上的benchmark，只不过留下最深印象的，往往不是所得，而是所感。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review编码问题]]></title>
    <link href="http://cxh.me/2015/04/22/post-review-encoding-problem/"/>
    <updated>2015-04-22T16:08:00+08:00</updated>
    <id>http://cxh.me/2015/04/22/post-review-encoding-problem</id>
    <content type="html"><![CDATA[<p>  windows下post-review遇到一个问题（不是我，不用windows）。python会报错：</p>

<pre><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position xxx: ordinal not in range(128)     
</code></pre>

<p>  又是编码的问题啊，我不想去看post-review的源码，所以还是改默认环境的源码好了。找到rbtools\utils\process.py，import sys后面加两行：</p>

<pre><code>reload(sys)
sys.setdefaultencoding("utf-8") 
</code></pre>

<p>  Ok.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[partition算法的落点讨论]]></title>
    <link href="http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis/"/>
    <updated>2015-04-20T21:27:00+08:00</updated>
    <id>http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis</id>
    <content type="html"><![CDATA[<p>  首先这里的partition算法指的是快速排序中把数据分区的算法，算法接受一个数列和一个值，返回一个位置，这个位置之前的元素都小于等于输入值，之后的元素都大于等于输入值。</p>

<p>  算法如下：</p>

<p>  还有一种常见的形式：</p>

<p>  这里我们讨论下落点的情况，如果partition算法可以传入任何的value，而不是快排中那样从序列中随机获得一个值，那么结果就会有多重情况了。</p>
]]></content>
  </entry>
  
</feed>
