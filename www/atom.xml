<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-03-03T19:21:24+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sudo的环境变量]]></title>
    <link href="http://cxh.me/2015/03/03/sudo-env/"/>
    <updated>2015-03-03T18:34:00+08:00</updated>
    <id>http://cxh.me/2015/03/03/sudo-env</id>
    <content type="html"><![CDATA[<p>  sudo的时候不会加载.bashrc什么的，今天就遇到了一个比较扯的问题。在home下安装了高版本的vim，bashrc里面PATH是home高于/bin的，但sudo vi的时候会调用系统的。尝试如下方式：
  1. 修改其他配置如.profile什么的。比较麻烦。
  2. 修改sudoers里面env_keep，发现还是不起作用。
  3. 修改sudoers里面secure_path，如下：</p>

<pre><code>    Defaults    secure_path = /root/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
</code></pre>

<p>  OK。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试下CloudSight的图像识别]]></title>
    <link href="http://cxh.me/2015/03/01/test-cloudsight/"/>
    <updated>2015-03-01T20:58:00+08:00</updated>
    <id>http://cxh.me/2015/03/01/test-cloudsight</id>
    <content type="html"><![CDATA[<p>  偶然看到<a href="http://buzz.beebeeto.com/topic/45/" title="使用CloudSight API进行图像识别的Python脚本">这个</a>链接，一个识别图像并标注的，还蛮有意思。代码直接用示例里面的就可以, 需要注意两个问题：</p>

<ol>
<li> <a href="https://cloudsightapi.com/api_clients/new" title="New Project">注册一个项目</a>。ResponseType选择Product。</li>
<li> 必须上传网络链接，不能使用文件。</li>
</ol>


<p>  测试几个效果（多次返回结果不一定一样）：</p>

<ol>
<li> <a href="http://www.baidu.com/img/bdlogo.png" title="百度标识">百度首页</a>，识别为&#8221;百度标志&#8221;</li>
<li> <a href="http://ww4.sinaimg.cn/bmiddle/61d83ed4jw1epqi6itn8mj20az08caa8.jpg" title="陈吉宁校长">陈吉宁校长的头像</a>，识别为&#8221;男人的黑色西装外套&#8221; 或 &ldquo;男人的蓝色西装&rdquo;</li>
<li> <a href="http://cxh.me/images/common/baiyipiaopiao.jpg" title="背景图">我博客一张背景图</a>，识别为&#8221;女性的黑色T恤&#8221; 或 &ldquo;红色的通勤自行车&rdquo;</li>
</ol>


<p>  让我突然对这个tag算法很感兴趣。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac下ffmpeg的编译]]></title>
    <link href="http://cxh.me/2015/03/01/compile-ffmpeg-under-mac/"/>
    <updated>2015-03-01T11:08:00+08:00</updated>
    <id>http://cxh.me/2015/03/01/compile-ffmpeg-under-mac</id>
    <content type="html"><![CDATA[<p>  基本步骤可以看<a href="http://www.liaoxuefeng.com/article/0013738927837699a7f3407ea5f4b5caf8e1ab47997d7c5000" title="Mac OS X编译ffmpeg">这个</a>，说两个问题：</p>

<ol>
<li><p>brew的formulae没有celt这个包。忽略了算了。</p></li>
<li><p>libaacplus安装的时候，</p>

<ol>
<li>首先这个地址<code>http://217.20.164.161/~tipok/aacplus/libaacplus-2.0.2.tar.gz</code>已经失效了，从网上下载的话，这个版本还是有问题，configure的时候会卡住，一些patch丢失了好像。建议直接fork <a href="https://github.com/Distrotech/libaacplus" title="Distrotech/libaacplus">github上的</a>。</li>
<li>这个branch也有问题，frontend链接的时候会提示<code>ld: symbol(s) not found for architecture x86_64</code>，直接从Makefile.am里面把frontend去掉算了。</li>
</ol>
</li>
<li><p>可以通过brew直接安装：</p>

<pre><code> brew install ffmpeg --with-fdk-aac --with-ffplay --with-freetype --with-frei0r --with-libass --with-libvo-aacenc --with-libvorbis --with-libvpx --with-opencore-amr --with-openjpeg --with-opus --with-rtmpdump --with-schroedinger --with-speex --with-theora --with-tools
</code></pre></li>
<li><p>libav10.5之后没有avserver的安装了，虽然enable-avserver的选项还在，所以不同版本安装的卸载时候会有些残留文件。我的安装选项是：</p>

<pre><code> --enable-libfaac\ --enable-libfdk-aac\ --enable-libfreetype\ --enable-libmp3lame\ --enable-libopencore-amrnb\ --enable-libopencore-amrwb\ --enable-libopenjpeg\ --enable-libopus\ --enable-librtmp\ --enable-libschroedinger\ --enable-libspeex\ --enable-libtheora\ --enable-libvo-aacenc\ --enable-libvorbis\ --enable-avserver\ --enable-libvpx\ --enable-shared \ --enable-libx264\ --enable-gpl\ --enable-nonfree\ --enable-version3\ --enable-openssl\ --enable-gnutls\ --enable-zlib
</code></pre></li>
<li><p>Besides, 我发现brew可以列出configure选项，如下：</p>

<pre><code> brew options xxx
</code></pre></li>
</ol>


<p>  手动安装的话，可以通过./configure &mdash;help来查看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django mod_wsgi配置的一些问题]]></title>
    <link href="http://cxh.me/2015/02/27/django-to-apache/"/>
    <updated>2015-02-27T13:39:00+08:00</updated>
    <id>http://cxh.me/2015/02/27/django-to-apache</id>
    <content type="html"><![CDATA[<p>  安装apache不说了，用apache做django容器的时候（详见<a href="http://www.cnblogs.com/fengzheng/p/3619406.html" title="Linux下安装Apache并以mod_wsgi方式部署django站点">参考文献1</a>)遇到如下几个问题，记录一下：</p>

<ol>
<li><p> apxs找不到。centos上直接装的httpd-2.2.3-83.el5_10，默认没有apxs。想源码编译一个apache，结果发现源里面有。</p>

<pre><code> yum install -y httpd-devel
</code></pre></li>
<li><p> /usr/local/lib/libpython2.7.a: could not read symbols: Bad value</p>

<pre><code>错误提示里面已经说了，libpython2.7.a没有动态编译。下了一个python2.7的源码，重新编译安装一下。
./configure --prefix=/usr/local/  –enable-shared CFLAGS=-fPIC
make
make install
</code></pre></li>
<li><p> ImportError: libpython2.7.so.1.0: cannot open shared object file: No such file or directory</p>

<pre><code>库路径问题，要么配置LD_LIBRARY_PATH，要么修改ld.so.conf然后ldconfig
</code></pre></li>
<li><p> / not found.</p>

<pre><code>httpd.conf配置：
WSGIScriptAlias / /var/www/html/mysite/mysite/django.wsgi
&lt;Directory /var/www/html/mysite&gt;
    Order allow,deny
    Allow from all
&lt;/Directory&gt; 
</code></pre></li>
<li><p> log/errro_log中 No module named mysite.settings。</p>

<pre><code>wsgi配置：
import sys
sys.path.append("/var/www/html/mysite/")
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gtest在mac上链接的问题]]></title>
    <link href="http://cxh.me/2015/02/06/gtest-bug-on-mac/"/>
    <updated>2015-02-06T20:39:00+08:00</updated>
    <id>http://cxh.me/2015/02/06/gtest-bug-on-mac</id>
    <content type="html"><![CDATA[<p>  gtest鉴于google自己的风格，不提供make install，直接make完之后配置路径链接就行，在linux上这样是ok的：</p>

<pre><code>g++  -I$GTEST_DIR/include -I$GTEST_DIR -c $GTEST_DIR/src/gtest-all.cc
g++ -I$GTEST_DIR/include -I$GTEST_DIR -c $GTEST_DIR/src/gtest_main.cc

ar -rv libgtest.a gtest-all.o
ar -rv libgtest_main.a gtest_main.o

c++ -g -Wall -Wextra -pthread  -isystem $GTEST_DIR/include  -c -o RemoveElement.o RemoveElement.cpp
c++ -g -Wall -Wextra -pthread  -isystem -isystem $GTEST_DIR/include/include -c -o SameTree.o SameTree.cpp
</code></pre>

<p>  在mac下这里会报错：architecture x86_64。关键我一直理解gest_main是包含main函数的gtest，gtest-all是不包含的，知道发现官方的makefile执行的时候是这样的</p>

<pre><code>ar rv gtest_main.a gtest-all.o gtest_main.o   
</code></pre>

<p>  用这里的gtest_main.a做libgtest_main.a就行了。不理解为什么在mac上单独打包一个gtest_main.o为什么不行。论坛貌似有人贴了一个patch，不看了，回家，碎觉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[区分下shell和makefile中的特殊字符]]></title>
    <link href="http://cxh.me/2015/02/04/distinguish-special-symbol-in-shell-and-makefile/"/>
    <updated>2015-02-04T14:51:00+08:00</updated>
    <id>http://cxh.me/2015/02/04/distinguish-special-symbol-in-shell-and-makefile</id>
    <content type="html"><![CDATA[<p>  主要是在Makefile中看到了这种字符($@)，不理解含义，查阅了一下，跟shell中意义不一样：</p>

<pre><code>$@     -is the name of the target currently being processed.
$&lt;     -is the name of the first dependency.
</code></pre>

<p>  顺便提下shell下的</p>

<pre><code>$#    Stores the number of command-line arguments that were passed to the shell program.
$?    Stores the exit value of the last command that was executed.
$0    Stores the first word of the entered command (the name of the shell program).
$*    Stores all the arguments that were entered on thecommand line ($1 $2 ...).
"$@"  Stores all the arguments that were entered on the command line, individually quoted ("$1" "$2" ...).
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gcc命令行参数总结]]></title>
    <link href="http://cxh.me/2015/02/04/gc-gcc-parameters-summary/"/>
    <updated>2015-02-04T11:36:00+08:00</updated>
    <id>http://cxh.me/2015/02/04/gc-gcc-parameters-summary</id>
    <content type="html"><![CDATA[<p>   总结一下混乱的GCC命令行参数，帮助写Makefile:</p>

<ol>
<li><p>编译阶段</p>

<ol>
<li>预编译E->生成汇编S(ccl)&ndash;>生成机器码c(as)&ndash;>链接生成目标程序(ld)</li>
</ol>
</li>
<li><p>输出类型：</p>

<ol>
<li>-E 只执行到预编译</li>
<li>-S 只执行到汇编阶段。生成汇编代码。</li>
<li>-c 只执行到编译。输出目标文件。</li>
<li>空。生成链接目标代码。</li>
<li>-o 指定输出文件名。</li>
</ol>
</li>
<li><p>输入类型：</p>

<ol>
<li><p>每个阶段可以接受之前阶段的中间结果（可跨越）。比如：</p>

<pre><code> gcc -E hello.c -o hello.i
 gcc -S hello.i -o hello.s
 顺序可以换：
 gcc -c -o hello.o hello.c
</code></pre></li>
</ol>
</li>
<li><p>优化调试相关</p>

<ol>
<li>-g 生成调试信息</li>
<li>-s 去掉调试和符号信息</li>
<li>-O[1|2|3..] 编译优化</li>
<li>-W[all] 开启额外警告</li>
</ol>
</li>
<li><p>链接相关：</p>

<ol>
<li>-l, 指定所使用到的函数库</li>
<li>-L, 指定函数库所在的文件夹。</li>
<li>-I, 指定头文件所在的文件夹</li>
</ol>
</li>
</ol>


<h3>Bibliography:</h3>

<blockquote><p>[1] Linux平台gcc和动态共享库的基础知识, <a href="http://robbinfan.com/blog/9/gcc-linker-basic-usage">http://robbinfan.com/blog/9/gcc-linker-basic-usage</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Configuration Inheritance]]></title>
    <link href="http://cxh.me/2015/02/02/python-config-inheritance/"/>
    <updated>2015-02-02T11:54:00+08:00</updated>
    <id>http://cxh.me/2015/02/02/python-config-inheritance</id>
    <content type="html"><![CDATA[<p>  While refactoring a project, I met with a situation that one configuration extends another configuration, like this:</p>

<pre><code>ConfigA = {"a":xx, "b":xx}
ConfigB extends ConfigA + {"a":yy, c:"yy"}
</code></pre>

<p>  Code before refactor treats configA and configB separately. So after a few code iterations you will find configA has something same with configB. So I change it to this：</p>

<pre><code>configA = {"a":xx, "b":xx}
configB = dict(configA.items() + {"a":yy, c:"yy"}}
</code></pre>

<p>  While this treats configA and configB evenly, meanwhile, it costs extra replication. A better way is like this:</p>

<pre><code>configA = {"a":xx, "b":xx}
configB = dict(configA, **{"a":yy, c:"yy"}})
</code></pre>

<p>  The order of configA and configB&rsquo;s own elements is immutable, which means if configA and configB has a same element, use configB as result.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About random shuffle in cplusplus]]></title>
    <link href="http://cxh.me/2015/02/01/random-shuffle/"/>
    <updated>2015-02-01T19:14:00+08:00</updated>
    <id>http://cxh.me/2015/02/01/random-shuffle</id>
    <content type="html"><![CDATA[<p>   Actually I just want to memorize the usage of STL function random_shuffle. It takes two or threes arguments, the begin iterator, end iterator and a generator. What makes it interesting is the optional third parameter. Random_shuffle will pass the index to generator and takes the output as index to place current element while shuffling. Here is an example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
const int POKER_NUM = 52; //52 pocker cards
void print_poker(int PokerNum)
{
    cout &lt;&lt; PokerNum &lt;&lt; " ";
}

class MyRand
{
public:
    int operator()(int index)
    {
        return rand() % PockerNum;
    }
};

int main()
{
    srand( (unsigned)time(NULL) ); //rand seed
    vector&lt;int&gt; poker; 
    //initialize
    for (int num = 0; num &lt; POKER_NUM; ++num)
    {
        poker.push_back(num+1);
    }

    //with default random_shuffle
    random_shuffle(poker.begin(), poker.end());
    for_each(poker.begin(), poker.end(), print_poker);
    cout &lt;&lt; endl;

    //use custom random_shuffle
    random_shuffle(poker.begin(), poker.end(), MyRand());
    copy(poker.begin(), poker.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
}
</code></pre>

<p>  I copy it from <a href="http://blog.csdn.net/aheroofeast/article/details/3907192" title="random_shuffle算法小例子">here</a>. While I found a mistake in it. The result isn&rsquo;t really random. The pseudo-code of above is :</p>

<pre><code>for i in 0..n
    exchange a[i] and a[random(0..n)]
</code></pre>

<p>  We assume a method can generate a sequence(a[0]..[n]) randomly, which means each sequence appears with the probability 1/n!. Take certain sequence a[0&#8217;]&hellip;a[n&#8217;] as an example: a[0&#8217;] appears with the probability 1/n, so a[1&#8217;] should appear with the probability 1/(n-1), etc. The algorithm above find a[1&#8217;] in the whole candidates, makes the probability 1/n actually. The right algorithm is like this:</p>

<pre><code>for i in 0..n
    exchange a[i] and a[random(i..n)]
</code></pre>

<p>  With a little change in the code:</p>

<pre><code>class MyRand
{
public:
    int operator()(int index)
    {
        return rand() % (PockerNum - index) + index;
    }
};
</code></pre>

<h3>Bibliography:</h3>

<blockquote><p>[1] random_shuffle算法小例子, <a href="http://blog.csdn.net/aheroofeast/article/details/3907192">http://blog.csdn.net/aheroofeast/article/details/3907192</a></p>

<p>[2]   &ldquo;Algorithms, <a href="http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY">http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的治牙经历]]></title>
    <link href="http://cxh.me/2015/02/01/experience-of-curing-my-teeth/"/>
    <updated>2015-02-01T17:02:00+08:00</updated>
    <id>http://cxh.me/2015/02/01/experience-of-curing-my-teeth</id>
    <content type="html"><![CDATA[<p>  2015.1.12，生日，去做了第一轮刮治的第一次治疗。痛不欲生啊。</p>

<p>  11月的时候查出来牙周有问题，其实很早就觉得不好了，洗牙之前没去看。洗牙的时候拍了牙片，槽骨吸收的很厉害了。中间又拖了两个月，一个是忙，一个是没挂上号，终于上周去北大口腔挂了号。医生说很严重，侵袭性牙周炎，牙周袋太深，可能还是得手术。</p>

<p>  今天第一次刮治。感慨牙这个东西，不意识到的时候不会觉得他的重要，上周探完牙周袋深度就疼了一个周，这次更是痛不欲生的感觉，打了麻药还是这样。而且奇怪的是手刮并不怎么疼，疼的还是超声洗牙石的部分。唯一的安慰是大夫态度都不错。牙科的大夫mm居多，虽然带着口罩都看不清楚长相&hellip;</p>

<p>  以前还是不重视啊。家庭上也整体不重视。中国还是有很多落后的地方，理念上这么多年都没有更新过来。联想到公务员热和中国父母普遍的求稳定，觉得理念真是落后太多了。至于过年各种嘘寒问暖的亲戚&hellip;哎，你们没有隐私这个观念么&hellip;还好我家人父母不太执着这些事情，就是说说算了&hellip;或者我压根没当真过..</p>

<p>  总的来说。长大了，要慢慢消除家庭的影响。有独立的思考了，就要慢慢消除教育的影响。离开了熟悉的环境，就要慢慢消除文化的影响。保持一个open的心态，不断质疑以前形成的思维定势，才能走出去，走的远。</p>

<hr />

<p>  此贴持续更新，毕竟还有四到五轮的刮治，每轮又要分多次，之后如果做牙周手术，又有得受了。立贴为记录吧。</p>

<p>  今天才注意到北大口腔的字还是老江题的。联想到今天疼爽了的经历，真是excited啊</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/excited.png"></p>

<hr />

<p>  第二次刮治，右上右下。倒是比第一次疼痛减轻多了，不过上次刮治之后都是臼齿吃饭，这下吃饭比较成问题。另外麻药的持久感好强，感觉右半边脸好像不存在一样。</p>

<p>  下周继续。第一轮三次完成。大夫比较辛苦。</p>

<hr />

<p>  第一轮第三次结束，医生说好多了，至少肿退下去了。买了牙缝刷每天饭后刷，还是能刷出一些刷牙刷不到的东西。下次检查年后了，抽空去拔个智齿。</p>

<hr />

<p>  今天想去拔智齿。经历了这样的流程：感冒不能拔->周日好的差不多了->早晨没起来->7点半出发去北大口腔第三门诊->被告知外科不现场挂号只能预约->北医三院，屏幕直接显示没号->海淀医院，被告知没号->中关村医院，成功挂号，拔牙医生只有周一到周六在->回，over。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在命令行使用Shadowsocks翻墙]]></title>
    <link href="http://cxh.me/2015/01/30/use-shadowsocks-in-terminal/"/>
    <updated>2015-01-30T18:13:00+08:00</updated>
    <id>http://cxh.me/2015/01/30/use-shadowsocks-in-terminal</id>
    <content type="html"><![CDATA[<p>  拜GFW所赐，连tm boot2docker都连接不上了。好在有shadowsocks的服务，可以转成http proxy给命令行使用。</p>

<p>  首先安装<a href="http://www.privoxy.org/" title="Privoxy">privoxy</a>。Linux下直接<code>apt-get install proxy</code>，然后编辑配置文件（etc/privoxy/config)：</p>

<pre><code>forward-socks5   /               127.0.0.1:1080 .
listen-address  localhost:8118
#local network do not use proxy
forward         192.168.*.*/     .
forward            10.*.*.*/     .
forward           127.*.*.*/     .
</code></pre>

<p>  基本上上这两项就可以了。之后在shell配置下代理，详见<a href="http://cxh.me/2015/01/11/linux-proxy-setup/" title="通过搭建代理来共享网络">参考文献2</a>：</p>

<pre><code>export http_proxy='http://127.0.0.1:8118'
export https_proxy='http://127.0.0.1:8118'
</code></pre>

<p>  最后chkconfig设置下开机启动。Mac下略微麻烦一些。主要是配置开机启动。详见<a href="http://blog.devtang.com/blog/2012/12/08/use-privoxy/" title="使用Privoxy做智能代理切换">参考文献3</a>。至于Mac下的Shadowsocks，还是ShadowsocksX比较方便，跟Linux下一样，都是会在1080启动监听。</p>

<h3>Bibliography:</h3>

<blockquote><p>[1] Privoxy, <a href="http://www.privoxy.org/">http://www.privoxy.org/</a></p>

<p>[2] 通过搭建代理来共享网络, <a href="http://cxh.me/2015/01/11/linux-proxy-setup/">http://cxh.me/2015/01/11/linux-proxy-setup/</a></p>

<p>[3] 使用Privoxy做智能代理切换, <a href="http://blog.devtang.com/blog/2012/12/08/use-privoxy/">http://blog.devtang.com/blog/2012/12/08/use-privoxy/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 中相等的比较]]></title>
    <link href="http://cxh.me/2015/01/29/java-compare-strategy/"/>
    <updated>2015-01-29T20:42:00+08:00</updated>
    <id>http://cxh.me/2015/01/29/java-compare-strategy</id>
    <content type="html"><![CDATA[<p>  遇到如下一个问题，java中使用复杂类型做Hashkey的时候，构造另一个值相同的对象作为key无法获取map的value。原因其实是java的==判断的依据是两个引用是否指向了同一个对象。实际调用了hashCode函数。内置对象的逻辑相等比较需要使用equals，比如String。而对于非内置对象，equals也同样调用了hashCode来判断相等。</p>

<p>  所以对于需要逻辑相等判断的对象，需要override两个函数，比如如下一个getkey的类定义了如何从Map中根据path和type得到一个唯一的对象：</p>

<p>  class ZkEventKey {</p>

<pre><code>    EventType type = null;
    String path = null;

    ZkEventKey(EventType type, String path) {
        super();
        this.type = type;
        this.path = path;
    }

    EventType getType() {
        return type;
    }

    String getPath() {
        return path;
    }

    @Override
    public String toString() {
        return "ZkEventKey [type=" + type + ", path=" + path + "]";
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj){
            return true;
        }else if (obj == null){
            return false;
        }
        if (getClass() != obj.getClass()){
            return false;
        }
        ZkEventKey other = (ZkEventKey)obj;
        if(type == other.type &amp;&amp; path.equals(other.path)){
            return true;
        }
        return false;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + type.hashCode(); 
        result = prime * result + path.hashCode(); 
        return result;
    }
}
</code></pre>

<p>  hashCode取31是一个统计的结论，在接近2<sup>x</sup>的质数下，散列冲突最小。没有看到过证明。</p>

<!--more-->


<p>  测试如下，value用String代替了。</p>

<pre><code>public void Test(){
    Map&lt;ZkEventKey, String&gt; map = new ConcurrentHashMap&lt;TestMap.ZkEventKey, String&gt;();
    ZkEventKey key1 = new ZkEventKey(EventType.NodeChildrenChanged, "/ua_server");
    ZkEventKey key2 = new ZkEventKey(EventType.NodeChildrenChanged, "/ua_server");
    map.put(key1, "Test Value");
    System.out.println(key1.equals(key2));
    System.out.println(map.get(key2));
}

结果：
true
Test Value
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eclipse多命令行窗口]]></title>
    <link href="http://cxh.me/2015/01/29/eclipse-multi-console/"/>
    <updated>2015-01-29T20:41:00+08:00</updated>
    <id>http://cxh.me/2015/01/29/eclipse-multi-console</id>
    <content type="html"><![CDATA[<p>   有时候需要在eclipse中同时运行客户端程序和服务器程序，开始都是一个在eclipse里面运行，另一个在命令行单独启动，未免不方便。后来发现，其实可以直接在eclipse中运行两次。调试视图会有两个显示，同时新建一个console窗口，关联另一个实例的显示就可以同时监视两个程序的输出了。</p>

<p>   <img class="img-polaroid center" src="http://cxh.me/images/2015/eclipse_instance.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协变返回类型]]></title>
    <link href="http://cxh.me/2015/01/27/convariant-return-type/"/>
    <updated>2015-01-27T15:48:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/convariant-return-type</id>
    <content type="html"><![CDATA[<p>  协变返回类型（Convariant Return Type）是指override的函数，返回值有继承关系（子类函数返回类型是父类返回类型的子类）。例子如下：</p>

<!--more-->


<pre><code>class Base
{
  public:
    Base (){}
    virtual void print(){
      printf("Base");
    }
};

class Derived : public Base
{
  public:
    Derived(){}
    virtual ~Derived (){}
    void print(){
      printf("Derived");
    }
};

class TestBase
{
  public:
    TestBase (){}
    virtual Base* getObject(){
      return new Base();
    }
};

class TestDerived : public TestBase
{
  public:
    TestDerived (){}
    virtual ~TestDerived (){}
    Derived* getObject(){
      printf("invoke here\n");
      return new Derived;
    }
};

int main(int argc, const char *argv[])
{
  TestBase * base = new TestDerived();
  Base* b = base-&gt;getObject();
  b-&gt;print();
  return 0;
}

结果：
invoke here
Derived
</code></pre>

<p>  java同理，只不过验证起来比较容易。直接打印对象就行。</p>

<pre><code>public class BaseClass {
}
public class DerivedClass extends BaseClass{
}

public class TestBase {
    public BaseClass getObject(){
        return new BaseClass();
    }
}

public class TestDerived extends TestBase{
    public DerivedClass getObject(){
        return new DerivedClass();
    }
    public static void main(String[] args) {
        TestBase base = new TestDerived();
        System.out.println(base.getObject());
    }
}

返回值：
test.server.others.DerivedClass@5d1eb50b
</code></pre>

<p>  这里想验证的其实是返回引用是可以的。返回对象是不行的。java只有返回引用，所以都可以。可自行验证。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java和C++继承上的一点不同]]></title>
    <link href="http://cxh.me/2015/01/27/java-cpp-derive-difference/"/>
    <updated>2015-01-27T14:51:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/java-cpp-derive-difference</id>
    <content type="html"><![CDATA[<p>   之前没注意过这里：</p>

<p>   java继承的时候只会隐藏父类同名同类型的函数。C++直接隐藏了同名的所有函数，如下：</p>

<pre><code>public class BaseClass {
    public void Print(String str){
        System.out.println("String" + str);
    }
    public void Print(int num){
        System.out.println(num);
    }
}
public class TestDerived extends BaseClass {
    public void Print(String str) {
        System.out.println("String" + str);
    }
    public static void main(String[] args) {
        new TestDerived().Print(121);
    }
}
</code></pre>

<p>  输出结果是121</p>

<p>  而同样的实现C++中直接会找不到父类的函数。</p>

<!--more-->


<pre><code>#include &lt;stdio.h&gt;
class Base
{
  public:
    Base (){}
    void Print(const char* str);
    void Print(int num);
};
void Base::Print(const char* str)
{
  printf(str);
}
void Base::Print(int num)
{
  printf("%d", num);
}

class Derived : public Base
{
  public:
    Derived(){}
    void Print(const char* str);
};
void Derived::Print(const char* str)
{
  printf("%s", str);
}

int main(int argc, const char *argv[])
{
  Derived d;
  d.Print(11);
  return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用shadow socks翻墙]]></title>
    <link href="http://cxh.me/2015/01/26/shadow-socks-proxy/"/>
    <updated>2015-01-26T15:39:00+08:00</updated>
    <id>http://cxh.me/2015/01/26/shadow-socks-proxy</id>
    <content type="html"><![CDATA[<p>   拜GFW所赐，连tm boot2docker都连接不上了。而且最近红杏抽风，遂决定买<a href="https://portal.shadowsocks.com/aff.php?aff=483" title="shadow socks">shadowsocks</a>服务翻墙。服务直接在官网购买，90一年，比红杏略便宜一点，主要还是可控性比较大，因为是socks5的代理。</p>

<p>  <a href="https://portal.shadowsocks.com/aff.php?aff=483" title="shadow socks">这里</a>购买服务，一年99，这个优惠码可以再打一点折<code>imouto985</code>。之后进入后台可以看到分配给自己的密码，服务器主要是日本，美国和新加坡的，实测貌似日本的响应更快一点。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2015/shadow_mac.png"></p>

<p>  mac下下载了客户端直接打开配置好地址就能用，linux下需要自己配置代理。</p>

<p>  首先下载安装node.js</p>

<pre><code>wget http://nodejs.org/dist/v0.10.35/node-v0.10.35.tar.gz
tar zxvf node-v0.10.35.tar.gz 
cd node-v0.10.35
./configure &amp;&amp; make 
sudo make install
</code></pre>

<p>  然后安装npm和shadowsocks</p>

<pre><code>sudo apt-get install npm
sudo apt-get install shadowsocks
</code></pre>

<p>  apt-get安装的nodejs好像有问题，所以用源码安装。编辑配置文件，默认是<code>/usr/local/lib/node_modules/shadowsocks/config.json</code>，启动之后就可以连上服务器了。</p>

<p>  之后需要配置proxy。以chrome为例，如果之前配置过goagent的话，基本配置一样。不过proxy switch sharp终于升级到了proxy switch omega了。需要注意的是shadowsocks是socks代理，选择的时候不要选择http。gfwlist 可用如下：</p>

<pre><code>https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt
</code></pre>

<p>  之后就可以翻墙了。最后说一句：<strong>Fxxk GFW，祝病魔早日战胜方校长，所有参与GFW的人都将钉在历史的耻辱柱上</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java中重用对象的bug]]></title>
    <link href="http://cxh.me/2015/01/23/java-reuse-bug/"/>
    <updated>2015-01-23T11:15:00+08:00</updated>
    <id>http://cxh.me/2015/01/23/java-reuse-bug</id>
    <content type="html"><![CDATA[<p>  首先这不是java编译器的问题，就是写代码的时候大意了。</p>

<p>  有这样一个函数</p>

<pre><code>int parse(String msg, Message out)；
</code></pre>

<p>  解析一个String，返回一个结构体。这么做的目的主要是避开try catch的性能问题，通过返回码来处理异常。这里就很容易出现这样的用法了：</p>

<pre><code>Message msg = new Message();
for (xxxx){
    if (0 == parse(str, msg))

}
</code></pre>

<p>  当时觉得还挺好，复用了一个对象。实际明显有问题的，这个对象的生命周期不见得只在for循环内部，一旦引用被传递出去，就会有悬挂（java里是不是不这么叫）的问题。多个引用指向了一个对象，计算结果是不可预测的。</p>

<p>  主要问题是java里面默认都是传引用的，所以要时刻保持对gc机制的警惕。或者直接实现clone接口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash下模拟group by功能]]></title>
    <link href="http://cxh.me/2015/01/22/simulate-group-by-in-bash/"/>
    <updated>2015-01-22T15:56:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/simulate-group-by-in-bash</id>
    <content type="html"><![CDATA[<p>  遇到这样一个问题：有一堆数据，需要统计相同key下相同的column的重复出现次数，实际上就是数据库里面的group by功能，但是建表导入然后计算未免麻烦，何况数据是临时数据，导入计算完毕之后就不需要了。这里用shell下的一些命令来完成。</p>

<p>  数据格式</p>

<pre><code>user            tag_id  type        time
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    EXPOSURE    2015:13:37:16
</code></pre>

<p>  目的：</p>

<pre><code>统计同一个用户下，同一个tag的点击次数：
</code></pre>

<p>  实现如下：</p>

<ol>
<li><p> 排序</p>

<p>首先对数据进行排序。这是最基本的，见<a href="http://cxh.me/2015/01/22/sort-using-multiple-columns/" title="Sort多列排序">上篇文章</a>。</p>

<pre><code>sort -k 1 
</code></pre></li>
<li><p> 过滤不需要的行和列。</p>

<pre><code>awk '{print $1, $2, $3}' |grep "Click" 
</code></pre></li>
<li><p> 这时候出现了一些重复列了，这也就是我们要做group by的数据。</p>

<pre><code>uniq -c | awk {'print $2, $3, $1'} 
</code></pre></li>
</ol>


<p>  后面awk只是调了一下位置。合并起来就是：</p>

<pre><code>sort -k 1  test.txt|awk '{print $1, $2, $3}' |grep "Click"|uniq -c | awk {'print $2, $3, $1'} 
</code></pre>

<p>  输出结果：</p>

<pre><code>AAAAAAAAAAA tag1 2
AAAAAAAAAAA tag2 1
BBBBBBBBBBB tag2 2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sort多列排序]]></title>
    <link href="http://cxh.me/2015/01/22/sort-using-multiple-columns/"/>
    <updated>2015-01-22T13:38:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/sort-using-multiple-columns</id>
    <content type="html"><![CDATA[<p>  遇到这样一个需求，希望按照第二列排序，第二列相同的情况下按照第一列排序，数据如下：</p>

<pre><code>b   2   c
c   2   b
a   1   b
</code></pre>

<p>  习惯性的用:</p>

<pre><code>sort -k 2 -k 1 input.txt
</code></pre>

<p>  输出结果是：</p>

<pre><code>a   1   b
c   2   b
b   2   c
</code></pre>

<p>  可以看到实际上先按照第二列排序，第二列相同按照第三列排序了。问题在于sort -k默认是按照顺序排序到末尾的。如果要打破默认，需要指定从哪个列到哪个列。</p>

<pre><code>sort -k 2，2 -k 1 input.txt
</code></pre>

<p>  换个角度说，<code>sort -k 1 -k 2</code> 的效果跟 <code>sort -k 1</code> 是一样的。所以最好还是让数据按照排序列生成，这样看起来也最直观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Django下获取checkbox的返回值]]></title>
    <link href="http://cxh.me/2015/01/19/django-checkbox/"/>
    <updated>2015-01-19T16:46:00+08:00</updated>
    <id>http://cxh.me/2015/01/19/django-checkbox</id>
    <content type="html"><![CDATA[<p>  HTML中我们可以在form中这样写复选框：</p>

<pre><code>&lt;form action="demo_form.asp"&gt;
  &lt;input type="checkbox" name="vehicle" value="Bike"&gt; I have a bike&lt;br&gt;
  &lt;input type="checkbox" name="vehicle" value="Car" checked&gt; I have a car&lt;br&gt;
  &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;
</code></pre>

<p>  但是作为服务端处理起来未免不变，尤其是checkbox list是自动生成的时候。此时可以用group方式把form value组合起来。如下：</p>

<pre><code>{\% for item in items \%}
    &lt;td&gt;&lt;input type="checkbox" name="selected_push[]" value=""&gt;&lt;/td&gt;
{\% endfor \%}
</code></pre>

<p>  服务端从命令行可以看到收到的post里面是有&#8217;selected_push[]&lsquo;变量的。但是直接get的结果只有一个。查阅stackoverflow发现RequestContext有单独的getlist函数来处理。果然还是跟PHP不一样啊。</p>
]]></content>
  </entry>
  
</feed>
