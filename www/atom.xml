<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-07-06T18:24:17+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[发一张喵星人的照片]]></title>
    <link href="http://cxh.me/2014/07/06/photo-of-cat/"/>
    <updated>2014-07-06T18:18:00+08:00</updated>
    <id>http://cxh.me/2014/07/06/photo-of-cat</id>
    <content type="html"><![CDATA[<p>  发一张喵星人的照片：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/cat.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[undo 日志和redo 日志]]></title>
    <link href="http://cxh.me/2014/07/05/redo-undo-log/"/>
    <updated>2014-07-05T21:20:00+08:00</updated>
    <id>http://cxh.me/2014/07/05/redo-undo-log</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="http://cxh.me/images/2014/interesting.gif" title="贴张图" alt="贴张图"><p class="align-center">贴张图</p></p>

<p>  具体的可以看<a href="http://blog.csdn.net/ggxxkkll/article/details/7616739" title="数据库日志文件-- undo log 、redo log、 undo/redo log">这里</a>，解释几个作者没解释清楚的问题：</p>

<ol>
<li><p>只用REDO日志为什么数据修改要每次修改刷盘</p>

<p> 如果不刷盘，不会导致数据不一致，但是数据修改过程相当于写redo日志-修改内存-写commit日志（修改内存的顺序也无所谓了），这个过程结束已经应答用户了，但是修改没有刷下去断电恢复的话也无法通过redolog恢复到当前状态，所以会丢失修改。</p></li>
<li><p>修改数据和写redo/undo log/commit log之间的关系是什么</p>

<p> 任何对磁盘的数据修改落实之前都需要先写log，无论是redo还是undo。undo保证了一旦数据写了一半（脏数据）能够回滚，redo保证了写了日志的事务能够回放出来。</p>

<p> 只使用undo的时候commit日志要等待刷盘成功，写了commit的事务不会再回滚。</p>

<p> 只使用redo的时候需要先写commit日志再修改缓冲区，因为数据有刷盘和不刷盘的可能，写完commit日志意味着修改已经完整记录下来了不会丢失。否则，没有commit的日志不会回放，如果之前修改数据并刷盘了，系统不知道处于哪个阶段：写了一半的log？写成功log?修改了一半数据？成功修改全部数据？。<del>如果修改不刷盘，那么如果在修改数据阶段宕机，就丢失了此条本来可以写成功的数据，好在这时候也没有回复用户。</del>确保数据不刷盘的情况下，是可以先修改缓冲区再写commit日志的。</p>

<p> <del>其实redo log + commit log写成功就可以回复用户了啊，异步修改数据好了。至少能保证不丢失。不过万一修改失败了或者这时候有读取怎么办&hellip;</del></p></li>
<li><p>只使用redo日志的时候checkpoint为什么不能直接刷盘</p>

<p> 如果只使用redo日志，而且修改顺序是写redo日志-写commit日志-修改缓冲区，那么缓冲区是可以在checkpoint的时候刷下去的，因为下次回放的时候已经有了redo日志和commit标记，可以回放覆盖之前的脏数据，问题在于如果这个事务被回滚了，只有redo日志是不能做回滚操作的。如果使用redo-undo log那么可以直接把脏数据刷盘。</p></li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] 数据库日志文件&mdash; undo log 、redo log、 undo/redo log, <a href="http://blog.csdn.net/ggxxkkll/article/details/7616739">http://blog.csdn.net/ggxxkkll/article/details/7616739</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发两张静物]]></title>
    <link href="http://cxh.me/2014/07/05/two-photo-of-still-life/"/>
    <updated>2014-07-05T19:49:00+08:00</updated>
    <id>http://cxh.me/2014/07/05/two-photo-of-still-life</id>
    <content type="html"><![CDATA[<p>  发两张静物，镜头宾得 SMC FA 50mm F1.4</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/grass.jpg"></p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/windmill.jpg"></p>

<p>  转一张网上的图，我觉得拍的极好（当然模特漂亮是主要的）：</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/fromweb.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于备份文件管理]]></title>
    <link href="http://cxh.me/2014/07/04/backup-file-management/"/>
    <updated>2014-07-04T11:20:00+08:00</updated>
    <id>http://cxh.me/2014/07/04/backup-file-management</id>
    <content type="html"><![CDATA[<p>  最近在写一个备份的工作，备份线程每次会把需要备份的数据写到文件，同时需要保存一定数量的旧文件。</p>

<p>  首先为了写失败的时候不会损坏之前的旧备份文件，我们需要写一个临时文件然后覆盖回去。同时，为了保存旧文件，需要每次写一个不同的文件，同时维护一个当前的最新文件，然后删除超过了一定期限的文件，假定临时文件名是file.bin.2014xxxx，最新文件名是file.bin，有如下三个方法：</p>

<ol>
<li> 每次写临时文件，同时写一个内容一样的file.bin。造成空间浪费。</li>
<li> 每次写临时文件，同时更新软链接file.bin。不兼容非linux系统。</li>
<li> 写manifest，文件内容是当前最新文件名。比较麻烦。</li>
</ol>


<p>  最后还是按2方案实现的，代码如下：</p>

<!--more-->


<pre><code>int overwrite_tmp_file(const char * filename, const int64_t version)
{
  char tmp_path[OB_MAX_FILE_NAME_LENGTH] ={'\0'};
  int ret = OB_SUCCESS;
  if (filename == NULL)
  {
    ret = OB_INVALID_ARGUMENT;
  }
  else
  {
    char time_str[OB_MAX_TIME_STR_LENGTH] = {'\0'};
    tbsys::CTimeUtil::timeToStr(ObTimeUtility::extract_second(version), time_str);
    int len = snprintf(tmp_path, sizeof(tmp_path), "%s.%s", filename, time_str);
    if (0 &gt; len || len &gt;= static_cast&lt;int32_t&gt;(sizeof(tmp_path)))
    {
      ret = OB_ERR_UNEXPECTED;
      TBSYS_LOG(WARN, "No file name specified!");
    }
    else
    {
      struct stat buf;
      if (0 == lstat(filename, &amp;buf))
      {
        if (0 != ::unlink(filename))
        {
          TBSYS_LOG(WARN, "fail to remove old file, msg: [%s]", strerror(errno));
          ret = OB_ERR_SYS;
        }
      }
      if (OB_SUCCESS == ret)
      {
        if (0 != ::symlink(basename(tmp_path), filename))
        {
          TBSYS_LOG(WARN, "fail to link backup file, msg: [%s]", strerror(errno));
          ret = OB_ERR_SYS;
        }
        else if (OB_SUCCESS != clean_old_files(filename))//do not need to return error
        {
          TBSYS_LOG(WARN, "failed to remove old files");
        }
      }
    }
  }
  return ret;
}


const static int64_t KEEP_FILE_RANGE = 3600 * 24 * 7;//7d,unit:s

int clean_old_files(const char * filename)
{
  int ret = OB_SUCCESS;
  if (filename == NULL)
  {
    ret = OB_INVALID_ARGUMENT;
  }
  else
  {
    char tmp_path[OB_MAX_FILE_NAME_LENGTH] ={'\0'};
    glob_t globbuf;
    globbuf.gl_offs = 0;
    int len = snprintf(tmp_path, sizeof(tmp_path), "%s.*", filename);
    if (len &lt; 0 || len &gt;= static_cast&lt;int32_t&gt;(sizeof(tmp_path)))
    {
      ret = OB_ERR_UNEXPECTED;
    }
    else if (0 != glob(tmp_path, GLOB_DOOFFS, NULL, &amp;globbuf))
    {
      ret = OB_ERR_SYS;
    }
    else
    {
      int64_t cur_time = ObTimeUtility::extract_second(tbsys::CTimeUtil::getTime());
      for(unsigned int i = 0; i &lt; globbuf.gl_pathc; ++i)
      {
        int64_t version = tbsys::CTimeUtil::strToTime(globbuf.gl_pathv[i] + strlen(filename) + 1);
        if (cur_time - version &gt; KEEP_FILE_RANGE)
        {
          //delete file
          if (0 != unlink(globbuf.gl_pathv[i]))
          {
            TBSYS_LOG(WARN, "fail to remove old file, msg: [%s]", strerror(errno));
          }
        }
      }
    }
    globfree(&amp;globbuf);
  }
  return ret;
}
</code></pre>

<p>  需要注意的大概只有软连接文件属性获取是lstat而不是stat。另外，由于子文件夹的存在，建立软链接的symlink参数需要指定相对路径，也就是说，如果我们要让etc目录下的file.bin指向file.bin.2014xxxx，需要：</p>

<pre><code>ln -s file.bin etc/file.bin.2014xxx
</code></pre>

<p>  而不是</p>

<pre><code>ln -s etc/file.bin etc/file.bin.2014xxx  
</code></pre>

<p>  上面会导致链接文件指向etc/etc/file.bin.2014xxx而失效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跟事务相关的一些文章]]></title>
    <link href="http://cxh.me/2014/07/02/article-on-transaction/"/>
    <updated>2014-07-02T16:45:00+08:00</updated>
    <id>http://cxh.me/2014/07/02/article-on-transaction</id>
    <content type="html"><![CDATA[<p>  主要纪录一下跟事务相关的一些文章。主要是博客，有论文加论文。顺便纪念下女神订婚。图是转载。</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/tangwei.jpg"></p>

<h3>参考文献:</h3>

<blockquote><p>[1] 数据库事务隔离级别和锁实现机制, <a href="http://comedsh.iteye.com/blog/698733">http://comedsh.iteye.com/blog/698733</a></p>

<p>[2] 数据库事务的实现（一） 故障恢复 （undo日志）, <a href="http://www.cnblogs.com/clam/archive/2012/08/27/2657943.html">http://www.cnblogs.com/clam/archive/2012/08/27/2657943.html</a></p>

<p>[3] 数据库事务的实现-故障恢复（二）（undo日志检查点）, <a href="http://www.cnblogs.com/clam/archive/2012/08/27/2657944.html">http://www.cnblogs.com/clam/archive/2012/08/27/2657944.html</a></p>

<p>[4] 为 Key-Value 数据库实现MVCC 事务, <a href="http://juliashine.com/implementation-of-mvcc-transactions-for-key-value-stores/">http://juliashine.com/implementation-of-mvcc-transactions-for-key-value-stores/</a></p>

<p>[5] 数据库日志文件&mdash; undo log 、redo log、 undo/redo log, <a href="http://blog.csdn.net/ggxxkkll/article/details/7616739">http://blog.csdn.net/ggxxkkll/article/details/7616739</a></p>

<p>[6] 两阶段提交-2PC, <a href="http://blog.csdn.net/ggxxkkll/article/details/7631545">http://blog.csdn.net/ggxxkkll/article/details/7631545</a></p>

<p>[7] 分布式系统的事务处理, <a href="http://coolshell.cn/articles/10910.html">http://coolshell.cn/articles/10910.html</a></p>

<p>[8] 两阶段提交(2PC)协议&#8221; , <a href="http://blog.chinaunix.net/uid-20761674-id-75164.html">http://blog.chinaunix.net/uid-20761674-id-75164.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试一张静物]]></title>
    <link href="http://cxh.me/2014/07/01/photo-of-a-cup/"/>
    <updated>2014-07-01T19:44:00+08:00</updated>
    <id>http://cxh.me/2014/07/01/photo-of-a-cup</id>
    <content type="html"><![CDATA[<p>  测试一张静物：宾得 SMC FA 50mm F1.4， 光圈2.0 快门 1/60</p>

<p>  <img class="img-polaroid center" src="http://cxh.me/images/2014/cup.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NVI的应用-虚函数模板]]></title>
    <link href="http://cxh.me/2014/07/01/nvi-usage-of-virtual-template/"/>
    <updated>2014-07-01T14:52:00+08:00</updated>
    <id>http://cxh.me/2014/07/01/nvi-usage-of-virtual-template</id>
    <content type="html"><![CDATA[<p>  我们有时候需要把一个模板函数实现为虚函数，但是C++不支持模板虚函数（至少目前是），所以需要一些方法绕过去。以下是郁白师兄提供的解决方案，确实比较巧妙，之前没想过NVI（NonVirtual Interface）能解决这个问题。</p>

<pre><code>class IAllocator
{
  public:
    virtual ~IAllocator() {};
    virtual void *alloc(const int64_t size) = 0;
};
template &lt;class T&gt;
class TAllocator : public IAllocator
{
  public:
    TAllocator(T &amp;allocator) : allocator_(allocator) {};
    void *alloc(const int64_t size) {return allocator_.alloc(size);};
  private:
    T &amp;allocator_;
};

class Base
{
  public:
    virtual ~Base() {};
  public:
    template &lt;class Allocator&gt;
    void get_number(Allocator &amp;allocator)
    {
      TAllocator&lt;Allocator&gt; ta(allocator);
      this-&gt;get_number_(ta);
    };
  private:
    virtual void get_number_(IAllocator &amp;allocator) = 0;
};

class Sub1 : public Base
{
  private:
    void get_number_(IAllocator &amp;allocator)
    {
      allocator.alloc(1);
      fprintf(stdout, "sub1::get_number_ invoked\n");
    };
};

class Sub2 : public Base
{
  private:
    void get_number_(IAllocator &amp;allocator)
    {
      allocator.alloc(1);
      fprintf(stdout, "sub2::get_number_ invoked\n");
    };
};

class PA
{
  public:
    void *alloc(const int64_t sz)
    {
      fprintf(stdout, "pa::alloc sz=%ld\n", sz);
      return NULL;
    };
};

int main()
{
  Sub1 s1;
  Sub2 s2;
  PA pa;

  s1.get_number(pa);
  s2.get_number(pa);
}
</code></pre>

<p>  主要思想是把模板特化，特化之后的函数实现虚函数，把模板遵循的规则转化到继承体系，让一个实例化的模板参数遵循Interface的接口要求。所以TAllocator这个Wrapper至关重要。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 【C++程序设计技巧】NVI（Non-Virtual Interface ）, <a href="http://www.cnblogs.com/gnuhpc/archive/2012/01/17/2324836.html">http://www.cnblogs.com/gnuhpc/archive/2012/01/17/2324836.html</a></p>

<p>[2] 纯虚函数能为private吗？, <a href="http://www.cppblog.com/zhuweisky/archive/2005/09/14/269.html">http://www.cppblog.com/zhuweisky/archive/2005/09/14/269.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[github/gitcafe pages域名设置]]></title>
    <link href="http://cxh.me/2014/06/28/gitcafe-github-domain-config/"/>
    <updated>2014-06-28T18:17:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/gitcafe-github-domain-config</id>
    <content type="html"><![CDATA[<h3>A纪录和CNAME</h3>

<p>  裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。引用自参考文献<a href="http://www.zhihu.com/question/20414602" title="为什么越来越多的网站域名不加www了？">1</a></p>

<h3>gitcafe pages 域名配置</h3>

<pre><code>  example.com.          1684    IN  A   117.79.146.98

  www.example.com.      3581    IN  CNAME   example.gitcafe.com.
  example.gitcafe.com. 560  IN  A   117.79.146.98
</code></pre>

<p>  gitcafe文档说：</p>

<p>  如果你想绑定 www 子域名, 你需要将此 www 子域名添加到自定义域名里, 然后在你的域名管理页面增加一条 A 记录, 将它指向 GitCafe 服务器的 IP 地址 117.79.146.98</p>

<!--more-->


<h3>github pages 域名配置</h3>

<pre><code>;example.com
example.com.   73  IN  A 192.30.252.153
example.com.   73  IN  A 192.30.252.154

www.example.com.   xxxx  IN  CNAME example.github.io.
example.github.io.  xxxx  IN  CNAME github.map.fastly.net.
github.map.fastly.net.  9 IN  A 103.245.222.133
</code></pre>

<p>  同时配置CNAME文件:</p>

<ul>
<li><p>If your CNAME file contains example.com, then www.example.com will redirect to example.com.</p></li>
<li><p>If your CNAME file contains www.example.com, then example.com will redirect to www.example.com.</p></li>
</ul>


<p>  也就是说如果同时配置了A纪录和CNAME，那么对www的访问会重定向到主域名，或者主域名的访问重定向到www。本质上是301 redirect。</p>

<h3>dig和nslookup</h3>

<pre><code>dig www.example.com +nostats +nocomments +nocmd
nslookup 详见参考文献[2][2]
</code></pre>

<h3>参考文献:</h3>

<blockquote><p>[1] 为什么越来越多的网站域名不加www了？, <a href="http://www.zhihu.com/question/20414602">http://www.zhihu.com/question/20414602</a></p>

<p>[2] 常用域名记录解释：A记录、MX记录、CNAME记录、TXT记录、AAAA记录、NS记录, <a href="http://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html">http://www.ezloo.com/2011/04/a_mx_cname_txt_aaaa_ns.html</a></p>

<p>[3] Tips for configuring a CNAME record with your DNS provider, <a href="https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider">https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于一个配置项的设计]]></title>
    <link href="http://cxh.me/2014/06/28/a-desgin-problem-of-config/"/>
    <updated>2014-06-28T16:27:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/a-desgin-problem-of-config</id>
    <content type="html"><![CDATA[<p>  有个需求需要配置每张表的备份SQL语句，我开始想实现如下的效果：</p>

<pre><code>struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};

struct TableBackupTransaction
{
  static const int OB_MAX_SQL_PER_TRANS = 5;
  TableBackupSQL sql_list_[OB_MAX_SQL_PER_TRANS];
};


TableBackupTransaction table_backup_list_[] =
{
  {
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
  },
  {
    TableBackupSQL(1, "name", "select * from cs")
  }
};
</code></pre>

<p>  然后用宏美化一下就成这样了：</p>

<!--more-->


<pre><code>#define TABLE_BACKUP_SINGLE(table_prefix, sql)\
  { TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, sql) }
#define TABLE_BACKUP(table_prefix, sql)\
   TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, sql)
#define TABLE_BACKUP_MULTIPLE

ObInnerTableBackupGuard::TableBackupSQL ObInnerTableBackupGuard::table_backup_list_[][MAX_SQL_PER_TRANS] =
{
  TABLE_BACKUP_SINGLE(OB_FIRST_ROOT_TABLE, "select * from %s"),

  TABLE_BACKUP_MULTIPLE
  {
    TABLE_BACKUP(OB_ALL_TABLE, "select * from %s"),
    TABLE_BACKUP(OB_ALL_COLUMN, "select * from %s"),
    TABLE_BACKUP(OB_ALL_JOIN_INFO, "select * from %s"),
    TABLE_BACKUP(OB_ALL_DDL_OPERATION, "select max(schema_version) from %s "),
  },

  TABLE_BACKUP_SINGLE(OB_ALL_SYS_STAT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SYS_PARAM, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_USER, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_TABLE_PRIVILEGE,  "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_CLUSTER, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_TRIGGER_EVENT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_CLIENT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SYS_CONFIG,"select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SYS_CONFIG_STAT, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_SERVER, "select * from %s"),
  TABLE_BACKUP_SINGLE(OB_ALL_CLUSTER_STAT, "select * from %s")
};
</code></pre>

<p>  无奈想法很美好，实际上行不通，至少不开C++11新特性的情况下，不允许这样初始化，退而求其次：</p>

<pre><code>struct TableBackupTransaction
{
  static const int OB_MAX_SQL_PER_TRANS = 5;
  int sql_count_;
  TableBackupSQL sql_list_[OB_MAX_SQL_PER_TRANS];
  TableBackupTransaction(const TableBackupSQL * sql_list, int count)
  {
    //assert, length sql_list
    for(int i = 0; i &lt; count; i++)
    {
      sql_list_[i] = sql_list[i];
    }//or memcpy
    sql_count_ = count;
  }
  TableBackupTransaction(const TableBackupSQL &amp; sql_list)
  {
    sql_list_[0] = sql_list;
    sql_count_ = 1;
  }
};

TableBackupTransaction table_backup_list_[] =
{
  TableBackupTransaction({
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
  }),
  TableBackupTransaction({
    TableBackupSQL(1, "name", "select * from cs")
  })
};
</code></pre>

<p>  多了一次复制，但是初始化列表{a,b,c&hellip;}在不开C++11的时候不能作为函数参数传递，只能这样</p>

<pre><code>TableBackupSQL table_backup_[] =
{
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
};
TableBackupTransaction table_backup_list_[] =
{
  TableBackupTransaction(table_backup_, sizeof(table_backup_)/sizeof(TableBackupSQL)),
  TableBackupTransaction(TableBackupSQL(1, "name", "select * from cs"))
};
</code></pre>

<p>  弱爆了，最后改成二位数组好了：</p>

<pre><code>struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
  bool is_valid() const
  {
    return sql_ != NULL &amp;&amp; table_name_ != NULL &amp;&amp; table_id_ != OB_INVALID_ID;
  }
};

TableBackupSQL table_backup_list_[][5] =
{
  {
    TableBackupSQL(1, "name", "select * from cs"),
    TableBackupSQL(2, "name2", "select 2* from cs")
  },
  {
    TableBackupSQL(1, "name", "select * from cs")
  }
};
</code></pre>

<p>  只不过二维数组每个维度只是数组，没有额外的信息，不能扩展，访问只能这样：</p>

<pre><code>int main(void)
{
  TableBackupSQL (*trans)[5] = table_backup_list_;
  for (int i = 0; i &lt; sizeof(table_backup_list_)/(sizeof(TableBackupSQL)*5); i++, trans++)
  {
    for (int j = 0; j &lt; 5; j++)
    {
      const TableBackupSQL&amp; desc = *trans[j];
      if (!desc.is_valid())
      {
        break;
      }
      printf("%d, %d: %d, %s, %s\n",i ,j , desc.table_id_, desc.table_name_, desc.sql_);
    }
  }
}
</code></pre>

<p>或者</p>

<pre><code>int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/(sizeof(TableBackupSQL)*5); i++)
  {
    const TableBackupSQL (&amp;trans)[5] = table_backup_list_[i];
    for (int j = 0; j &lt; 5; j++)
    {
      const TableBackupSQL desc = trans[j];
      if (!desc.is_valid())
      {
        break;
      }
      printf("%d, %d: %d, %s, %s\n",i ,j , desc.table_id_, desc.table_name_, desc.sql_);
    }
  }
}
</code></pre>

<p>  弱爆了&hellip;.所以我最后决定把Transaction和单条事务直接分开了&hellip;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同步github上的项目到gitcafe]]></title>
    <link href="http://cxh.me/2014/06/28/gitsync-github-gitcafe/"/>
    <updated>2014-06-28T12:41:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/gitsync-github-gitcafe</id>
    <content type="html"><![CDATA[<p>  github固然好，只是国内访问有点慢。为了提高博客访问速度我决定把github上托管的博客同步到gitcafe上。最好能在DNS那里做CDN，但是貌似没有免费的服务。那直接指向gitcafe好了，反正没有什么国外访问的需求。简单记一下过程。</p>

<p>  gitcafe自己有导入的功能，但是貌似不是很好用。而且不够智能。所以我们先建立一个跟用户名一样的目录。gitcafe只允许这种方式的Html页面生成。并且只渲染gitcafe-pages分支。</p>

<p>  我们修改source分支.git/config加入</p>

<pre><code>[remote "cafe"]
  url = git@gitcafe.com:xxx/xxx.git
  fetch = +refs/heads/*:refs/remotes/cafe/*
</code></pre>

<p>  由于</p>

<pre><code>[branch "source"]
  remote = origin
  merge = refs/heads/source
</code></pre>

<p>  所以当前source分支（这下面我没有master）默认提交到origin（github)，所以我们通过</p>

<pre><code>git push cafe
</code></pre>

<p>  提交source，会被扩展成：</p>

<pre><code>git push cafe source:source "当前分支
</code></pre>

<p>  然后提交<em>deploy，这是渲染之后的html页面，前面那个是octopress的源码。修改</em>deploy/.git/config</p>

<pre><code>[remote "cafe"]
  url = git@gitcafe.com:chenxiaohui/chenxiaohui.git
  fetch = +refs/heads/*:refs/remotes/cafe/*
</code></pre>

<p>  然后提交:</p>

<pre><code>git push cafe master:gitcafe-pages
</code></pre>

<!--more-->


<p>  本地分支名字和远程分支不同的时候不能省略，否则会被自动扩展成相同的名字。这就是问题了，我们多了一个master分支&hellip;.</p>

<p>  按照gitcafe的教程删除master未果，不过顺便把默认分支改成了gitcafe-pages。删除master分支的时候，里面有一段说明：</p>

<pre><code>为什么要删除 master 分支
当你在创建一个新的仓库的时候没有指定分支的话，Git 会默认创建 master 分支并指定它为默认分支。

一般情况下使用 master 分支作为整个项目的核心分支是很普遍的行为， 而 Pages 服务之所以使用 gitcafe-pages 分支的方式区别项目文件和 Pages 文件。 这样你就可以在一个仓库中保存他们而且彼此不会有任何影响。

但是像是个人主页类的 Pages 服务或其他一些应用场合，可能并不需要 master 的存在， 甚至必须要删除它，或者只是你有洁癖┑(￣Д ￣)┍ 那么你就需要如下的方法来删除 master 分支。
</code></pre>

<p>  (#‵′)靠，就是这样。</p>

<p>  最后修改一下Rakefile</p>

<pre><code>...
    system "git push origin #{deploy_branch}"
    system "git push cafe #{deploy_branch}:gitcafe-pages"
    puts "\n## Github Pages deploy complete"
  end
...

  puts "\n## Pushing source"
  system "git push origin "
  system "git push cafe"
  puts "\n## Github source pushed"
</code></pre>

<p>  当然问题是同一个本地分支track了两个远程分支，但是默认值只能配置一个：</p>

<pre><code>[branch "master"]
    remote = cafe
    merge = refs/heads/gitcafe-pages
</code></pre>

<p>  这说明master分支上更新gitcafe必须指明repository，好在我们直接用git push/pull不带任何参数的时候不多。同时如果git pull的话，默认的merge两个repository是不同的，好在我们也一般不用从两个repository上面pull。</p>

<p>  顺便去挂一下域名就好了。</p>

<p>  矮马，快多了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git远程分支和refs文件详解]]></title>
    <link href="http://cxh.me/2014/06/28/git-remote-branch/"/>
    <updated>2014-06-28T11:14:00+08:00</updated>
    <id>http://cxh.me/2014/06/28/git-remote-branch</id>
    <content type="html"><![CDATA[<p>  最近同时同步博客到github和gitcafe上，遇到一些问题，我们分如下几个方面来分析一下：</p>

<h3>推送远程分支到同一个服务器</h3>

<p>  比如首先建立git服务器，顺便clone出两个副本</p>

<pre><code>mkdir server
cd server
git init --bare
cd ..
git clone server git1
git clone server git2
</code></pre>

<p>  目前git branch是空的。我们提交一点东西建立master分支。</p>

<pre><code>cd git1
touch a.txt
git add .
git commit -m "init"
git push origin master
</code></pre>

<p>  现在git branch -a 显示:</p>

<pre><code>* master
  remotes/origin/master
</code></pre>

<p>  当前系统处于master分支，远程origin的repository上也有一个master分支。两个是tracking的。我们切到git2下面</p>

<pre><code>cd ../git2
git pull origin
</code></pre>

<p>  这时候git2跟git1完全同步了。现在我们开始尝试建立另一个分支并推送到服务器。习惯的，我们还是切回git1</p>

<pre><code>cd ../git1
git checkout -b source
</code></pre>

<p>  这时候我们已经有了一个本地分支了，如果这个分支不需要共享，那么你可以一直在这个分支上commit但是不push到服务器，直到这个分支被合并回主分支或者丢弃。git branch 显示如下：</p>

<pre><code>  master
* source
</code></pre>

<!--more-->


<p>  我们最终决定把这个分支push到服务器上与其他人共享，如下：</p>

<pre><code>git push origin source:source
</code></pre>

<p>  这时候git branch -a 能看到当前repository里面所有的分支，包括两个本地的，两个远程的，本地和远程的都处于tracking状态。</p>

<pre><code>  master
* source
  remotes/origin/master
  remotes/origin/source
</code></pre>

<p>  切到另一个副本。</p>

<pre><code>cd ../git2
git pull origin
</code></pre>

<p>  显示如下：</p>

<pre><code> * [新分支]          source      -&gt; origin/source
</code></pre>

<p>  git branch -a显示本地已经有了一个远程分支的指针，但是没有tracking这个分支的本地分支：</p>

<pre><code>* master
  remotes/origin/master
  remotes/origin/source
</code></pre>

<p>  同样我们可以在.git/refs/remotes/origin下看到分支的名字，但是refs/heads下面并没有。我们来检出这个远程分支：</p>

<pre><code>git checkout -b source origin/source
</code></pre>

<p>  这时候git branch -a 显示就跟git1一致了。git2下也可以编辑source分支并同步。这些都是比较常见的操作，我们需要注意的是，多分支下默认的参数。比如，在两个分支都修改一点东西：</p>

<pre><code>cd ../git1
git checkout master
//modify 
git add .
git commit -m "master modify"
git checkout source
//modify
git add .
git commit -m "source modify"
</code></pre>

<p>  这时候git push origin 是针对当前分支的，所以两个分支同时push更新只能</p>

<pre><code>git push origin
git checkout master
git push origin
</code></pre>

<p>  pull更新的时候</p>

<pre><code>cd ../git2
git checkout master
git pull origin
</code></pre>

<p>  这会同时更新两个分支的指针，但是不会merge另一个分支，我们去另一个分支下</p>

<pre><code>git checkout source
git pull origin
</code></pre>

<p>  但是出错如下：</p>

<pre><code>You asked to pull from the remote 'origin', but did not specify
a branch. Because this is not the default configured remote
for your current branch, you must specify a branch on the command line.
</code></pre>

<p>  问题在于没有给当前分支配置merge的路径，git不知道去merge哪个分支。（<del>虽然我觉得既然是tracking的不应该不知道啊</del>）。</p>

<p>  如果你有 1.6.2 以上版本的 Git，&mdash;track 选项可以同时配置merge的路径：</p>

<pre><code>git checkout --track origin/serverfix
</code></pre>

<p>  这里我们修改配置文件加入branch &ldquo;source&#8221;：</p>

<pre><code>[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    logallrefupdates = true
[remote "origin"]
    url = /media/cxh/backup/work/ceshi/git/server
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master"这里指server上的refs/heads/master
[branch "source"]
    remote = origin
    merge = refs/heads/source
</code></pre>

<p>  这意味着每次fetch origin的时候更新所有remotes/origin的头指针到refs/heads/下面，具体可以去.git下查阅这个目录，但是头指针都是只读的。merge是由所在branch定义的。</p>

<p>  我们加了branch &ldquo;source&#8221;的配置指定当前source的merge策略是使用<strong>服务器端的</strong>refs/heads/source来合并到当前分支。这样就可以顺利的git pull origin了。</p>

<h3>推送远程分支到不同服务器</h3>

<p>  我们先建立新的repo：</p>

<pre><code>cd ..
mkdir server2
cd server2
git init --bare
</code></pre>

<p>  加入git1副本，并提交</p>

<pre><code>git remote add server xxx/server2
git push server
</code></pre>

<p>  上面过程的本质是提交当前分支头指针到server，相当于拷贝refs/head/xxx到refs/remotes/server/下并提交。git push server会被展开成</p>

<pre><code>git push server 当前分支名：当前分支名
</code></pre>

<p>  我们可以在git2副本同样加入该repository并更新引用</p>

<pre><code>git remote add server xxx/server2
git fetch server
</code></pre>

<p>  可以看到refs下目录结构如下：</p>

<pre><code>├── heads
│   ├── master
│   └── source
├── remotes
│   ├── origin
│   │   ├── master
│   │   └── source
│   └── server
│       └── source
└── tags
</code></pre>

<h3>总结一下</h3>

<ul>
<li><p>update</p>

<ul>
<li><p>fetch操作的本质是更新repo所指定远程分支的头指针(server->refs/remotes/xxx/)</p></li>
<li><p>merge操作的本质是合并当前分支和指定的头指针(refs/remotes/xxx->refs/heads)</p></li>
<li><p>pull操作的本质是fetch + merge</p></li>
</ul>
</li>
<li><p>commit</p>

<ul>
<li><p>commit的本质是修改了当前分支的头指针(refs/heads)</p></li>
<li><p>push操作本质是提交当前分支头指针到server，顺便也修改了本地存储的server头指针(refs/remotes/xxx)</p></li>
</ul>
</li>
<li><p>checkout</p>

<ul>
<li><p>复制本地分支的本质是拷贝了refs/heads/下的一个头指针</p></li>
<li><p>push本地分支到server的本质是把这个头指针上传服务器，顺便拷贝了本地存储的server头指针（refs/remotes/xxx)</p></li>
<li><p>tracking远程分支的本质是把refs/remotes/下的指针拷贝到了refs/heads下</p></li>
</ul>
</li>
</ul>


<blockquote><p>注：以上过程都没有涉及数据流。</p></blockquote>

<h3>参考文献:</h3>

<blockquote><p>[1] Git 分支 &ndash; 远程分支, <a href="http://git-scm.com/book/zh/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">http://git-scm.com/book/zh/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF</a></p>

<p>[2] The Configuration File – “Branch” Section, <a href="http://www.gitguys.com/topics/the-configuration-file-branch-section/">http://www.gitguys.com/topics/the-configuration-file-branch-section/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个关于宏的问题]]></title>
    <link href="http://cxh.me/2014/06/26/a-macro-problem/"/>
    <updated>2014-06-26T10:53:00+08:00</updated>
    <id>http://cxh.me/2014/06/26/a-macro-problem</id>
    <content type="html"><![CDATA[<p>  写了一段代码，我想实现宏里面拼接一个变量然后取得这个变量的值的效果，但是没有成功：</p>

<pre><code>#define OB_FIRST_ROOT_TABLE_TID 21
#define OB_INVALID_ID INT_MAX
const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";

struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};


#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from "#table_name)
#define TABLE_BACKUP(table_prefix)\
TABLE_BACKUP_(table_prefix, table_prefix##_TABLE_NAME)

TableBackupSQL table_backup_list_[] =
{
  TABLE_BACKUP(OB_FIRST_ROOT_TABLE)
};


int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/sizeof(TableBackupSQL); i++)
  {
    TableBackupSQL&amp; desc = table_backup_list_[i];
    printf("%d, %s, %s\n", desc.table_id_, desc.table_name_, desc.sql_);
  }
}
</code></pre>

<p>  期望的结果是</p>

<pre><code>21, __first_root_table, select * from __first_root_table
</code></pre>

<p>  实际的结果是</p>

<pre><code>21, __first_root_table, select * from OB_FIRST_ROOT_TABLE_TABLE_NAME
</code></pre>

<!--more-->


<p>  拼出来的OB_FIRST_ROOT_TABLE_TABLE_NAME没有被替换，当然有很多方法绕开。我试图两次展开宏但是没有成功，这个跟<a href="http://blog.csdn.net/maray/article/details/11096459" title="介绍一个C++奇巧淫技">这里</a>说的问题毕竟不是一个。不知道C++11里面有没有解决方法。</p>

<p>  另外，我才发现一个struct直接赋值是C++11才允许的。比如：</p>

<pre><code>TableBackupSQL table_backup_list_[] =
{
  {21, "__first_root_table", "select * from __first_root_table"}
};
</code></pre>

<p>  不加-std=c++0x或者 -std=gnu++0x的时候会报错。c语言支持。</p>

<p>  后来发现我遗忘了一个事实，宏替换是发生在预编译期的，这时候都没有做语法词法分析，程序不知道一个变量应该如何替换，所以变量实际上没有被替换成值，这跟函数定义是不一样的。比如：</p>

<pre><code>#define wrap(value) value
int a  = 1;
int b = wrap(a);
</code></pre>

<p>  我们用gcc打印展开之后的结果如下：</p>

<pre><code>int a = 1;
int b = a;
</code></pre>

<p>  这里是不会展开成 int b = 1;的。而连接符#的作用也只是把宏替换后的字面值加上引号，比如：</p>

<pre><code>#define wrap(value) #value
int a  = 1;
const char * b = wrap(a);
</code></pre>

<p>  展开结果是：</p>

<pre><code>int a = 1;
const char * b = "a";
</code></pre>

<p>  而连接符##的作用就更简单了，就是提供一个标示宏传入参数的作用，比如</p>

<pre><code>#define wrap(value) a##value
int ab = 2;
int b = wrap(b);
</code></pre>

<p>  如果不写##就变成了avalue，无法区分输入参数，如果写a(value)就会替换成a(b),如果写a value就会替换成a b，所以想替换成ab只能用##。</p>

<p>  至于上面那个问题，如果我们table的名字都是宏定义的字符串，那就好办多了：</p>

<pre><code>const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";
#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from " table_name)
</code></pre>

<p>  感谢郁白师兄的指导。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress代码着色]]></title>
    <link href="http://cxh.me/2014/06/22/octopress-code-highlight/"/>
    <updated>2014-06-22T11:15:00+08:00</updated>
    <id>http://cxh.me/2014/06/22/octopress-code-highlight</id>
    <content type="html"><![CDATA[<p>  markdown有自己支持的代码模块，但是想支持着色，就需要单独对代码进行parse和加上css。octopress支持自己的代码语法，但是比较麻烦，并且是本地渲染，对不同语言需要指定。</p>

<p>  所以还是js渲染比较方便一点，我们可以用<a href="https://code.google.com/p/google-code-prettify/" title="google code prettify">google code prettify</a>进行着色，在markdown里面只要对代码加入缩进（tab或者四个空格）。服务端引入如下js:</p>

<pre><code>&lt;link href="http://cxh.me/javascripts/google-code-prettify/prettify.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;
&lt;script type="text/javascript" src="http://cxh.me/javascripts/google-code-prettify/prettify.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" &gt;
&lt;!--
    $(function() {
      $('pre').addClass('prettyprint').attr('style', 'overflow:auto');
      window.prettyPrint &amp;&amp; prettyPrint();
      $('table').addClass('table')
});
--&gt;
&lt;/script&gt;
</code></pre>

<p>  google code prettify的样式可以<a href="http://jmblog.github.io/color-themes-for-google-code-prettify/" title="google code prettify theme">这里</a>选择，关于行号的一些问题参见<a href="http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/" title="Jekyll中使用google-code-prettify高亮代码">这里</a>。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] google code prettify, <a href="https://code.google.com/p/google-code-prettify/">https://code.google.com/p/google-code-prettify/</a></p>

<p>[2] google code prettify theme, <a href="http://jmblog.github.io/color-themes-for-google-code-prettify/">http://jmblog.github.io/color-themes-for-google-code-prettify/</a></p>

<p>[3] Jekyll中使用google-code-prettify高亮代码, <a href="http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/">http://blog.evercoding.net/2013/02/27/highlight-code-with-google-code-prettify/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直接从markdown生成各种电子书]]></title>
    <link href="http://cxh.me/2014/06/21/generate-several-types-using-pandoc/"/>
    <updated>2014-06-21T21:23:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/generate-several-types-using-pandoc</id>
    <content type="html"><![CDATA[<p>  有时候我们需要把编辑的markdown转成各种格式，这不失为一种写书的方式。借助pandoc这把瑞士军刀，我们可以实现一个脚本编译各种格式的功能，代码如下：</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:build.py
import glob,os,sys,shutil

cmd_template={'html':"pandoc %s -o output/html/%s.html --template=default.html",
              'pdf':'pandoc -N --toc --template=default.latex --latex-engine=xelatex %s -o output/pdf/%s.pdf',
              'beamer': 'pandoc -N -t beamer --toc --template=default.beamer --latex-engine=xelatex %s -o output/beamer/%s.pdf',
              'epub': 'pandoc %s -o output/epub/%s.epub'
             }

if __name__ == '__main__':
    if len(sys.argv) &gt; 2:
        print 'Usage: build.py [pdf|html|epub|beamer]'
    else:
        out_type = 'html' if len(sys.argv) == 1 else sys.argv[1]
        assert(out_type in cmd_template)

    os.system('cat *.md &gt; swift_book.mkd')
    cmd = [os.system(cmd_template[out_type] %(path, os.path.splitext(path)[0])) for path in glob.glob("*.md")]
    cmd += [os.system(cmd_template[out_type] %('swift_book.mkd', 'swift_book'))]
    print cmd

    if out_type == 'html':
        try:
            shutil.rmtree('output/html/pic')
        except Exception , e:
            pass
        shutil.copytree("pic",'output/html/pic')
</code></pre>

<!--more-->


<p>  为此你需要<a href="http://johnmacfarlane.net/pandoc/installing.html" title="pandoc">安装一下pandoc</a>，需要pdf支持的话还需要<a href="https://www.tug.org/texlive/" title="texlive">装一下texlive</a>，用法如下：</p>

<pre><code>build.py [pdf|html|epub|beamer]

需要如下的目录结构：

    output  - beamer
            - pdf
            - epub
            - html
                - pic
</code></pre>

<p>   另外，脚本会拼一份合集在目录下，所以需要markdown文件有序，比如9.md会拼在10.md后面，所以需要9.md改名为09.md。</p>

<p>  一个使用的例子可以看<a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese" title="The-Swift-Programming-Language-in-Chinese">这里</a>。那些template都是模板文件，可以参考上面例子里的。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] The-Swift-Programming-Language-in-Chinese, <a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese">https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese</a></p>

<p>[2] pandoc, <a href="http://johnmacfarlane.net/pandoc/">http://johnmacfarlane.net/pandoc/</a></p>

<p>[3] pandoc, <a href="http://johnmacfarlane.net/pandoc/installing.html">http://johnmacfarlane.net/pandoc/installing.html</a></p>

<p>[4] texlive, <a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review插件]]></title>
    <link href="http://cxh.me/2014/06/21/ppost-review-plugin/"/>
    <updated>2014-06-21T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/ppost-review-plugin</id>
    <content type="html"><![CDATA[<h3>post-review.vim</h3>

<p>A plugin to generate post-review script</p>

<h3>Usage</h3>

<h4>install:</h4>

<pre><code>git clone https://github.com/chenxiaohui/post-review.vim 
</code></pre>

<p>put post-review.vim to your $VIM/plugin</p>

<p>add this to your vimrc</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>process:</h4>

<p>svndiff use vimdiff: see <a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">link</a></p>

<p>gitdiff use vimdiff: see <a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">link</a></p>

<p><img src="http://cxh.me/images/2013/git-vimdiff.png"></p>

<!--more-->


<p>first use svn diff/git diff and open vimdiff to see the difference</p>

<p>secondly when you consider the changed file needs to be posted , use <leader>pr to add it to post-review.sh</p>

<p>if you has no post-review.sh on your base_dir( specified by the g:base_dir_mark), you need to input the review id or just enter for a new review.</p>

<p>after you added all files you need to review, chmod +x post-review.sh and execute it.</p>

<p>(if you set g:chmod_after_create to 1 you will not need to chmod +x)</p>

<hr />

<p>  请无视楼主以上装逼的英文:</p>

<h3>post-review.vim</h3>

<p>  就是一个用来从vimdiff记录需要Post-review的文件的插件</p>

<p>  不知道Post-review的同学请google之, 用百度搜索的同学自觉面壁去</p>

<h3>用法</h3>

<h4>安装</h4>

<p>  统共分三步:</p>

<p>1.下载解压(或者git clone) url:<a href="https://github.com/chenxiaohui/post-review.vim">https://github.com/chenxiaohui/post-review.vim</a>
2.放到$VIM/plugin目录下(原谅我不写doc的习惯)
3.在vimrc中添加</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>使用</h4>

<p>  比如说Jack正欢快的写着代码呢，然后Jack要提交, 猛然发现好多修改啊</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<blockquote><p>难道不应该写一部分就post-review的嘛</p></blockquote>

<p>  好了不要care这种细节, 然后Jack需要一个一个查看修改的文件, 确定是放到哪个Post-review中提交</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<pre><code>What a fucking job!!!
</code></pre>

<p>  这时候你需要的就是这一款全自动, 人性化, 帮你生成post-review命令的插件, 只要998, 打进电话你就能拥有它&hellip;</p>

<p><img src="http://cxh.me/images/common/ask.jpg"></p>

<blockquote><p>跑题了&hellip;</p></blockquote>

<p>  好了, 我们先svn diff或者git diff一下, 为了保证你看到的是如下界面请参考<a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">这里</a>或者<a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">这里</a>.</p>

<p><img src="http://www.ccvita.com/usr/uploads/2011/svn_diff.png" title="svndiff" alt="" /></p>

<p>  好了, 在你需要提交文件的那个窗口用快捷键<leader>pr, 标记完了所有的文件之后进入你的根目录(根目录是什么, 这个待会再说, 不要care这种细节), 下面是不是有一个post-review.sh了? 没有? 卧槽&hellip;男子汉大丈夫, 我写的插件, 有问题&hellip;.我也不承认&hellip;</p>

<p>  最后, 两个配置项:</p>

<pre><code>let g:base_dir_mark = 'cscope.out'
</code></pre>

<p>  制定了一个根目录标志, 也就是说你需要在你的项目根目录找一个(或者建一个)独一无二的文件(比如.git, cscope.out, tags)之类, 让插件去寻找这个文件, 找到之后就标识这个目录为根目录. 跟ctrlp学的.</p>

<pre><code>let g:chmod_after_create = 0
</code></pre>

<p>  无聊的选项, 建立完post-review之后是不是chmod +x, 无视它.</p>

<p>  发起新的post-review的时候建议把post-review.sh清空或者删除, 重复添加同一个文件的时候会判断.</p>

<p>  好了, 也就想到这么多了, 有其他的再补充, 钦此.</p>

<p>注：其实最后我发现还是这样更容易：</p>

<pre><code>alias st='svn st'
alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias po="echo 'post-review -d' &gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; stm &gt;&gt; post-review.sh ; chmod +x post-review.sh ;sed -i 's/^[MA]\s\+//g' post-review.sh;sed -i 's/$/ \\\\/g' post-review.sh;vi post-review.sh"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试一下机器和镜头]]></title>
    <link href="http://cxh.me/2014/06/21/photography-test/"/>
    <updated>2014-06-21T13:24:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/photography-test</id>
    <content type="html"><![CDATA[<p>  测试一下机器，镜头是18-55套头，表现中规中矩吧，K10D色彩不错。图压缩过。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/flower.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本文件和二进制文件读写]]></title>
    <link href="http://cxh.me/2014/06/21/bin-txt-file-read-write/"/>
    <updated>2014-06-21T12:28:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/bin-txt-file-read-write</id>
    <content type="html"><![CDATA[<p>  探究这个的起因是我在序列化一个数据结构，用二进制写到文件之后用vim打开发现后面居然多了一个值。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2014/binfile.png" title="用vim显示二进制文件" alt="用vim显示二进制文件"><p class="align-center">用vim显示二进制文件</p></p>

<p>  所以总结一下文件的两种不同写入方式。(当然上面是vim里面xxd显示的问题)</p>

<p>  我们用如下代码测试:</p>

<pre><code>int main(int argc, const char *argv[])
{
  FILE * fp  = fopen("output.txt", "w");
  fputc(10, fp);
  fputc(13, fp);
  fputc('\n', fp);
  fclose(fp);

  fp  = fopen("output.bin", "wb");
  int32_t length[] ={0x0a, 0x12345678};
  fwrite(&amp;length, sizeof(int32_t), 2, fp);
  fclose(fp);
  return 0;
}
</code></pre>

<!--more-->


<p><strong>windows下</strong></p>

<p>文本文件写入：</p>

<pre><code>0000000: 0d0a 0d0d 0a                             .....
</code></pre>

<p>二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>linux下：</strong></p>

<p>  文本方式写入</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入：</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>mac下</strong></p>

<p>  文本方式写入：</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p>  解释几个问题：</p>

<h3>回车符的转义</h3>

<p>  windows下写文本文件的时候换行符会被替换成回车换行(0d0a), 直接写0a(10)也是一样的. Linux和mac下不会,二进制文件不care这些.</p>

<h3>文件结尾判断</h3>

<p>  详见这里：<a href="http://blog.csdn.net/bingqing07/article/details/5785080">http://blog.csdn.net/bingqing07/article/details/5785080</a></p>

<h3>UTF-8 BOＭ</h3>

<p>  转载：</p>

<blockquote><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。
所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。
BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。
「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sublime根据markdown引用生成参考文献的插件]]></title>
    <link href="http://cxh.me/2014/06/20/susublime-plugin-to-generate-refrence/"/>
    <updated>2014-06-20T21:21:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/susublime-plugin-to-generate-refrence</id>
    <content type="html"><![CDATA[<p>  写这个的目的主要是每次写博客需要生成以下版权声明，免得引用了别人的文章被人说盗版。markdown里面支持通过列表组织引用的url，如下所示：</p>

<pre><code>  [1]: http://www.baidu.com   "百度"
  [2]: http:://www.google.com "谷歌"
  [3]: http://www.facebook.com "404 Not Found"
</code></pre>

<p>  我们可以通过这个形式来生成如下的代码</p>

<pre><code>###参考文献:

&gt;\[1] 百度, &lt;http://www.baidu.com&gt;

&gt;\[2] 谷歌, &lt;http:://www.google.com&gt;

&gt;\[3] 404 Not Found, &lt;http://www.facebook.com&gt;
</code></pre>

<p>  效果如下：</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 百度, <a href="http://www.baidu.com">http://www.baidu.com</a></p>

<p>[2] 谷歌, <a href="http:://www.google.com">http:://www.google.com</a></p>

<p>[3] 404 Not Found, <a href="http://www.facebook.com">http://www.facebook.com</a></p></blockquote>

<!--more-->


<p>  代码如下:</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:generate_ref.py

import sublime, sublime_plugin

class GeneraterefCommand(sublime_plugin.TextCommand):
    def run(self, edit):
        sels = self.view.sel()
        lines=[]
        for sel in sels:
            lines += (self.view.substr(sel)).strip("\n").split("\n")
        outlines=[]
        for line in lines:
            idx1 = line.find(":")
            index = line[:idx1]
            idx2 = line.find('"', idx1)
            url = line[idx1+1:idx2].strip(' ')
            title = line[idx2:].strip('"')
            outlines.append('\n&gt;\%s %s, &lt;%s&gt;'%(index,title,url))
        self.view.insert(edit, sel.end(),"\n###参考文献:\n".decode("utf-8") + "\n".join(outlines))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress支持markdown表格]]></title>
    <link href="http://cxh.me/2014/06/20/octopress-pandoc-table/"/>
    <updated>2014-06-20T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/octopress-pandoc-table</id>
    <content type="html"><![CDATA[<p>   pandoc支持扩展的markdown，也就是支持类似于如下的表格：</p>

<pre><code>-----------------------------------------------------------------------------------------------------------------
测量指标                    低程度中心性             低亲近中心性                      低居间中心性
--------------------   -------------------   -----------------------------  -------------------------------------
高程度中心性                                        “自我”所嵌入的聚类                “自我”的联系人是冗余的，
                                                   远离网络中其他节点                整个世界绕他而行


高亲近中心性               是联系重要他人或                                       在事件中，自我位于一个相互
                         活跃人物的关键人物                                     联系密切、活跃的聚类中，与
                                                                             很多节点都很接近；其他节点也是如此
------------------------------------------------------------------------------------------------------------------
: 表3-1 不同中心性测量指标之间的关系[^16]
</code></pre>

<p>  效果可以渲染成这样：</p>

<table>
<caption>表3-1 不同中心性测量指标之间的关系[^16]</caption>
<col width="20%" />
<col width="19%" />
<col width="27%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">测量指标</th>
<th align="center">低程度中心性</th>
<th align="center">低亲近中心性</th>
<th align="center">低居间中心性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">高程度中心性</td>
<td align="center"></td>
<td align="center">“自我”所嵌入的聚类 远离网络中其他节点</td>
<td align="center">“自我”的联系人是冗余的， 整个世界绕他而行</td>
</tr>
<tr class="even">
<td align="left">高亲近中心性</td>
<td align="center">是联系重要他人或 活跃人物的关键人物</td>
<td align="center"></td>
<td align="center">在事件中，自我位于一个相互 联系密切、活跃的聚类中，与 很多节点都很接近；其他节点也是如此</td>
</tr>
</tbody>
</table>




<!--more-->


<p>  插件如下。</p>

<pre><code>require 'pathname'

module Jekyll
  class PandocTag &lt; Liquid::Tag
    def initialize(tag_name, markup, tokens)
      @file = nil
      if markup.strip =~ /(\S+)/i
        @file = $1
      end
      super
    end

    def render(context)
      code_dir = (context.registers[:site].config['pandoc_dir'].sub(/^\//,'') || 'pandoc')
      code_path = (Pathname.new(context.registers[:site].source) + code_dir).expand_path
      file = code_path + @file
      outfile = code_path + "output.html"
      if File.symlink?(code_path)
        return "Code directory '#{code_path}' cannot be a symlink"
      end

      unless file.file?
        return "File #{file} could not be found"
      end

      Dir.chdir(code_path) do
        system "pandoc -o output.html -f markdown -t html #{file}"
        outfile.read
      end
    end
  end

end

Liquid::Template.register_tag('pandoc', Jekyll::PandocTag)
</code></pre>

<p>  使用的时候先生成一个md文件，放在source/pandoc（随便设定）目录下。插件只是生成了html文件然后read进来了而已，所以有点傻，比如下面我的代码放到缩进里面还是被执行了。</p>

<p>  最后用如下语法载入（去掉空格）：</p>

<pre><code>{ % pandoc test.md % }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress的缩进插件]]></title>
    <link href="http://cxh.me/2014/06/20/octopress-indent-plugin/"/>
    <updated>2014-06-20T20:45:00+08:00</updated>
    <id>http://cxh.me/2014/06/20/octopress-indent-plugin</id>
    <content type="html"><![CDATA[<p>  我们写中文的时候通常有首行缩进的需求，markdown默认是不支持的，octopress和wordpress也没有缩进的css。这里我们通过加个插件的方式完成。</p>

<p>  首先，处理markdown的渲染。我们建立如下插件:</p>

<pre><code>    module Jekyll
    module IndentFilter
        def indent(content)
            content.gsub(/&lt;p&gt;\s\s/, '&lt;p class="indent"&gt;')
        end
    end
end

Liquid::Template.register_filter(Jekyll::IndentFilter)
</code></pre>

<p>  这个就是做了个替换。会把行首的两个字符替换成一个css标签。然后加个css在系统css里面就行了：</p>

<pre><code>.indent{text-indent:2em;}
</code></pre>

<!--more-->


<p>  需要注意的是，整个文章的缩进层次可以这样使用：</p>

<pre><code># first
## second
## third
** bold **
no indent
* item
  indent
  &gt; * indent item
</code></pre>

<p>  效果如下所示：</p>

<h1>first</h1>

<h2>second</h2>

<h2>third</h2>

<p><strong> bold </strong></p>

<p>no indent</p>

<ul>
<li><p>item</p>

<p>indent</p></li>
</ul>


<blockquote><ul>
<li>indent item</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
</feed>
