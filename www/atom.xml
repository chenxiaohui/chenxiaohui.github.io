<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CXH.ME]]></title>
  <link href="http://cxh.me/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-10-25T20:37:58+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[table_tablet_iterator]]></title>
    <link href="http://cxh.me/2013/10/21/table-tablet-iterator/"/>
    <updated>2013-10-21T16:26:00+08:00</updated>
    <id>http://cxh.me/2013/10/21/table-tablet-iterator</id>
    <content type="html"><![CDATA[<p>所有迭代器的类图如下所示：</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/iterator.png" title="iterator类图" alt="iterator类图"><p class="align-center">iterator类图</p></p>

<h2>ObRootTabletIterator</h2>

<p>所有tablet类迭代器，也就是ObRootTableIterator, ObTableTabletIterator等的直接父类，定义了迭代接口。</p>

<!-- more -->


<h2>ObTableTabletIterator</h2>

<p>最基本的迭代器，继承ObRootTabletIterator, 负责迭代一个表的所有（或者某个指定range里面的）Tablet。</p>

<h3>实现机理 :</h3>

<p>从Rowkey::MINROWKEY开始，每次迭代的tablet的endkey（加一个ObRowkey::MIN_OBJECT防止找到同一个）作为下次迭代的起始值。</p>

<h3>错误码与错误原因对应</h3>

<p><strong>断言失败</strong>：</p>

<ol>
<li><p>接受返回值的传入参数tablet存在分配器（allocator）或者手动制定了其他的分配器（而不是由上次本迭代器制定的range_allocator)</p></li>
<li><p>sql查询结果为空</p></li>
</ol>


<p><strong>OB_ITER_END</strong>：</p>

<ol>
<li><p>迭代正常结束，必须保证tablet是以MAX结束的（或者以ScanRange的endkey结束）。</p></li>
<li><p>如果有一个表没有任何tablet，同样返回OB_ITER_END，而不是OB_NO_RESULT错误码（更新，争议的地方）。</p></li>
</ol>


<p><strong>OB_NOT_INIT</strong>:</p>

<p>没有初始化，目前是没有传入RootTableService指针，或者指针为空。</p>

<p><strong>OB_ROOT_NOT_INTEGRATED</strong>：</p>

<p>scan_range出错，当前end_key不再scan_range的范围里，</p>

<p><strong>OB_ERR_UNEXPECTED</strong>：</p>

<p>tablet本身错误，start_key > end_key</p>

<h4>其他从root_table层得到的错误码：</h4>

<p><strong>OB_MEM_OVERFLOW</strong>： 内存错误</p>

<p><strong>OB_TABLE_NOT_EXIST</strong>：</p>

<p>1.获得表schema的时候发现schema中不存在这张表</p>

<p>2.查询到的结果有空洞（某个范围下没有当前表的tablet）</p>

<p><strong>OB_NO_RESULT</strong>：按照指定的条件，proxy查询不到结果，主要是table没有tablet的情况和tablet范围未封闭（没有max)，否则总会找到结果，即使没有对应的tablet，也应该返回OB_ENTRY_NOT_EXIST</p>

<p><strong>OB_ERROR</strong>：可能情况</p>

<ol>
<li><p>当前表的元数据表没有指定</p></li>
<li><p>获取root_table_name的时候写入失败</p></li>
<li><p>proxy读取tablet的时候结果加入返回列表的时候失败。</p></li>
<li><p>proxy构建内部表读取sql语句的时候失败（内存错误或者schema错误或者sql字符串填充失败）</p></li>
</ol>


<p><strong>OB_ENTRY_NOT_EXIST</strong>：</p>

<ol>
<li><p>当前表的元数据表schema不存在。</p></li>
<li><p>tablet范围里面有空洞，按照rowkey查找一定范围的tablet之后找不到rowkey所刚好对应的tablet</p></li>
</ol>


<p><strong>OB_SCHEMA_ERROR</strong>：</p>

<p>proxy生成sql语句的时候add_rowkey_column_value失败</p>

<p><strong>OB_ERR_NULL_VALUE</strong>：</p>

<p>proxy生成sql语句的时候add_rowkey_column_value失败</p>

<p><strong>OB_ERR_SQLCLIENT</strong>：</p>

<p>主要是一些sql调用失败。</p>

<p><strong>OB_ALLOCATE_MEMORY_FAILED</strong>：</p>

<p>主要是deep copy range失败</p>

<p><strong>以上错误码都会直接返回到上层，只不过部分需要单独处理，比如OB_ENTRY_NOT_EXISTS 和OB_NO_RESULT是否继续迭代还是个问题。</strong></p>

<h2>ObRootTableIterator</h2>

<p>继承ObRootTabletIterator，实现迭代所有表的所有tablet的功能，如果有table完全没有tablet，则返回OB_NO_TABLET，调用者决定是否继续迭代。</p>

<h3>实现机理</h3>

<p>通过ObTableSchemaIterator迭代所有table, 每次生成一个table的TableTabletIterator,迭代此iterator直到end，然后继续迭代下一个表。如果遇到tablet_iter的错误，返回错误，除OB_NO_TABLET错误外，调用者应中止迭代。</p>

<h3>错误码与错误对应原因</h3>

<p><strong>OB_ITER_END</strong>：迭代所有表的tablet结束。</p>

<p><strong>OB_NO_TABLET</strong>： 从一个表里没有迭代出任何一个tablet，之后仍可继续迭代。</p>

<p>其他错误码来自ObTableSchemaIterator和TableTabletIterator</p>

<h2>ObServerTabletIterator</h2>

<p>继承ObRootTableIterator（仔细看不是tablet）,实现一个server上所有tablet的迭代。</p>

<h3>实现机理</h3>

<p>迭代所有tablet直到找到有副本分布在这个server上的tablet，然后返回。如果出错，一概中断。</p>

<h3>错误码与错误原因对应</h3>

<p>OB_ITER_END：所有tablet迭代结束。</p>

<p>其他错误码来自root_table_iterator</p>

<h2>ObAliveRootTableIterator</h2>

<p>继承ObRootTableIterator（仔细看不是tablet),返回所有表的所有tablet，但是剔除不存活的版本，所以依赖一个ObChunkServerManager指针。</p>

<h2>ObTableTabletFilterVersionIterator</h2>

<p>继承ObTableTabletIterator，返回所有表的所有tablet，但是剔除版本不等于指定版本的replica。</p>

<h3>错误码及错误原因对应</h3>

<p>OB_NOT_INIT：未初始化。</p>

<p>OB_INVALID_ARGUMENT： 初始化参数不合法。</p>

<h3>ObIteratorUtility</h3>

<p>工具类，无状态，负责一些iterator数据处理：如剔除不存活的副本（strip_dead_replicas），筛选符合version条件的副本（filter_replica_version）等。</p>

<hr/>


<h2>ObRootReplicaIterator</h2>

<p>所有replica类迭代器，目前只有ObServerReplicaIterator，定义了迭代接口。包含一个ObRootTableIterator的迭代对象，即所有replica迭代器都是基于RootTableIterator迭代所有表的所有tablet的基础上实现的。</p>

<h2>ObServerReplicaIterator</h2>

<p>迭代某个server上的所有replica(副本)</p>

<h3>实现机理</h3>

<p>迭代所有tablet，直到得到一个tablet里面的分布在该server上的副本。没有就继续迭代。有错误一概中断。</p>

<h2>ObReplicaIteratorCalculator</h2>

<p>合并两个replica类迭代器的结果，并返回当前吐出的replica（replica参数）是属于哪个迭代器的（type参数/LEFT_ITER/RIGHT_ITER/BOTH_ITER三种)</p>

<h3>实现机理</h3>

<ol>
<li>首先置type为both_iter,两个迭代器都前进一步</li>
<li>如果left_iter的结果> right_iter，吐出right_iter的结果，置type为LEFT_ITER，保存两个结果。</li>
<li>同理如果right>left,吐出right_iter的结果，置type为RIGHT_ITER,保存两个结果。</li>
<li>如果right==left，吐出随便哪个结果（左边），置type为BOTH_ITER,保存两个结果。</li>
<li>之后每次next判断type，type=LEFT_ITER则迭代LEFT_ITER，跟right_iter上次的结果比较，决定吐出哪个，并置位type=left/right/both。RIGHT/BOTH同理。</li>
<li>如果有单边迭代器中止，比如左边，则置type=RIGHT_ITER, 迭代到结束，反之亦然。</li>
<li>正常中止条件：两边迭代器都中止。</li>
<li>OB_ITER_END情况下type返回值决定了哪边先结束。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级到ubuntu13.10]]></title>
    <link href="http://cxh.me/2013/10/18/update-to-ubuntu-13-10/"/>
    <updated>2013-10-18T10:49:00+08:00</updated>
    <id>http://cxh.me/2013/10/18/update-to-ubuntu-13-10</id>
    <content type="html"><![CDATA[<p>Ubuntu13.10可以升级了，版本名称是：“俏丽的蝾螈”。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/ubuntu13_10.jpg" title="俏丽的蝾螈" alt="俏丽的蝾螈"><p class="align-center">俏丽的蝾螈</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过脚本统计代码覆盖率]]></title>
    <link href="http://cxh.me/2013/10/16/user-script-to-get-coverage/"/>
    <updated>2013-10-16T20:56:00+08:00</updated>
    <id>http://cxh.me/2013/10/16/user-script-to-get-coverage</id>
    <content type="html"><![CDATA[<p>只是记录一下工作里面的一些trick。我发现我对这些trick的兴趣无比的高。</p>

<p>我们有时候需要在开发机上统计代码覆盖率，这可能是做测试的同学经常的工作，做开发的同学也难免会遇到。对于某些分支复杂的逻辑，代码覆盖工具是极大的助力。</p>

<p>关于gcc coverage选项和gcov/lcov工具的使用已经在 <a href="http://cxh.me/2013/10/16/test-coverage-percentage-statistics/" title="测试覆盖率统计">上篇文章</a>里面说过了，我们这里说的是如何实现方便的统计和拉取数据并显示。</p>

<!-- more -->


<p>首先，测试目录和代码目录是分开的，我们在测试目录运行的时候会生成测试文件的代码覆盖率统计，但是实际上被测试的文件的代码覆盖率是在源码目录生成的。这是需要注意的一点，之前我考虑过合并两处的代码覆盖率统计文件，后来发现没有必要，毕竟你关注的是源码目录的统计文件。这样我们通过如下脚本实现代码覆盖率的生成和拉取。</p>

<pre><code>#!/bin/bash
if [ $# = 1 ] ;then
    lcov --capture --directory . --output-file $1.info --test-name $1
    lcov --remove $1.info "/usr*" -o $1.info # remove output for external libraries
    genhtml $1.info --output-directory ~/$1_output --title "$1" --show-details --legend
    rm $1.info
    tar czvf ~/$1.tar.gz ~/$1_output
    rm -rf ~/$1_output
else
    echo 'cover.sh &lt;testname&gt;'
fi
</code></pre>

<p>解释几点：</p>

<ol>
<li>第四行目的是去掉usr相关的统计，毕竟跟我们没关系。生成的代码打包到HOME目录下。</li>
</ol>


<p>2．可能会报.gcda文件目录出错，找不到要创建的目录的错误，这种主要用于跨平台情况。
这个是由于.gcda文件的生成默认保存到.o所在的目录，但是如果.o所在目录不存在，就会出现错误。
设置环境变量可以解决这个问题。设置GCOV_PREFIX=/target/run&#8217; 同 GCOV_PREFIX_STRIP=1
则生成的.gcda文件 将会保存到 /target/run/build/foo.gcda。</p>

<p>3．有时候会遇到&#8221;Merge mismatch for summaries&#8221; 的错误，可以将.gcda全部删除或者对整个文件全部编译，而不是单个改变的文件，这个是由于gcda与gcno不相配导致的，因为两者之间都有个时间戳用来记录是不是相同的。</p>

<p>然后是关于拉取到本地的问题，直接在bashrc里面配置如下别名好了：</p>

<pre><code>alias getcov="from 你的测试用例.tar.gz &amp;&amp; tar zxvf xxx.tar.gz &amp;&amp; cd xxx"

function from() {
 scp -r 你的用户名@$你的开发机:$@ .
}
alias html='google-chrome http://localhost:8000; python -m SimpleHTTPServer'
</code></pre>

<p>这样getcov拉取覆盖率文件，html命令建立webserver并打开浏览器，小trick，用起来舒服而已。</p>

<hr />

<p>擦，我不得我提醒各位，有时候发现修改了case之后覆盖率并没有提升，这一定不是你的问题，不一定是coverage数据没有更新的问题，不一定是数据没有拉取成功的问题，极有可能是浏览器缓存了数据的问题。</p>

<p>针对这种问题，我们的解决方法就是：</p>

<p><strong>作死地按f5</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下挂载ntfs分区的问题/draft]]></title>
    <link href="http://cxh.me/2013/10/16/linux-mount-ntfs/"/>
    <updated>2013-10-16T10:29:00+08:00</updated>
    <id>http://cxh.me/2013/10/16/linux-mount-ntfs</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试覆盖率统计]]></title>
    <link href="http://cxh.me/2013/10/16/test-coverage-percentage-statistics/"/>
    <updated>2013-10-16T10:15:00+08:00</updated>
    <id>http://cxh.me/2013/10/16/test-coverage-percentage-statistics</id>
    <content type="html"><![CDATA[<h3>什么是代码覆盖率(code coverage)</h3>

<p>代码覆盖（Code coverage）是软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p>

<p>代码覆盖主要包括如下四个方面：</p>

<ol>
<li>语句覆盖(StatementCoverage)</li>
<li>判定覆盖(DecisionCoverage)</li>
<li>条件覆盖(ConditionCoverage)</li>
<li>路径覆盖(PathCoverage) 或者叫条件/判断覆盖率</li>
</ol>


<p>具体的参见参考文献<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87" title="代码覆盖率">1</a>.</p>

<h3>怎么得到覆盖率数据</h3>

<p>这里我们主要说测试工具的使用的问题。c++的项目测试里面我们用gcc产生测试数据，用gcov和lcov生成测试结果的报表。</p>

<!-- more -->


<p>gcc这里需要做的工作是编译的时候打开coverage选项，主要是如下几步。</p>

<ol>
<li>编译的时候，增加 -fprofile-arcs -ftest-coverage 或者 –coverage；</li>
<li>链接的时候，增加 -fprofile-arcs 或者 –lgcov；</li>
<li>打开–g3 选项，去掉-O2以上级别的代码优化选项；否则编译器会对代码做一些优化，例如行合并，从而影响行覆盖率结果；</li>
</ol>


<p>为了方便的在Makefile里面控制是否生成测试覆盖率数据，我们在Makefile里面加入如下开关</p>

<pre><code>ifeq ($(coverage), yes)
    CXXFLAGS       +=  -fprofile-arcs -ftest-coverage
    LINKERCXX      +=  -fprofile-arcs -ftest-coverage
    OPT_FLAGS     =  -g3
endif
</code></pre>

<p>这样就可以通过make coverage=yes生成。</p>

<p>同理如果用automake工具的话，Makefile.am里面需要加入如下语句：</p>

<pre><code>if COVERAGE
    CXXFLAGS+=-fprofile-arcs -ftest-coverage
    AM_LDFLAGS+=-lgcov
    OPT_FLAGS =  -g3
endif
</code></pre>

<p>configure.ac/configure.in脚本里面需要加入</p>

<pre><code>AC_ARG_WITH([coverage],
       AS_HELP_STRING([--with-coverage],
              [with coverage (default is NO)]),
          [
            if test "$withval" = "yes"; then
                coverage=yes
            fi
          ],
          [coverage=no]
   )
AM_CONDITIONAL([COVERAGE], test x$coverage = xyes )
</code></pre>

<p>就可以通过</p>

<pre><code>./configure --with-coverage来生成Makefile了
</code></pre>

<p>之后我们可以通过gcov/lcov工具来显示覆盖率的结果，使用帮助参见参考文献<a href="http://sdet.org/?p=212" title="Linux下c/c++项目代码覆盖率的产生方法">3</a> <a href="http://www.cnblogs.com/turtle-fly/archive/2013/01/09/2851474.html" title="[整理] gcov lcov 覆盖c/c++项目入门">4</a>。至于如何在去开发机拉取结果/一些小技巧和容易出现的问题，请看<a href="http://cxh.me/2013/10/16/user-script-to-get-coverage/" title="通过脚本统计代码覆盖率">下一篇博客</a>。</p>

<h3>参考文献</h3>

<blockquote><p><a href="http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html" title="代码覆盖率浅谈">1</a> 代码覆盖率浅谈，<a href="http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html">http://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html</a></p>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87" title="代码覆盖率">2</a> 代码覆盖率，<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87">http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B%E7%8E%87</a></p>

<p><a href="http://sdet.org/?p=212" title="Linux下c/c++项目代码覆盖率的产生方法">3</a> Linux下c/c++项目代码覆盖率的产生方法，<a href="http://sdet.org/?p=212">http://sdet.org/?p=212</a></p>

<p>[4] [整理] gcov lcov 覆盖c/c++项目入门, <a href="http://www.cnblogs.com/turtle-fly/archive/2013/01/09/2851474.html">http://www.cnblogs.com/turtle-fly/archive/2013/01/09/2851474.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git reset和git revert]]></title>
    <link href="http://cxh.me/2013/10/15/git-reset-revert/"/>
    <updated>2013-10-15T14:50:00+08:00</updated>
    <id>http://cxh.me/2013/10/15/git-reset-revert</id>
    <content type="html"><![CDATA[<h3>git reset 作用</h3>

<p>git reset 主要完成到版本库某个特定版本的回退，分为如下三种方式</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/git-reset.png" title="git-reset三种方式" alt="git-reset三种方式"><p class="align-center">git-reset三种方式</p></p>

<p>git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可
git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p>

<h3>git revert 作用</h3>

<p>git revert从字面的理解上跟git reset是一样的，不同之处在于git revert生成一个反向的差异（特定版本-当前版本）然后提交到版本库，相当与做了之前操作的逆操作，这个操作是可以直接在版本库中看到并使用git reset回退的。</p>

<h3>撤销之后恢复</h3>

<p>git-reset如果执行之后，再想回退到指定版本。//TODO</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn vim 整合方案]]></title>
    <link href="http://cxh.me/2013/10/15/svn-vim-integration/"/>
    <updated>2013-10-15T11:53:00+08:00</updated>
    <id>http://cxh.me/2013/10/15/svn-vim-integration</id>
    <content type="html"><![CDATA[<p>这也是实际工作中遇到的问题，所以还是分类到了oceabase分类里面。</p>

<p>遇到的情况是这样的，有可能同时做多个任务的修改，或者说上一个任务的修改并未提交（尚未ship不能提交），但是下一个已经修改了，这样的话，post-review的时候是需要管理post列表的，而不能把所有的修改一起post。之前应该写过一篇文章说一个post-review插件的实现，但是实际上颇为不便，最好的办法是直接在vim里面操作一个修改列表。这里我们首先通过如下方式生成修改列表。</p>

<!-- more -->


<pre><code>alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias std='st|grep ^D '
alias po='echo "#!/bin/sh" &gt;post-review.sh &amp;&amp; echo "post-review \\" &gt;&gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; std &gt;&gt;post-review.sh; stm &gt;&gt; post-review.sh ; vi post-review.sh'
</code></pre>

<p>之后可以得到类似如下所示的post-review.sh，当然这个是不能直接运行的。</p>

<pre><code>#!/bin/sh
post-review \
M       tests/rootserver/root_table/iterator/test_ob_server_tablet_iter.cpp
M       tests/rootserver/root_table/iterator/test_ob_root_replica_iter.cpp
M       tests/rootserver/root_table/iterator/test_ob_server_replica_iter.cpp
M       tests/rootserver/root_table/iterator/test_iterator_base.h
M       tests/rootserver/root_table/iterator/Makefile.am
M       tests/rootserver/root_table/iterator/test_ob_root_table_iter.cpp
M       tests/rootserver/root_table/iterator/run.sh
M       tests/rootserver/root_table/iterator/test_ob_alive_root_table_iter.cpp
</code></pre>

<p>我们面临两个问题：</p>

<ol>
<li>每行的格式都略有差别，比如前面有A/M/D标记，后面没有续行符号\，没有空格什么的。</li>
<li>需要能够针对每一行或者多行进行svn操作（svn diff/revert 应该是最常见的操作）</li>
</ol>


<p>这里我们通过vim脚本实现如下的功能：</p>

<p>svn.vim 实现如下</p>

<pre><code>function! StripSVN() range
    "Step through each line in the range...
    for linenum in range(a:firstline, a:lastline)
        "Replace loose ampersands (as in DeAmperfy())...
        let curr_line   = getline(linenum)
        let replacement = substitute(curr_line,'^\(A\|M\|D\)','','g')
        call setline(linenum, replacement." \\")
    endfor
    call cursor(linenum)
    "Report what was done...
    if a:lastline &gt; a:firstline
        echo "Strip Svn" (a:lastline - a:firstline + 1) "lines"
    endif
endfunction
function! SVNCommand(cmd, prompt, combine) range
    if a:prompt
        let sure = input("Are you sure? (y/n) ")
        if sure != 'y'
            return
        endif
    endif
    let cmd = '!svn '.a:cmd
    for linenum in range(a:firstline, a:lastline)
        "Replace loose ampersands (as in DeAmperfy())...
        let curr_line   = getline(linenum)
        let replacement = substitute(curr_line,'^\(A\|M\)','','g')
        let replacement = Trim(Trim(replacement,'\\'),' ')
        if a:combine
           let cmd = cmd.' '.replacement.' '
        else
            let cmd = '!svn ' . a:cmd. ' ' . replacement
            execute cmd
            "echo cmd
        endif
    endfor
    if a:combine
        execute cmd
        "echo cmd
    endif
endfunction
</code></pre>

<p>第一个函数处理每行的格式，第二个函数读取每行的内容，生成命令并执行，prompt=1 的时候会提示并让用户确认， combine=1 的时候所有行会拼成一条执行，否则每行执行一次。</p>

<p>然后在vimrc中添加：</p>

<pre><code>noremap &lt;leader&gt;sp :call StripSVN()&lt;CR&gt;
noremap &lt;leader&gt;sf :call SVNCommand("diff", 0 ,1)&lt;cr&gt;
noremap &lt;leader&gt;sr :call SVNCommand("revert", 1 ,0)&lt;cr&gt;dd
noremap &lt;leader&gt;sl :call SVNCommand("log", 0 ,0)&lt;cr&gt;
noremap &lt;leader&gt;sa :call SVNCommand("add", 0 ,1)&lt;cr&gt;
noremap &lt;leader&gt;sb :call SVNCommand("blame", 0 ,1)&lt;cr&gt;
noremap &lt;leader&gt;sd :call SVNCommand("delete", 1 ,0)&lt;cr&gt;dd
</code></pre>

<p>这样实现了两种操作，n状态下在当前行执行操作，v状态下在选中的所有行执行操作。</p>

<hr />

<p>其实偶然发现我好像没说怎么用，大致流程是这样的：</p>

<ol>
<li>po(alias)，生成修改列表</li>
<li>在每个行，或者选中多个行执行svn命令(<leader>sf,<leader>sr什么的)，查看diff啊，回滚啊，查看log啊，查看blame啊</li>
<li>提交前选中所有行执行<leader>sp， 去掉行首的A/M/D标记，在行尾加续行符</li>
<li>执行post-review.sh提交</li>
</ol>


<hr />

<p>参考文献：</p>

<blockquote><p>[1] SVN 命令参考（svn command reference）, <a href="http://riaoo.com/subpages/svn_cmd_reference.html">http://riaoo.com/subpages/svn_cmd_reference.html</a></p>

<p>[2] 使用脚本编写 Vim 编辑器, <a href="http://www.ibm.com/developerworks/cn/linux/l-vim-script-2/">http://www.ibm.com/developerworks/cn/linux/l-vim-script-2/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于svn commit fail的问题]]></title>
    <link href="http://cxh.me/2013/10/12/svn-commit-failed/"/>
    <updated>2013-10-12T21:39:00+08:00</updated>
    <id>http://cxh.me/2013/10/12/svn-commit-failed</id>
    <content type="html"><![CDATA[<p>svn commit失败的时候会产生一个svn-commit.tmp 文件， 打开之后发现里面是commit-message，难道下次提交的时候还需要把消息复制进去么？</p>

<p>看看 svn help commit, 发现有 -F 可以用, 平常都只有用 -m &lsquo;message&rsquo; 而已。定义如下：</p>

<blockquote><p>-F: 会把档案内容读进来, 然后直接 commit, 想当然就用 -F 直接取 svn-commit.tmp 来 commit.</p>

<ul>
<li>例: svn ci -F svn-commit.tmp</li>
</ul>
</blockquote>

<!-- more -->


<p>PS: commit 完后, 还是要手动 rm svn-commit.tmp.</p>

<p>另一个关于commit的问题是，如果 svn ci 进入填充commit-log的交互界面的时候，突然发现提交文件列表有误怎么办？</p>

<p>其实很简单，只要不保存退出，就会有提示了。保存退出才会直接提交的。放心。</p>

<p>钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个svn的问题]]></title>
    <link href="http://cxh.me/2013/10/12/several-svn-problems/"/>
    <updated>2013-10-12T19:27:00+08:00</updated>
    <id>http://cxh.me/2013/10/12/several-svn-problems</id>
    <content type="html"><![CDATA[<h3>误用rm删除了未提交文件</h3>

<p>经常会遇到这种情况：本地修改了一部分东西，增增改改删删，后来发现已经用svn add过的的文件被删除了，但是这个文件只是加入了版本控制，而并不再版本库里，这时候post-review就会有各种问题。如图（前面有感叹号的文件）：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/before_revert.png" title="直接用rm删除的文件" alt="直接用rm删除的文件"><p class="align-center">直接用rm删除的文件</p></p>

<!-- more -->


<p>解决办法也很简单，我们直接:</p>

<pre><code>svn revert ob_alive_table_tablet_iter.h
</code></pre>

<p>这时候文件并不会被恢复，但是svn status上已经显示删除了，post-review不会再报错，如下图所示：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/after_revert.png" title="revert之后" alt="revert之后"><p class="align-center">revert之后</p></p>

<h3>版本控制中移除文件</h3>

<p>经常会遇到错误的把文件加入了版本控制的情况，比如我加了一个Makefile.in到版本控制里（如图），但是svn rm 会同时从版本库和本地删除这个文件，这是我所不希望的，毕竟我还要再跑一遍automake。</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/before-rm.png" title="错误的把Makefile.in加入版本控制" alt="错误的把Makefile.in加入版本控制"><p class="align-center">错误的把Makefile.in加入版本控制</p></p>

<p>其实 svn rm 提供了keep-local选项来保留本地副本：</p>

<pre><code>svn rm Makefile.in --keep-local
</code></pre>

<p>执行之后的版本库状态如下图：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/before-rm.png" title="版本控制的状态" alt="版本控制的状态"><p class="align-center">版本控制的状态</p></p>

<p>从文件管理里面看，这个本地副本依然存在，如下图：</p>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/ll-result.png" title="文件管理里的情况" alt="文件管理里的情况"><p class="align-center">文件管理里的情况</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记几个诡异的bug]]></title>
    <link href="http://cxh.me/2013/10/12/a-strange-error/"/>
    <updated>2013-10-12T15:57:00+08:00</updated>
    <id>http://cxh.me/2013/10/12/a-strange-error</id>
    <content type="html"><![CDATA[<h3>ERROR: mutli target patterns</h3>

<p><s>这个莫名其妙啊，不知道在Makefile.am里改了什么，然后就这样，网上的解释大部分是说target里面有多余的冒号，但是我发现问题啊。最后该来该去bug没了，但是也复现不出来，只是在这里记一下，如果有复现的时候再说。</s></p>

<p>后来 <a href="http://weibo.com/leslieyuchen" title="阿里聿明">聿明</a> 解决了这个问题，原来是编译的线程开太多了，而开发机性能又不好，争用然后冲突。</p>

<pre><code>alias make='make -s -j 4' #这里开到4-5就不要更多了
</code></pre>

<!-- more -->


<h3>ob集群无法启动</h3>

<p>怀疑是机器的问题，但是如果大部分机器我都无法启动这算怎么一回事，</p>

<p>rs的日志如下：</p>

<pre><code>[2013-10-12 14:41:56.484203] WARN  create_first_table (ob_root_bootstrap.cpp:164) [140296887187200] fail to create e
mpty tablet. table_id=111 err=-54
[2013-10-12 14:41:56.484272] WARN  bootstrap_first_table (ob_root_bootstrap.cpp:130) [140296887187200] fail to creat
e first_tablet_entry's tablet. err=-54
[2013-10-12 14:41:56.484289] ERROR do_bootstrap (ob_root_server2.cpp:582) [140296887187200] bootstrap first root table error, err=-54
[2013-10-12 14:41:56.484302] ERROR boot_strap (ob_root_server2.cpp:565) [140296887187200] bootstrap failed! ret: [-54]
[2013-10-12 14:41:56.484314] INFO  ob_root_server2.cpp:570 [140296887187200] ObRootServer2::bootstrap() end:ret[-54]
[2013-10-12 14:41:56.484325] INFO  ob_root_worker.cpp:3129 [140296887187200] admin cmd=16, err=-54
[2013-10-12 14:41:56.484339] WARN  do_admin_without_return (ob_root_worker.cpp:3252) [140296887187200] not supported admin cmd:cmd[16]
</code></pre>

<p>cs的日志如下：</p>

<pre><code>ERROR do_request (ob_chunk_service.cpp:451) [139992810493696] service not started, only accept start schema message or heatbeat from rootserver.
[2013-10-12 14:41:56.480804] INFO  ob_tablet_image.cpp:3133 [139993389482080] begin scan report_tablet_list size:0
[2013-10-12 14:41:56.481673] INFO  ob_general_rpc_stub.cpp:259 [139993389482080] report tablets over, send OB_WAITING_JOB_DONE message.
[2013-10-12 14:41:56.482303] INFO  ob_tablet_manager.cpp:987 [139993389482080] tablet report. typeset=51
[2013-10-12 14:41:56.482321] INFO  ob_tablet_image.cpp:3133 [139993389482080] begin scan report_tablet_list size:0
[2013-10-12 14:41:56.483331] INFO  ob_general_rpc_stub.cpp:259 [139993389482080] report tablets over, send OB_WAITING_JOB_DONE message.
[2013-10-12 14:41:56.483670] ERROR do_request (ob_chunk_service.cpp:470) [139992810493696] call func error packet_code is 219 return code is -1026
</code></pre>

<p>ms的日志如下：</p>

<pre><code>[2013-10-12 14:41:56.510527] WARN  create (../../src/common/hash/ob_hashtable.h:302) [139726122704928] create buckets fail
[2013-10-12 14:41:56.527871] WARN  init (../../src/common/ob_kv_storecache.h:1755) [139726122704928] create map fail
 ret=-1 num=5543383
[2013-10-12 14:41:56.527890] ERROR init (ob_sql_query_cache.cpp:217) [139726122704928] KeyValueCache init error, ret: 1
[2013-10-12 14:41:56.527897] ERROR initialize (ob_mysql_server.cpp:151) [139726122704928] ObSQLQueryCache init error, ret: 1
[2013-10-12 14:41:56.527906] WARN  start (ob_mysql_server.cpp:508) [139726122704928] initialize failed ret is 1
[2013-10-12 14:41:56.527913] ERROR do_work (ob_merge_server_main.cpp:172) [139726122704928] obmysql server start failed,ret=1
[2013-10-12 14:41:56.527982] INFO  ob_mysql_server.cpp:611 [139726122704928] server stoped.
</code></pre>

<p><s>create_bucket失败，这个也不能总是说内存的问题吧&hellip;莫非是大部分开发机都资源不足？我靠谁干的&hellip;.</s></p>

<p>确认了 ms 起不来是因为内存分配失败的问题 感谢 <a href="http://www.weibo.com/u/1912538231" title="瑶瓔">瑶瓔</a> 的辛苦debug</p>

<h3>关于border_flag</h3>

<p>border_flag这事情是很早遗留的问题了，<a href="http://weibo.com/chuanhui85" title="阿里日照">@日照师兄</a> 说过，大概是border_flag和min/max对象两套东西一起在用，目前看直接不要用border_flag的MIN/MAX位就好了，比对的时候会直接跟min/max对象比对的，而忽略了border_flag。但是毕竟有些地方没改过来，比如：</p>

<pre><code>int ObRootTabletInfo::split_tablet(const ObReplica &amp; replica)
{
  int ret = OB_ERROR;
  if (replica.meta_.range_.start_key_ == meta_info_.range_.start_key_)
  {
    if (replica.meta_.range_.end_key_ &lt; meta_info_.range_.end_key_)
    {
      meta_info_.range_.border_flag_.unset_min_value(); #这里需要设置
      meta_info_.range_.start_key_ = replica.meta_.range_.end_key_;
      ret = OB_SUCCESS;
    }
  }
  if (OB_SUCCESS != ret)
  {
    TBSYS_LOG(WARN, "split tablet error:tablet[%s], replica[%s]", to_cstring(meta_info_.range_),
        to_cstring(replica.meta_.range_));
  }
  return ret;
}
</code></pre>

<p>如果split的时候一个tablet已经置位MIN/MAX了，现在分裂的时候后一部分（原tablet split之后的那部分）已经不是MIN-MAX，但是置位还在，就悲催了。</p>

<p>钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review在svn和git共同存在下的冲突问题]]></title>
    <link href="http://cxh.me/2013/10/11/post-review-conflict-under-git-svn/"/>
    <updated>2013-10-11T21:24:00+08:00</updated>
    <id>http://cxh.me/2013/10/11/post-review-conflict-under-git-svn</id>
    <content type="html"><![CDATA[<p>  有时候我们会同时用多种版本管理工具进行管理，或许这听着很eggache，但是有时候确实会发生，比如</p>

<ul>
<li>不习惯某种版本管理工具，希望通过另一种熟悉的版本管理工具进行管理</li>
<li>有些特性是其他的版本管理工具所没有的</li>
<li>开发的版本管理和自己的分支管理策略之间有冲突，开发的版本库不允许随便建立测试分支</li>
</ul>


<!-- more -->


<p>  具体到一种情况下，比如我们有一个svn的版本库，版本管理策略比较严格，而我们需要做一些有风险的本地开发的时候，都原意建立一个test分支，开发确定没有问题之后再合并到master分支，但是现实的情况不允许我们随便建立丢弃分支。这样就可以通过加入一个git的版本管理来实现。</p>

<p>  比如我们建立了一个新的版本库（repository）</p>

<pre><code>mkdir repository.git &amp;&amp; cd repository.git &amp;&amp; git init --bare
</code></pre>

<p>  然后checkout了版本并使当前项目加入版本管理，这里我只会一个笨办法，checkout一个空的，然后mv .git目录进去，有空再研究别的方法。</p>

<p>  之后所有的修改都可以通过git进行管理了，git的version control文件只存在于根目录下，所以也不会污染原有版本库。</p>

<p>  但是post-review的时候就有问题了我们明明有修改，但是post-review总是报错：</p>

<pre><code>  There don't seem to be any diffs!
</code></pre>

<p>  这到底是什么问题呢，启动debug模式运行post-review，结果如下：</p>

<pre><code>&gt;&gt;&gt; RBTools 0.5
&gt;&gt;&gt; Python 2.6.6 (r266:84292, May  1 2012, 13:52:17) 
[GCC 4.4.6 20110731 (Red Hat 4.4.6-3)]
&gt;&gt;&gt; Running on Linux-2.6.32-220.el6.x86_64-x86_64-with-redhat-6.2-Santiago
&gt;&gt;&gt; Home = /xxx
&gt;&gt;&gt; Current Directory = /xxx
&gt;&gt;&gt; Checking the repository type. Errors shown below are mostly harmless.
DEBUG:root:Checking for a Bazaar repository...
DEBUG:root:Checking for a CVS repository...
DEBUG:root:Checking for a ClearCase repository...
DEBUG:root:Checking for a Git repository...
DEBUG:root:Running: git rev-parse --git-dir
DEBUG:root:Running: git config core.bare
DEBUG:root:Running: git rev-parse --show-toplevel
DEBUG:root:Running: git symbolic-ref -q HEAD
DEBUG:root:Running: git config --get branch.master.merge
DEBUG:root:Running: git config --get branch.master.remote
DEBUG:root:Running: git config --get remote.origin.url
DEBUG:root:repository info: Path: /xxx.git, Base path: , Supports changesets: False
&gt;&gt;&gt; Finished checking the repository type.
&gt;&gt;&gt; HTTP GETting api/info/
DEBUG:root:Running: git merge-base origin/master refs/heads/master
DEBUG:root:Running: git diff --no-color --full-index --no-ext-diff --ignore-submodules --no-renames 43351ae337ca18c3f00660c9d565b18a5e904e66..refs/heads/master
There don't seem to be any diffs!
</code></pre>

<p>  可以看到，git的检测优先于subversion，这样当前版本库被当作git管理的版本库来处理了，所以才没有变更。</p>

<p>  解决办法有两个，要么修改RBTool的代码，更改检测优先级，或者post-review之前运行</p>

<pre><code>mv .git git
</code></pre>

<p>  这足够骗过RBTool了。</p>

<p>  钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[霸气风骚的系统监视器htop]]></title>
    <link href="http://cxh.me/2013/10/10/the-best-monitor-under-linux-htop/"/>
    <updated>2013-10-10T20:12:00+08:00</updated>
    <id>http://cxh.me/2013/10/10/the-best-monitor-under-linux-htop</id>
    <content type="html"><![CDATA[<p>做测试和运维的同学都比较熟悉top工具，top工具提供了强大的系统性能监视能力，但是top毕竟比较简陋，而服务器端又不能运行需要X的程序，所以需要一款更人性更强大的系统监视器。HTOP就是一个很好的选择。</p>

<!-- more -->


<h3>介绍</h3>

<blockquote><p>htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。</p>

<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>

<p>与top相比，htop有以下优点：</p>

<ul>
<li>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</li>
<li>在启动上，比top 更快。</li>
<li>杀进程时不需要输入进程号。</li>
<li>htop 支持鼠标操作。</li>
</ul>


<p>htop 官网：<a href="http://htop.sourceforge.net/">http://htop.sourceforge.net/</a></p></blockquote>

<h3>截图</h3>

<p><img class="img-ploaroid center" src="http://cxh.me/images/2013-10/htop.png" title="htop截图" alt="htop截图"><p class="align-center">htop截图</p></p>

<h3>安装</h3>

<h4>Ubuntu</h4>

<pre><code>sudo apt-get install htop
</code></pre>

<h4>RHEL/CentOS</h4>

<h5>CentOS 5.x</h5>

<pre><code>32位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm
64位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm
导入key
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL
</code></pre>

<h5>CentOS 6.x</h5>

<pre><code>32位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm
64位系统选择：
rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
导入key：
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
</code></pre>

<p>最后执行</p>

<pre><code>yum install htop
</code></pre>

<h4>源码安装</h4>

<pre><code>wget http://nchc.dl.sourceforge.net/project/htop/htop/1.0.1/htop-1.0.1.tar.gz
tar zxvf htop-1.0.1.tar.gz
cd htop-1.0.1
./configure
make
make install
</code></pre>

<h3>参考文献：</h3>

<blockquote><p>[1] （原创）htop：一款比top强悍好用的进程管理监控工具, <a href="http://www.ha97.com/4075.html">http://www.ha97.com/4075.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[去了趟锦州]]></title>
    <link href="http://cxh.me/2013/10/07/tourism-of-jinzhou/"/>
    <updated>2013-10-07T18:34:00+08:00</updated>
    <id>http://cxh.me/2013/10/07/tourism-of-jinzhou</id>
    <content type="html"><![CDATA[<p>去锦州的原因，其实是没搞到去其他的地方的票。</p>

<p>十一这个季节，就是人啊人啊人啊人啊人啊人啊人啊人啊人啊人啊人啊&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[狄仁杰之神都龙王]]></title>
    <link href="http://cxh.me/2013/10/06/young-detective-dee-rise-of-the-sea-dragon/"/>
    <updated>2013-10-06T20:21:00+08:00</updated>
    <id>http://cxh.me/2013/10/06/young-detective-dee-rise-of-the-sea-dragon</id>
    <content type="html"><![CDATA[<p>抽空去看了一下。去看的原因倒是很简单， 有人把它上升到中国大片的崛起的高度。大片看多了，崛起这事情，倒是值得去看一下。</p>

<p>坦白说比其他的拍的好多了，至少没什么硬伤，或者明显的硬伤，这让我很欣慰了，对的起票钱（折扣之后）。</p>

<!-- more -->


<p>我不理解的是，这几年过去了，武侠怎么已经上升到法术的高度了，更让我不能理解的是，这么牛逼的一只<a href="http://baike.baidu.com/link?url=dWI58A0UeuCs95DyVPXFM-4bT9b4wQyRlXRSbA3o2u0ShtN1Rhum3rLMJSoKyGwO" title="蝠鲼">蝠鲼</a>（fú fèn，原谅我的猜测，那只怪物或许真是什么变异物种也说不定，比如随便从山海经里面拿一只出来就足够吓尿观众了），怎么就死在几只毒鱼下了呢，这是告诉我们食品安全刻不容缓么？</p>

<p>话说这么险恶的环境，狄大人能活下来真的是奇迹啊。为了救美女拿人头打赌的都是亡命徒啊，果然只有不怕死的才命大&hellip;</p>

<p>顺便逛了一下<a href="http://www.parkviewgreen.com/cn/" title="侨福芳草地">侨福芳草地</a>，好象是芳草地一周年还是怎么的，里面布满了各种艺术雕塑。有种进了798的感觉，但是798毕竟厂房了一点，这才是艺术品该待的地方嘛。没准哪个土豪逛着逛着看上一个就掏钱买了呢，要知道可不是所有的土豪都愿意转两趟公交去大山桥然后走200米左右跑798那堆厂房去。</p>

<hr />

<p><img src="http://cxh.me/images/common/ask.jpg" width="200" title="&#34;are you kidding me&#34;" alt="&#34;are you kidding me&#34;"> 你家的土豪是坐公交的啊</p>

<hr />

<p>好了，不管土豪的事情了，上几张照片。</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/IMG_20131006_144718.jpg" title="这个是想表达什么" alt="这个是想表达什么"><p class="align-center">这个是想表达什么</p></p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/IMG_20131006_145824.jpg" title="话说这个狗狗还是挺可爱的嘛" alt="话说这个狗狗还是挺可爱的嘛"><p class="align-center">话说这个狗狗还是挺可爱的嘛</p></p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-10/IMG_20131006_172509.jpg" title="最震撼的其实是这个" alt="最震撼的其实是这个"><p class="align-center">最震撼的其实是这个</p></p>

<p>这TM才叫雕塑嘛，毕竟任何一只单独拿出来也可以用嘛&hellip;多么的经济实惠</p>

<p>钦此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[陌生的人, 请给我一支兰州]]></title>
    <link href="http://cxh.me/2013/09/30/give-me-a-sigarette-of-lanzhou/"/>
    <updated>2013-09-30T16:11:00+08:00</updated>
    <id>http://cxh.me/2013/09/30/give-me-a-sigarette-of-lanzhou</id>
    <content type="html"><![CDATA[<!-- more -->


<p>普及一下:</p>

<p>兰州: 一种烟, 如图所示:</p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-9/lanzhou.jpg" width="200" title="兰州" ></p>

<p><img class="img-polaroid center" src="http://cxh.me/images/2013-9/lanzhou2.jpg" width="200" title="兰州" ></p>

<p>钦此.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase的库依赖问题]]></title>
    <link href="http://cxh.me/2013/09/27/depend-problem-in-oceanbase/"/>
    <updated>2013-09-27T16:15:00+08:00</updated>
    <id>http://cxh.me/2013/09/27/depend-problem-in-oceanbase</id>
    <content type="html"><![CDATA[<p>今天遇到一个问题: 写测试用例的时候发现总是找不到符号undefined refrence, 第一反应是我去有个没编译的吧, 但是打印了所有的符号，发现其实编译生成库文件里面完全有对应的符号，命名空间也没有错误。这就是很诡异的问题了，刚好手头另一份代码可以编译链接成功，于是对比了一下午结果，发现最后一个函数在类里实现就能编译，类外实现就不能编译，这个问题就太毁三观了。</p>

<p>最后请教了 <a href="http://weibo.com/cangzhou" title="Leverly">解伦师兄</a> ， 发现其实是库依赖的问题， Libtool制定的链接库列表是有相互依赖关系的，比如：</p>

<!-- more -->


<pre><code>LDADD = libtest2.a \
        libtest2.a 
</code></pre>

<p>或者gcc命令</p>

<pre><code>gcc –o test main.c libtest2.a libtest1.a
</code></pre>

<p>这里编译的时候会认为libtest2.a依赖于libtest1.a, libtest2.a可以使用libtest1.a的接口，但是反过来会找不到符号。也就是会有会有&#8221;undefined reference to ***”的链接错误。</p>

<p>找了一下原因，主要是gcc链接顺序的问题，以下引自 <a href="http://www.cnblogs.com/wujianlundao/archive/2012/06/06/2538125.html" title="使用静态库链接程序">悟空不悟空的博客</a></p>

<hr />

<p>原因是gcc在链接的时候，对于多个静态库或者.o文件是从前往后依次处理的，如果当前的静态库或.o文件中没有使用的符号，则往后继续寻找，而不会再往前查找。</p>

<p>下面是man gcc看到的说明：</p>

<p>-l library</p>

<blockquote><p>  Search the library named library when linking.  (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.)</p>

<p> It makes a difference where in the command you write this option; the linker searches and processes libraries and object files in the order they are specified.  Thus, foo.o -lz bar.o searches library z after file foo.o but before bar.o.  If bar.o refers to functions in z, those functions may not be loaded.</p></blockquote>

<p>所以在使用一些依赖关系比较复杂的静态库时，我们可能会看到这样的使用方式：gcc –o test main.c libtest1.a libtest2.a libtest1.a。在链接序列中，一个静态库可能出现多次，以解决一些循环依赖。</p>

<hr />

<p>另外的办法是指定Xlinker， 让ld链接的时候全局搜索符号， 但是明显效率会低很多。 所以维护一下依赖关系还是必要的。</p>

<p>ps: 刚刚看到<a href="http://weibo.com/raywill2" title="研究员Raywill">晓楚师兄</a>的博客里也有<a href="http://blog.csdn.net/maray/article/details/7666022" title="gcc库的链接顺序导致编译出错的问题">一篇</a>说这个事情的&hellip;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase源码分析-root_table_manager相关]]></title>
    <link href="http://cxh.me/2013/09/26/root-table-manager/"/>
    <updated>2013-09-26T12:15:00+08:00</updated>
    <id>http://cxh.me/2013/09/26/root-table-manager</id>
    <content type="html"><![CDATA[<p>记录一下root_table_manager相关类的阅读和心得。</p>

<!-- more -->


<h3>ObTableNameIterator</h3>

<p>一个Iterator, 用于获取所有的TableName</p>

<ul>
<li><p>init</p>

<p>初始化并调用scan_tables执行查询表名的sql语句</p></li>
<li><p>scan_tables</p>

<p>执行sql语句 &ldquo;select table_name, table_id from __all_table&rdquo; 来得到所有表的表名</p></li>
<li><p>get_next</p>

<p>获取下一个表名, 如果 table_idx_ &lt; 3 获取的是内部表的信息, 否则从sql执行结果中迭代返回普通表名</p>

<p>table_idx_对应的表名分别是:</p>

<p>&hellip;.</p></li>
<li><p>internal_get</p>

<p>获取内部表名</p></li>
<li><p>normal_get</p>

<p>获取普通表名</p></li>
</ul>


<h3>ObTableIdName</h3>

<p>顾名思义, TableId 和 TableName 的组合</p>

<h3>ObTableSchemaIterator</h3>

<p>获取TableSchema的迭代器</p>

<h3>ObRootSchemaService</h3>

<p>RootServer的Schema服务类, 提供rootserver所需的schema操作, 主要是读操作.</p>

<p>成员</p>

<p>方法</p>

<pre><code>init
写入
</code></pre>

<h3>RootTableService</h3>

<p>RootServer</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[防止通过rm误删文件]]></title>
    <link href="http://cxh.me/2013/09/22/avoid-delete-wrong-files-using-rm/"/>
    <updated>2013-09-22T20:46:00+08:00</updated>
    <id>http://cxh.me/2013/09/22/avoid-delete-wrong-files-using-rm</id>
    <content type="html"><![CDATA[<p>相信大家都有通过rm误删文件的经历, 而且Linux下又貌似没有Final Data之类的工具. 相对于Windows或者Nautilus里的删除机制, rm虽然高效, 但是很危险.</p>

<p>为了防止误删文件, 我们可以把删除的文件先转移到/tmp下, /tmp下的文件会被系统定时清除, 也就起到了回收站的作用.</p>

<p>这里我们首先建立如下脚本:</p>

<pre><code>#!/bin/sh 
dirpath=/tmp/recycle_$USER # find a place for recycle
now=`date +%Y%m%d_%H_%M_%S_`  
arg=$1
if [ "$arg" = "-rf" ] || [ "$arg" = "-fr" ] || [ "$arg" = "-r" ]; then # compatible with /bin/rm
    shift
    arg=$1
elif [ -d $arg ]; then # is a directory
    echo "rm: cannot remove '$arg': Is a directory"
    exit
fi
filename=${now}$arg # add a timestamp for files deleted
if [ ! -d ${dirpath} ];then  
    /bin/mkdir -p ${dirpath} 
    chmod 777 ${dirpath} 
fi 
/bin/mv $arg ${dirpath}/${filename} # move to trash
</code></pre>

<p>然后把脚本命名为rm放到/bin目录下, 最好放到home/bin目录下然后指定一下Path, 这样不影响其他人.</p>

<pre><code>export PATH=$HOME/bin:$PATH
</code></pre>

<p>最后记得给rm加权限就行</p>

<p>需要说明的一点是, 服务器端有时候为了限制rm会给rm做alias(别名), 所以以上rm脚本需要根据实际情况判断传入参数的序号, 比如如果有别名设置如下:</p>

<pre><code>alias rm='rm -i --preserve-root' 
</code></pre>

<p>就需要把上面的$1都改成$3, 钦此.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OceanBase源码分析-tablet相关]]></title>
    <link href="http://cxh.me/2013/09/16/oceanbase-source-analysis-tablet/"/>
    <updated>2013-09-16T15:49:00+08:00</updated>
    <id>http://cxh.me/2013/09/16/oceanbase-source-analysis-tablet</id>
    <content type="html"><![CDATA[<h3>ObRootTabletInfo</h3>

<p>Tablet是分布式系统里很重要的概念, 无论是分布式文件系统, 还是分布式数据库, tablet定义了</p>

<p>//TODO</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[oceanbase源码分析-Rowkey相关]]></title>
    <link href="http://cxh.me/2013/09/16/oceanbase-sources-analyze-roottable/"/>
    <updated>2013-09-16T12:55:00+08:00</updated>
    <id>http://cxh.me/2013/09/16/oceanbase-sources-analyze-roottable</id>
    <content type="html"><![CDATA[<p>这里分析一下ObRowkey相关的源码.</p>

<p> 引用<a href="http://blog.csdn.net/maray/article/details/9731113" title="OceanBase里面的rowkey是什么概念，是由哪些要素构成的？">晓楚师兄的一段话</a>:</p>

<ul>
<li>Rowkey是OceanBase诞生之初就引入的概念，最终被确立是在OceanBase 0.3。</li>
<li>为了便于理解，不妨把OceanBase想象成一个Key-Value系统，Rowkey就是Key，Value就是返回的行数据。</li>
<li>如果你对mysql数据库熟悉，那么不妨把Rowkey理解成primary key，它就是那几个主键列的组合，列的顺序与primary key中定义的顺序一致。</li>
</ul>


<!-- more -->


<h3>ObObjType</h3>

<p>定义了OceanBase中支持的基本数据类型,我们可以在ob_obj_type.h中看到其定义</p>

<h3>ObRowkeyColumn</h3>

<p>定义了RowKey中的每个列Column</p>

<h3>ObRowkeyInfo</h3>

<p>定义了RowkeyColumn的集合</p>

<h3>ObCellInfo</h3>

<p>从结构上可以看出，定义了一个cell的相关信息，主要包括了</p>

<pre><code>  ObString table_name_; //所在表名
  uint64_t table_id_;   //表id
  ObRowkey row_key_;    //所在行row_key_
  uint64_t column_id_;  //列id
  ObString column_name_;//列名
  ObObj value_;         //cell值
</code></pre>

<p>如下两个类与之有关联，一并写在这里</p>

<h3>ObRootTableRow:</h3>

<p>存储了RootTable中一行的信息，包括了rowkey列的数据和各个replica的版本信息</p>

<pre><code>  // 方法
  int input_tablet_row(const bool start_key, const ObRootTabletInfo &amp; tablet);
  int output_tablet_row(common::ObScanner &amp; result);
  // 成员
  common::ObObj rowkey_objs_[common::OB_MAX_ROWKEY_COLUMN_NUMBER];
  common::ObCellInfo row_cells_[common::OB_MAX_COLUMN_NUMBER];
</code></pre>

<p>着重分析一下input_tablet_row方法，首先拷贝rowkey，没有做深拷贝</p>

<pre><code>// copy the range end key as rowkey
rowkey_column_num_ = rowkey_len;
for (int64_t i = 0; i &lt; rowkey_column_num_; ++i)
{
  rowkey_objs_[i] = input_key.ptr()[i];
}
</code></pre>

<p>然后填充row_cells_，RootTable中一行的各个列信息，</p>

<pre><code>ADD_REPLICA_SERVER(normal_column_num_, i, replica-&gt;server_, replica-&gt;version_);
</code></pre>

<p>ADD_REPLICA_SERVER的定义如下：</p>

<pre><code>#define ADD_REPLICA_SERVER(column, index, server, version) \
{ \
    ObRowkey rowkey; \
    rowkey.assign(rowkey_objs_, rowkey_column_num_); \
    row_cells_[column].row_key_ = rowkey; \
    row_cells_[column].table_name_ = ObString::make_string("temp"); \
    row_cells_[column].column_name_ = ObString::make_string("version_"#index); \
    row_cells_[column].value_.set_int(version); \
    column++; \
    row_cells_[column].row_key_ = rowkey; \
    row_cells_[column].table_name_ = ObString::make_string("temp"); \
    row_cells_[column].column_name_ = ObString::make_string("port_"#index); \
    row_cells_[column].value_.set_int(server.get_port()); \
    column++; \
    row_cells_[column].row_key_ = rowkey; \
    row_cells_[column].table_name_ = ObString::make_string("temp"); \
    row_cells_[column].column_name_ = ObString::make_string("ip_"#index); \
    row_cells_[column].value_.set_int(server.get_ipv4()); \
    column++; \
}
</code></pre>

<p>同时填充了三个cell，分别是version，port，ip，对应了RootTable的表结构，这里顺便说一下RootTable内部表化之后的表结构定义：</p>

<p>range默认前开后闭，也就是说从检索tablet的时候的如果刚好有个tablet是以此endkey结尾的，那么这个tablet会被检索出来。如果检索的关键字是rowkey的话，那么这个rowkey所对应的tablet就是这个tablet而不是下一个tablet（如果tablet没有出现空洞的话），这个是系统里的约定，也是比较基础的规则了。</p>

<p>举个例子，如下的函数负责从一堆tablet里面找到刚好对应当前rowkey的tablet,我们来看函数的逻辑。</p>

<p>int ObRootTabletUtil::find_right_tablet(const ObRootTabletList &amp; list, const uint64_t table_id,</p>

<pre><code>const ObRowkey &amp; rowkey, ObRootTabletInfo &amp; tablet)
</code></pre>

<p>{
  int ret = OB_ENTRY_NOT_EXIST;
  for (int64_t i = 0; i &lt; list.list_.count(); ++i)
  {</p>

<pre><code>tablet = list.list_.at(i);
TBSYS_LOG(DEBUG, "iterator tablet:%s", to_cstring(tablet.meta_info_.range_));
if (tablet.meta_info_.range_.table_id_ &lt; table_id)
{
  continue;
}
else if (tablet.meta_info_.range_.table_id_ &gt; table_id)
{
  break;
}
else if (tablet.meta_info_.range_.end_key_ &lt; rowkey)
{
  continue;
}
else
{
  if (tablet.meta_info_.range_.start_key_ &gt; rowkey)
  {
    break;
  }
  else if (tablet.meta_info_.range_.start_key_ == rowkey)
  {
    // find the first root tablet
    if (rowkey.is_min_row())
    {
      ret = OB_SUCCESS;
    }
    break;
  }
  else
  {
    ret = OB_SUCCESS;
    break;
  }
}
</code></pre>

<p>  }
  if (ret != OB_SUCCESS)
  {</p>

<pre><code>// find the next tablet but not find the suitable tablet
if (list.list_.count() &gt; 0)
{
  TBSYS_LOG(WARN, "not find the tablet in root table has hole:rowkey[%s], tablet[%s]",
      to_cstring(rowkey), to_cstring(tablet.meta_info_.range_));
}
</code></pre>

<p>  }
  return ret;
}</p>

<h3>表名</h3>

<p>First Root Table 的 Table ID 为 111(固定值,暂定 111)
User Meta Table 和 User Root Table 为 User Table 的衍生 Table, 对外不可见, 在 User Table 创建时自动创建， Table Name 和 Table
ID 取值约定如下:要求 User Table ID 从 3000 以后取值。</p>

<p>如下所示：</p>

<p>Table Type          Table Name              Table ID
User Table          User Table Name         User Table ID
User Meta Table     <strong>User Table ID.META    User Table ID – 1
User Root Table     </strong>User Table ID.ROOT    User Table ID – 2
First Root Table    __first_root_table      111</p>

<p>Rowkey构成规则</p>

<p>Table Type          Table Rowkey
User Table          User Table Rowkey Columns
User Meta Table     Cluster ID + User Table ID + User Table Rowkey Columns
User Root Table     Cluster ID + User Meta Table ID + User Table ID + User Table Rowkey Columns
First Root Table    Cluster ID + User Root Table ID</p>

<p>表结构比较多，只捡主要的说：</p>

<p>FirstRootTable</p>

<h3>ObScanner</h3>
]]></content>
  </entry>
  
</feed>
