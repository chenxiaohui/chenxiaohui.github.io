<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | CXH.ME]]></title>
  <link href="http://cxh.me/category/python/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-01-12T17:21:37+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[redhat下升级python]]></title>
    <link href="http://cxh.me/2015/01/11/redhat-upgrade-python/"/>
    <updated>2015-01-11T18:56:00+08:00</updated>
    <id>http://cxh.me/2015/01/11/redhat-upgrade-python</id>
    <content type="html"><![CDATA[<p>  偶然发现服务器上的python是2.4的，好多语法都不支持。遂决定升级。</p>

<p>  首先yum升级是可以升级到2.6的：</p>

<pre><code>yum install python26
yum install python26-devel
yum install python26-setuptools
ln -s /usr/bin/python2.6 /usr/bin/python
</code></pre>

<p>  升级之后发现yum不能用了。yum应该是跟python版本绑定了，于是把yum头部改成：</p>

<pre><code>#!/bin/python2.4
</code></pre>

<p>  之后发现2.6还是不行&hellip;我是用了多新的语法啊&hellip;就是几个dict comprehension。于是决定升级到2.7。源里面没有，只能手动。</p>

<pre><code>#wget http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2  
#tar -jxvf Python-2.7.3.tar.bz2
#cd Python-2.7.3  
#./configure  
#make all             
#make install
#ln -s /usr/local/bin/python2.7 /usr/bin/python  
</code></pre>

<p>  安装setup-tools</p>

<pre><code>wget https://pypi.python.org/packages/source/s/setuptools/setuptools-11.3.1.zip --no-check-certificate
unzip setuptools-11.3.1.zip
cd setuptools-11.3.1
python setup.py install
</code></pre>

<p>  yum不用动了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django重定向的参数传递]]></title>
    <link href="http://cxh.me/2015/01/05/django-redirect-render/"/>
    <updated>2015-01-05T15:55:00+08:00</updated>
    <id>http://cxh.me/2015/01/05/django-redirect-render</id>
    <content type="html"><![CDATA[<p>  其实就是想实现如下一个功能，重定向到一个网页，但是这个网页根据传参的不同显示不同的内容。基于Django各种render的shortcut理所当然的想有没有render_redirect，但是想想网络请求的流程，redirect只是返回了一个302，让浏览器直接去请求新的网页了，首先这个response很简单没有携带其他信息，此外，浏览器也不会把302code和url之外的内容作为下一次请求的参数。</p>

<p>  可行的办法还是用get参数。针对遇到的需求：传入不同的参数的时候在不同的div上显示class=active，我们可以简化的实现如下：</p>

<pre><code>模板：
  &lt;div role="tabpanel" class="tab-pane " id="a"&gt;
  &lt;div role="tabpanel" class="tab-pane " id="b"&gt;
  &lt;div role="tabpanel" class="tab-pane " id="c"&gt;
后台：
  init = request.GET.get('init', 'a')#a是默认active的tab
  return render(request, 'xx.html', {init:'active'})
跳转：
  return HttpResponseRedirect("/?init=b")
</code></pre>

<p>  直接用传入参数当了render参数的名字。<code>request.GET.get('init', 'a')</code>保证了无参数的时候active a作为默认值。django容错保证了没有的变量置空。基本够用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Python字典解析中进行update]]></title>
    <link href="http://cxh.me/2015/01/05/python-dict-update-in-comprehensions/"/>
    <updated>2015-01-05T13:25:00+08:00</updated>
    <id>http://cxh.me/2015/01/05/python-dict-update-in-comprehensions</id>
    <content type="html"><![CDATA[<p>  遇到这样一个事情，从一个Thrift源取回部分数据，结构是一个对象数组，根据其中所有的Id字段从数据库又取回另一部分数据，结构是一个字典数组。那么问题来了，<del>挖掘机技术哪家强</del>如何按照id合并两份数据?</p>

<p>  这其实就是JOIN，也就两种做法，nested loop join和hash join（这些词都是在ob的时候听到的，其实道理很简单）。做nested loop join的话，最好按排序，做hash join的话，就需要把其中一份数据的变成以id字段为key的字典。这里我们选择后一种，python代码实现起来比较简洁。前一种貌似只能for循环搞下标，不知道有没有直接的built in function。</p>

<p>  代码比较简单，就是遇到了一个有代表性的问题：</p>

<pre><code>results = [result.update(items[result['id']])) for result in results]
</code></pre>

<p>  id字段是join的key，results是从数据库取到的，items是从thrift取到的。关键问题在于update的结果是None，result是被原地修改的。所以需要改成下面：</p>

<pre><code>results = [dict(result.items() + items[result['id']].items()) for result in results]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GDB/PDB调试时变量的监视]]></title>
    <link href="http://cxh.me/2012/12/19/watch-variables-when-debuggin-with-gdb-and-pdb/"/>
    <updated>2012-12-19T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/12/19/watch-variables-when-debuggin-with-gdb-and-pdb</id>
    <content type="html"><![CDATA[<p>  gdb下有几个监视变量的命令，比如watch可以监视一个变量是否更改，rwatch监视读，awatch监视写等等。这里说的主要是另一个命令，display。</p>

<p>  display命令做的事情是指定一个变量，然后在每次调试停住的时候显示这个变量的值。这个是很有用的操作，等于在命令行调试的时候提供了类似于IDE里监视变量（Add to Watch）的功能。但是一直没有发现python的调试工具pdb里有类似的功能。后来在Python官方文档里看到一个命令:commands，提供了类似的功能。</p>

<p>  commands命令的使用是 commands [bpnumber] 。bpnumber指定了断点的id（集），省略的话表示上一个断点（集）。之后可以输入需要做的事情，然后以end结尾，一个简单的例子如下：</p>

<pre><code>(Pdb) commands 1
(com) print some_variable
(com) end
(Pdb)
</code></pre>

<p>  commands有一个明显的问题，就是如果停在其他断点的地方，就会终止这个commands，以后即使执行到了这个断点，也不会再执行该commands，官方的解释是：</p>

<blockquote><p>Specifying any command resuming execution (currently continue, step, next, return, jump, quit and their abbreviations) terminates the command list (as if that command was immediately followed by end). This is because any time you resume execution (even with a simple next or step), you may encounter another breakpoint–which could have its own command list, leading to ambiguities about which list to execute.</p></blockquote>

<p>  但是这个明明是说只要恢复执行，commands就失效啊…但是实际上比如你只打了一个断点，然后在这个断点定义了commands，之后每次都是用continue，这是不会导致该断点失效的，毕竟没有encounter another breakpoint–which could have its own command list嘛。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Django url映射的一些小问题]]></title>
    <link href="http://cxh.me/2012/10/03/some-problems-of-django-url-mapping/"/>
    <updated>2012-10-03T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/03/some-problems-of-django-url-mapping</id>
    <content type="html"><![CDATA[<h1></h1>

<p>  之前写Django一直没想着去用patterns的prefix，偶然用的时候发现总不起作用，后来才发觉原来是写法的问题</p>

<pre><code>urlpatterns = patterns('book.views',
    (r'^(\w ).html$', 'default_render'),
)
</code></pre>

<p>  在这种情况下肯定是没问题的，但是不排除会有同学跟我一样的写成如下的格式</p>

<pre><code>urlpatterns = patterns('book.views',
    (r'^(\w ).html$', default_render),
)
</code></pre>

<p>  看到差别了吧，只有字符串才可以拼接嘛。</p>

<p>  另外是关于Django 1.4之后的路径的问题，每个app被放到跟主project同级的目录，所以引用的时候都变成与project同级的模块。比如有一个叫test的project，那么test里的urls.py必然是test.urls，而某个app里的urls.py显然已经不是test.app.urls而是app.urls了。</p>

<p>  纯mark之。水文勿喷….</p>
]]></content>
  </entry>
  
</feed>
