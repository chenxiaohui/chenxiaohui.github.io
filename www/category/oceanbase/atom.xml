<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Oceanbase | CXH.ME]]></title>
  <link href="http://cxh.me/category/oceanbase/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-11-08T21:45:30+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[vim日志定位解决方案]]></title>
    <link href="http://cxh.me/2013/11/08/solution-to-locate-log-in-src/"/>
    <updated>2013-11-08T21:31:00+08:00</updated>
    <id>http://cxh.me/2013/11/08/solution-to-locate-log-in-src</id>
    <content type="html"><![CDATA[<p>  做分布式系统看日志解决问题是基本功了，毕竟多个server跑在不同的机器上，即使用gdb能attach到某个进程上，或者<a href="http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob/" title="用gdb调试分布式系统（OB中的应用）">用非daemon模式启动并调试</a>但是case往往很复杂，难以用测试环境完全模拟case，所以大部分情况下还是需要看日志解决问题的。</p>

<p>  不过日志多了之后往往容易跟丢，在浩如烟海的日志里面定位到发生错误的地方也不是见容易的事情。这周大部分时间就费在这上面了（不过还是不熟）。期间写了一个简单的vim插件实现日志的定位。想法如下：</p>

<!-- more -->


<p>  偶然发现通过deploy.py ob1.rs0.less打开less窗口之后按v键可以转到vim窗口，这就解决很多问题了，毕竟我可不想在less下实现什么功能。vim script就熟悉多了。</p>

<p>  ob的log格式是这样的</p>

<pre><code>[2013-11-08 20:02:23.698586] WARN  get_schema (ob_root_schema_service.cpp:296) [139800896067328] local schema not inited 
</code></pre>

<p>  可以看出关键的地方是打印日志的文件和行数，所以我们用正则\w+.c(pp)*:\d+（vim里需要转义）来匹配日志行，得到所在文件和行数之后用执行ssh命令去开发机的项目下find对应的文件，把找到的结果写入某个特定文件（~/.session)里面，之后写一个插件根据文件中的记录打开对应的文件并标红对应的行即可。</p>

<p>  定位log的vim脚本实现如下：</p>

<pre><code>if !exists('g:project_base_dir')
    let g:project_base_dir = '$HOME/dev $HOME/src'
endif

if !exists('g:user_name')
    let g:user_name = 'xxxx'
endif

if !exists('g:server_ip')
    let g:server_ip = 'xx.xx.xx.xx'
endif

function! LogSession() range
    let filearr = []
    for linenum in range(a:firstline, a:lastline)
        let curr_line = getline(linenum)
        let pos_str = matchstr(curr_line,'\(\w\+\)\.c\(pp\)*:\(\d\+\)')
        let pos_arr = split(pos_str, ":")
        if !empty(pos_arr)
            let filename = pos_arr[0]
            let linenum = pos_arr[1]
            if index(filearr, filename) == -1
                "generate file list
                let session_cmd = "find ". g:project_base_dir ." -name ". filename .' -exec echo "{}"":'.linenum.'" &gt;&gt;~/.session \;'
                let ssh_cmd = "!ssh ".g:user_name.'@'.g:server_ip." \'".session_cmd."\'"
                echo ssh_cmd
                execute ssh_cmd
                execute ':call Vm_toggle_sign()'
                call add(filearr, filename)
            endif
        endif
    endfor
endfunction
</code></pre>

<p>  解释几点</p>

<ul>
<li>g:project_base_dir定义源码所在目录，如果源码引用了其他的库，最好把其他库的源码目录一并指定。</li>
<li>g:user_name 开发机用户名，这是你源码所在机器的用户名</li>
<li>g:server_ip 开发机IP，这是你的源码所在机器的IP，保证能够无密码登录。</li>
</ul>


<p>  这样在测试机看log的less窗口里面按v进入vim（vim脚本需要部署到开发机和测试机各一份），然后在对应的行（或者多行）执行LogSession，对应的文件位置信息就被写入开发机的~/.session文件里面（这个应该可以配置，忘了做了）。</p>

<p>  另开一个窗口ssh到开发及，打开.session，应该类似于如下：</p>

<pre><code>/home/xxx.xx/dev/src/rootserver/ob_root_server.cpp:584
/home/xxx.xx/dev/src/rootserver/ob_root_server.cpp:2183
/home/xxx.xx/dev/src/rootserver/ob_root_inner_table_task.cpp:175
</code></pre>

<p>  定位到某一行调用插件打开代码就行，这就涉及到[前文所说的插件了][2]。按照快捷键打开对应的行就行。</p>

<p>  之后在vimrc里面映射键就行了</p>

<pre><code>map &lt;leader&gt;ss :call LogSession()&lt;cr&gt;
nnoremap &lt;leader&gt;co :call OpenFileWithDefApp()&lt;cr&gt;
let g:applist={
        \'pdf':'evince',
        \'png,gif,jpg':'eog',
        \'rmvb,mkv,flv,avi,mp4,m4v':'mplayer',
        \'rar':'!unrar l %',
        \'epub':'!calibre %',
        \'zip':'!unzip -O CP936 -l %',
        \'pwd':'nautilus',
        \'docx,xlsx,pptx,ppt':'libreoffice',
        \'default':':e %'
        \}
</code></pre>

<p>  截图如下：</p>

<p>  <img class="img-polaroid center" src="/images/2013-11/three-log.png" title="&ldquo;log文件&rdquo; &ldquo;log文件&rdquo;" ></p>

<p>  <img class="img-polaroid center" src="/images/2013-11/two-line.png" title="&ldquo;定位到对应的源码行&rdquo; &ldquo;定位到对应的源码行&rdquo;" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何构建按高可用系统（分享的笔记）]]></title>
    <link href="http://cxh.me/2013/11/01/how-to-build-high-available-system/"/>
    <updated>2013-11-01T18:42:00+08:00</updated>
    <id>http://cxh.me/2013/11/01/how-to-build-high-available-system</id>
    <content type="html"><![CDATA[<p>版权所有：<a href="">解伦师兄</a></p>

<h3>介绍篇</h3>

<p><strong>可用性vs可靠性</strong></p>

<p>  可用性主要是从时间的角度看，可靠的时间。可靠性主要是看不可用的频率。如果一个系统1小时宕机1ms，可用性非常高，可靠性非常低。</p>

<p>  可用性可靠性是系统的工程，设计开发，管理，运维等等。</p>

<p>  宕机几大因素：软件-硬件-网络-人为</p>

<p>  data loss的最大因素：drop table, 所以要做好充分的容错。</p>

<!-- more -->


<h3>设计篇</h3>

<p><strong>减少故障发生的可能</strong></p>

<p>  避免单点故障，防止扩散，有效的监控运维配合</p>

<p>  常见的<strong>冗余</strong>设计。</p>

<ul>
<li>RAID,Replica,Erasure Code</li>
<li>BackUp, Reassign,Retry</li>
<li>Master-Slave,Mirror,RAC..</li>
</ul>


<p>  减少对外部系统强依赖</p>

<ul>
<li>缓存</li>
<li>异步替代同步</li>
</ul>


<p>  对外部依赖不信任</p>

<ul>
<li>结果进行</li>
<li>失败情况下failover（重试时间次数需要控制）</li>
</ul>


<p>  有效的内部监控</p>

<p><strong>减少故障恢复时间</strong></p>

<p>  无状态最好</p>

<ul>
<li>有状态定期做持久化（checkpoint/commitlog)</li>
</ul>


<p>  有效的故障隔离</p>

<ul>
<li>故障检测，黑白名单，流量分配</li>
<li>黑名单要有恢复机制</li>
</ul>


<p><strong>减少损失</strong></p>

<p>  过载保护</p>

<ul>
<li>发现故障，并限制资源</li>
</ul>


<p>  应用降级</p>

<ul>
<li>关闭部分不重要的功能(某些情况下用户也感觉不出来)</li>
</ul>


<p>  有个故事：二战的时候（好背景），坦克设计的时候每次发射炮弹，都会有电磁波导致所有软件挂掉，所以故障恢复就很重要。</p>

<h3>案例篇</h3>

<p><strong>Twitter</strong></p>

<p>  世界杯额时候twitter经常会时常挂掉</p>

<ul>
<li>memcache规划的问题</li>
<li>cache也要注意设计</li>
</ul>


<p><strong>Foursquare</strong></p>

<p>  数据不均，mongodb数据量超过内存之后性能非常差(mmap的问题)</p>

<ul>
<li>数据迁走之后有空洞，页不释放</li>
<li>还好毕设的时候数据量不大</li>
</ul>


<p><strong>Amazon</strong></p>

<p>  EBS主网络走数据，备网络走控制，操作失误，主网络切到备网络</p>

<ul>
<li>相应超时，认为丢失副本</li>
<li>副本复制，继续加剧网络问题</li>
</ul>


<p><strong>Weibo</strong></p>

<p>  热点存在，cache失效，一瞬间所有访问db</p>

<ul>
<li>加锁，一个人获取内容回填cache之后就不会有人去访问db了</li>
</ul>


<p><strong>Facebook</strong></p>

<p>  cache没取到就删除了原cache</p>

<p><strong>OB</strong></p>

<p>  客户端要做分流，业务高峰，超时严重，把cluster都加入黑名单，重试风暴</p>

<h3>总结篇</h3>

<p><strong>可用性</strong></p>

<ul>
<li>BASE:基本可用</li>
<li>CAP:No CAP, No CP, A是很重要的</li>
<li><a href="">20 Key High Availability Design Principles</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用gdb调试分布式系统（OB中的应用）]]></title>
    <link href="http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob/"/>
    <updated>2013-10-29T13:40:00+08:00</updated>
    <id>http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob</id>
    <content type="html"><![CDATA[<p>  分布式系统开发的时候我们最经常遇到的问题就是，从一个server发送了一条报文之后怎么在另一个server查看这条报文的处理逻辑是否正确，单机的debug都不是问题，但是多机debug怎么做呢？</p>

<p>  在ob团队里面，正常情况下我们有如下三种方式处理这些问题：</p>

<ol>
<li> 做mock，写单测，隔离开集群环境</li>
<li> 加调试日志，部署集群环境，看日志。</li>
<li> 非daemon模式下通过gdb调试。</li>
</ol>


<p>  这里我们详细说一下第三种。这也是最有效果的一种。</p>

<!-- more -->


<p>  需要强调的是，正常情况下ob启动之后各个server会以守护进程方式运行，这时候如果用gdb启动server的话，gdb不知道在fork之后跟哪个进程，而在我测试下，<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/" title="使用 GDB 调试多进程程序">set follow-fork-mode</a>貌似也没成功过。</p>

<p>  所以最好的方法是直接不要通过守护进程启动，我们在部署ob到home目录下，集群名用ob1，.gdbinit里面写入：</p>

<pre><code>cd ~/ob1
file bin/rootserver
set args -r 10.235.162.8:3500 -R 10.235.162.8:3500 -i eth0 -C 1 -N
break "/home/xiaohui.cpc/roottable_dev/src/rootserver/ob_root_worker.cpp:2053"
break "/home/xiaohui.cpc/roottable_dev/src/rootserver/ob_root_worker.cpp:941"
</code></pre>

<p>  参数里面加-N表示不以daemon方式启动。</p>

<p>  这样通过gdb可以启动rootserver，然后同样启动其他需要的server，就可以调试在gdb里面看到程序执行后停在断点的位置。启动脚本如下，这里我们只启动了chunkserver。</p>

<pre><code>#!/bin/bash
rs_ip=10.235.162.8
rs_port=3500
cs_port=3501
ups_port=3502
ms_port=3503
freeze_port=3504
mysql_port=3505
net=bond0
appname=ob1.xiaohui.cpc
no_daemon=-N

#bin/rootserver -r $rs_ip:$rs_port -R $rs_ip:$rs_port -i $net -C 1 $no_daemon
bin/chunkserver -r $rs_ip:$rs_port -p $cs_port -n $appname -i $net $no_daemon

#bin/updateserver -r $rs_ip:$rs_port -p $ups_port -m $freeze_port -i $net $no_daemon
#bin/mergeserver -r $rs_ip:$rs_port -p $ms_port -z $mysql_port -i $net $no_daemon

#bin/rs_admin -r $rs_ip -p $rs_port set_obi_role -o OBI_MASTER
#bin/rs_admin -r $rs_ip -p $rs_port -t 60000000 boot_strap $no
</code></pre>

<p>  断点命中的情况如图1所示：</p>

<p>  <img class="img-polaroid center" src="/images/2013-10/gdb_multi_server.png" title="&ldquo;图1：断点命中的情况&rdquo; &ldquo;图1：断点命中的情况&rdquo;" ></p>

<p>  唯一的问题是gdb有时候会退出，如图2。感觉上是rpc超时了？</p>

<p>  <img class="img-polaroid center" src="/images/2013-10/gdb_quit.png" title="&ldquo;图2：gdb退出&rdquo; &ldquo;图2：gdb退出&rdquo;" ></p>

<p>  感谢玩大数据的<a href="http://weibo.com/hanfooo" title="韩富晟 支付宝颜然，玩大数据的，OceanBase工程师">颜然师兄</a>提供非daemon方式启动的方法。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 使用 GDB 调试多进程程序, <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/">http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/</a></p>

<p>[2] 韩富晟 支付宝颜然，玩大数据的，OceanBase工程师, <a href="http://weibo.com/hanfooo">http://weibo.com/hanfooo</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
