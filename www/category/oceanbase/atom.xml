<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Oceanbase | CXH.ME]]></title>
  <link href="http://cxh.me/category/oceanbase/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-06-28T14:35:21+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据库锁和隔离级别的总结]]></title>
    <link href="http://cxh.me/2016/04/03/summarize-isolation-lock/"/>
    <updated>2016-04-03T19:34:00+08:00</updated>
    <id>http://cxh.me/2016/04/03/summarize-isolation-lock</id>
    <content type="html"><![CDATA[<p>  最近在琢磨MVCC和悲观乐观锁的问题，感觉有些以前学习的点没有串联起来，主要是隔离级别和锁相关的，这里总结思考一下：</p>

<ol>
<li><p> 两阶段锁解决了什么问题</p>

<p>两阶段锁主要解决事务调度的可串行化，保证了调度是正确的。一个简单的例子参考<a href="http://baike.baidu.com/view/3798716.htm" title="两阶段封锁">度娘</a>这里。</p></li>
<li><p> 实现两阶段锁对应了什么隔离级别。</p>

<p>两阶段锁保证了基本的隔离级别正确性，RC之上的隔离级别（包含RC）都需要至少保证两阶段锁。一个例外是如果where条件不走索引的话，是可能全表加锁的，这种情况下mysql为了性能提前解锁了不满足条件的行，参见<a href="http://hedengcheng.com/?p=771#_Toc374698312" title="MySQL 加锁处理分析">这里</a>。</p></li>
<li><p> 各个隔离级别对应的加锁策略。</p>

<p>这个比较简单了：</p>

<ul>
<li>RU：读加S锁，写加X锁，完成即可释放。</li>
<li>RC：读加S锁，写加X锁，读锁完成可释放，写锁一直到事务完成再释放。</li>
<li>RR：读加S锁，写加X锁，读写锁都一直到事务完成再释放。</li>
<li>SE: RR基础上再加范围锁。</li>
</ul>
</li>
<li><p> select如何防止丢失更新。</p>

<p>按照<a href="http://hedengcheng.com/?p=771#_Toc374698312" title="MySQL 加锁处理分析">何登成</a>博客里面的定义，可以区分MVCC下两种读。</p>

<p>快照读</p>

<ul>
<li>select * from table where ?;</li>
</ul>


<p>当前读。</p>

<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert into table values (…);</li>
<li>update table set ? where ?;</li>
<li>delete from table where ?;</li>
</ul>


<p>快照读级别下，写事务可能丢失更新，因为select并不阻塞写，两个读写事务可能基于同一个快照点。当前读级别下，写阻塞读，所以涉及同一行的读写事务一定是串行的。不会丢失更新。</p>

<p>基于乐观锁的方式下，也不会丢失更新，因为检查到更新可能被覆盖的操作都会回滚（打回重试）了。</p></li>
<li><p> MVCC和锁（悲观乐观）的实现方式下，隔离级别是怎么实现的？</p>

<p>MVCC主要针对冲突数据的处理，乐观锁、悲观锁决定了最终原子的更新一行的方式。</p>

<p>MVCC加乐观锁的方式基本思路如下：</p>

<blockquote><p>定义一个keyValueSet，Conditional Update在此基础上加上了一组更新条件conditionSet { … data[keyx]=valuex, … }，即只有在D满足更新条件的情况下才将数据更新为keyValueSet’；否则，返回错误信息。<a href="http://coolshell.cn/articles/6790.html" title="多版本并发控制(MVCC)在分布式系统中的应用">引用</a></p></blockquote>

<p>MVCC加悲观锁主要是提供了不加锁的读。按<a href="http://hedengcheng.com/?p=771#_Toc374698312" title="MySQL 加锁处理分析">何登成</a>的文章里看，就是快照读+当前读。快照读级别下，直接按照版本读就行，当前读级别下，如果有锁冲突还是要加锁。</p>

<p>在ob里的实现上看比较明显，行的修改增量组织为一棵B树，历史版本表现为B树叶子节点上挂的链表。链表的按照版本号串接起所有历史版本，全局Publish version决定了当前可见的最新版本。</p>

<p>在快照读级别下，select不需要加锁，只需要每次按照publish version去链表遍历，找到可见的结果并返回。如果不修改transaction consistency set的情况下，这种读取可能导致两次读结果不一致，不满足RR或者SI(Snapshot Isolation)。OB0.5增加了一个readonly snapshot的级别，可以提供对一个快照的只读操作，保证了多次读取的一致，但是没有snapshot级别不加锁的读写事务（快照写），毕竟基于一个旧的快照做写操作可能使新的提交丢失。这里要么类似乐观锁验证一下版本，要么加锁来延迟读写。</p>

<p>当前读级别下，select也要加锁直到事务结束释放，跟mysql的实现一致。</p>

<p>总结来讲，如果把当前读看成写事务的话，那么ob事实上是读操作只看版本号，写操作只看锁。如果只考虑当前读和写操作的话，那么相当于有冲突的时候读锁延迟了写操作，写锁延迟了读操作，保证了调度的串行。这种情况下，多次读取的结果是一致的。</p></li>
<li><p> select for update在mvcc下如何实现。</p>

<p>道理是一样的，跟mvcc没什么关系，select for update实际上相当于写事务（select的时候加写锁，直到事务结束再释放，update操作本身也是一样的过程，先检索符合条件的记录加锁，再修改并提交，这样才能保证是原子的）</p></li>
<li><p> 分布式环境下的快照读</p>

<p>单点的快照相对来讲比较容易，因为每次可以取一下publish version，来决定什么是可以读取的，但是分布式环境下，每个点读取的时候不能总去看全局publish version(似乎也可以)， 这样本地读取的时候可能由于时间偏移出现全局本地开启事务的时间戳大于全局publish version的问题，</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统/NOSQL入门书单]]></title>
    <link href="http://cxh.me/2014/10/20/distribute-system-guide/"/>
    <updated>2014-10-20T11:26:00+08:00</updated>
    <id>http://cxh.me/2014/10/20/distribute-system-guide</id>
    <content type="html"><![CDATA[<p>  简单记一下我看过的和觉得值得看的。主要是给@赵龙作为参考。</p>

<ul>
<li>分布式相关</li>
</ul>


<blockquote><p>[1] 大规模分布式存储系统, <a href="http://book.douban.com/subject/25723658/">http://book.douban.com/subject/25723658/</a>
  阿里日照的书，全面介绍了分布式系统的原理和实践，入门不可多得的书</p>

<p>[2] 分布式系统原理介绍, <a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=31413">http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=31413</a>
  百度刘杰的，讲基本的分布式原理，有些笔误什么的。</p>

<p>[3] paxos算法相关, <a href="http://cxh.me/2014/08/26/paxos-study/">http://cxh.me/2014/08/26/paxos-study/</a>
  总结了paxos算法一些资料。</p>

<p>[5] 分布式数据库系统原理, <a href="http://product.dangdang.com/23466507.html">http://product.dangdang.com/23466507.html</a>
  分布式数据库的一本教材。</p>

<p>[6] The Raft Consensus Algorithm, <a href="http://raftconsensus.github.io/">http://raftconsensus.github.io/</a>
  raft相关的资料，论文和一些实现都能在里面找到，另外有一个图形化的展示很方便。</p>

<p>[7] Raft介绍, <a href="http://www.slideboom.com/presentations/956855/Raft%E4%BB%8B%E7%BB%8D">http://www.slideboom.com/presentations/956855/Raft%E4%BB%8B%E7%BB%8D</a>
  raft的一个ppt。</p></blockquote>

<ul>
<li>数据库相关</li>
</ul>


<blockquote><p>[1] 数据库系统实现, <a href="http://item.jd.com/10060181.html">http://item.jd.com/10060181.html</a>
  数据库的一本教材，偏重于实现。</p>

<p>[2] 数据挖掘概念与技术, <a href="http://book.douban.com/subject/2038599/">http://book.douban.com/subject/2038599/</a>>[3] 事务相关, <a href="http://cxh.me/2014/07/02/article-on-transaction/">http://cxh.me/2014/07/02/article-on-transaction/</a></p>

<p>[3] 事务相关, <a href="http://cxh.me/2014/07/02/article-on-transaction/">http://cxh.me/2014/07/02/article-on-transaction/</a>
  总结了事务相关的一些资料。</p></blockquote>

<ul>
<li>NOSQL相关</li>
</ul>


<blockquote><p>[1] Dynamo论文, <a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a></p>

<p>[2] bigtable论文, <a href="http://research.google.com/archive/bigtable-osdi06.pdf">http://research.google.com/archive/bigtable-osdi06.pdf</a></p>

<p>[3] gfs论文, <a href="http://research.google.com/archive/gfs-sosp2003.pdf">http://research.google.com/archive/gfs-sosp2003.pdf</a></p>

<p>[4] map reduce论文, <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf">http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf</a></p>

<p>[5] Redis 设计与实现, <a href="http://redisbook.com/en/latest/">http://redisbook.com/en/latest/</a>
  一本不错的讲redis的书。</p>

<p>[6] 数据分析与处理之二（Leveldb 实现原理）, <a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html</a>
  leveldb的实现。</p>

<p>[7] Memcached 源码剖析笔记, <a href="http://files.cppblog.com/xguru/Memcached.pdf">http://files.cppblog.com/xguru/Memcached.pdf</a>
  memcache的源码。</p></blockquote>

<ul>
<li>基础</li>
</ul>


<blockquote><p>[1] UNIX环境高级编程, <a href="http://book.douban.com/subject/1788421/">http://book.douban.com/subject/1788421/</a></p>

<p>[2] UNIX网络编程, <a href="http://book.douban.com/subject/1500149/">http://book.douban.com/subject/1500149/</a></p></blockquote>

<ul>
<li>一些博客</li>
</ul>


<blockquote><p>[1] 银河里的星星的博客, <a href="http://duanple.blog.163.com/">http://duanple.blog.163.com/</a>
  主要是分布式领域的论文和翻译。</p>

<p>[2] 章炎的技术博客, <a href="http://dirlt.com/">http://dirlt.com/</a></p>

<p>[3] 何登成的技术博客, <a href="http://hedengcheng.com/">http://hedengcheng.com/</a> 大牛不解释</p>

<p>[4] 淘宝核心系统团队博客, <a href="http://csrd.aliapp.com/">http://csrd.aliapp.com/</a></p>

<p>[5] 吴镝 <a href="http://www.cnblogs.com/foxmailed/">http://www.cnblogs.com/foxmailed/</a> 专注系统，基础架构，分布式系统</p></blockquote>

<p>  都看还是需要时间的，我只是读完了一部分翻完了一部分，很多还需要再看一遍。分布式系统最好的学习方法当时是实现一个分布式系统，像晓楚<a href="https://github.com/raywill/macraykv" title="Macrakv">macrakv</a>这样，但是工程量和难度比较大，退而求其次的办法是看源码，redis/hbase/leveldb/memcached都是不错的例子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paxos算法学习]]></title>
    <link href="http://cxh.me/2014/08/26/paxos-study/"/>
    <updated>2014-08-26T20:53:00+08:00</updated>
    <id>http://cxh.me/2014/08/26/paxos-study</id>
    <content type="html"><![CDATA[<p>  本来想写点东西，后来觉得都是一知半解。这里转载一点学习资料吧。</p>

<p>  一个是知行学社的分布式系统与Paxos算法视频课程，循序渐进，讲解地比较浅显易懂。</p>

<p>  <embed src="http://www.tudou.com/v/e8zM8dAL6hM/&bid=05&rpid=51943457&resourceId=51943457_05_05_99/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"></embed></p>

<p>  另一个是百度刘杰<a href="http://www.valleytalk.org/2012/07/12/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%8B-%E3%80%82%E7%99%BE%E5%BA%A6-%E3%80%82%E5%88%98%E6%9D%B0/" title="《分布式系统原理介绍》">《分布式系统原理介绍》</a>。当然Lamport的几篇论文是不能不看的，虽然都不太好懂。</p>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" title="The Part-Time Parliament">The Part-Time Parliament</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" title="paxos made simple">Paxos Made Simple</a></li>
<li><a href="https://www.andrew.cmu.edu/course/15-749/READINGS/required/resilience/lamport82.pdf" title="The Byzantine Generals Problem">The Byzantine Generals Problem</a></li>
</ul>


<p>  相比较而言，<a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)" title="Paxos (computer science)">paxos的wiki</a>可能更好懂一些。有余力的同学可以做一下<a href="http://css.csail.mit.edu/6.824/2014/" title="MIT Distributed Systems Labs">MIT Distributed Systems Labs</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两阶段提交协议的异常处理]]></title>
    <link href="http://cxh.me/2014/07/07/two-process-commit-exceptions/"/>
    <updated>2014-07-07T11:57:00+08:00</updated>
    <id>http://cxh.me/2014/07/07/two-process-commit-exceptions</id>
    <content type="html"><![CDATA[<p>  两阶段提交的协议大家都比较熟悉了，解释一下每个阶段的异常处理。首先，我们需要持久化协议过程中的状态，这样如果server宕机，那么恢复的时候还能通过日志知道宕机前处于那个阶段。同时，所有对数据的修改都会先写write ahead log，保证宕机重启的之后数据也不会丢失。写日志的顺序假定为:写write ahead log-修改缓冲区-写commit/abort log。</p>

<p>  在这个前提下，我们根据如下的时序图来讨论异常情况和处理方法。</p>

<p><img class="img-polaroid center" src="/images/2014/2pc.png" title="&ldquo;两阶段提交协议时序&rdquo; &ldquo;两阶段提交协议时序&rdquo;" ></p>

<ol>
<li><p> 过程a没有成功，即协调者没有收到部分参与者的回应。超时后，协调者发送abort消息给参与者取消事务。参与者存在两种情况：</p>

<ul>
<li>过程1失败，网络问题导致参与者没有收到vote request消息或者此时参与者宕机。参与者重启恢复后无需做任何事。</li>
<li>过程2失败，参与者收到了vote request，网络问题协调者没有收到回复或此时参与者宕机。参与者宕机恢复或等待超时后广播DECISION_REQUEST消息向其他参与者询问是否收到commit/abort消息。</li>
</ul>
</li>
<li><p> 过程b没有成功，即协调者发送commit消息之后没有收到部分参与者的回应。协调者需要重试，确认参与者的提交完毕消息，如果多次尝试不能联系上，则等待参与者上线之后解决。参与者存在两种情况：</p>

<ul>
<li>过程3失败，网络问题导致参与者没有收到commit消息或此时参与者宕机。参与者上线发现在本地日志中发现尚未提交成功，因为到达这里，可以肯定本地已做好提交准备，但是不知道协调者是决定提交，所以向协调者询问，按协调者的回复来进行提交或回滚。如果无法联系上协调者，则向其他参与者询问事务状态，如果有某一个节点已经做了提交或异常终止(说明协调者已发送了相关消息)，则做同样的操作。</li>
<li>过程4失败，参与者完成了commit/rollback，但是网络问题协调者没有收到回应或者此时参与者宕机。参与者在本地日志中发现已完成本地提交，所以可能由于网络故障导致提交完成消息没有到达协调者。所以直接忽略。这时可能协调者在等待该参与者的提交完成回应消息，所以参与者主动联系协调者告知事务状态。</li>
</ul>
</li>
<li><p> 过程c没有成功，即参与者发送vote回应消息之后没有等到协调者的commit/rollback消息。这个过程参与者的异常处理已经讨论过了，这里讨论协调者的异常处理。存在两种情况：</p>

<ul>
<li>过程2失败，网络问题导致协调者没有收到回复或此时协调者宕机。协调者恢复重启后，发现并未做提交操作，保险操作(因为不知道它是否发送过准备消息，或其他参与者是否做好提交准备)，直接发送abort消息给所有参与者，终止事务</li>
<li>过程3失败，网络问题导致参与者没有收到commit/rollback消息或者此时协调者宕机。协调者恢复重启后，不能保证所有参与者都已收到了提交消息，所以给所有的参与者发送commit消息，保证事务的正常提交。</li>
</ul>
</li>
</ol>


<!--more-->


<p>  算法的伪代码可以参考如下代码，摘自《Distributed Systems: Principles and Paradigms》。</p>

<p>  <strong>Actions of Coordinator</strong></p>

<pre><code>write("START_2PC tolocal log");
multicast("VOTE_REQUESTto all participants");
while(not all votes have been collected)
{
  waitfor("any incoming vote");
  if(timeout)
  {
    write("GLOBAL_ABORT to local host");
    multicast("GLOBAL_ABORT to all participants");
    exit();
  }
  record(vote);
}
if(all participants send VOTE_COMMIT and coordinatorvotes COMMIT)
{
  write("GLOBAL_COMMIT to local log");
  multicast("GLOBAL_COMMIT to all participants");
}
else
{
  write("GLOBAL_ABORT to local log");
  multicast("GLOBAL_ABORT to all participants");
}

**Actions of Participants**

write("INIT to locallog");
waitfor("VOTE_REQUESTfrom coordinator");
if(timeout)
{
  write("VOTE_ABORT to local log");
  exit();
}
if("participantvotes COMMIT")
{
  write("VOTE_COMMIT to local log");
  send("VOTE_COMMIT to coordinator");
  waitfor("DESCISION from coordinator");
  if(timeout)
  {
    multicast("DECISION_REQUEST to other participants");
    waituntil("DECISION is received"); /// remain blocked
    write("DECISION to local log");
  }
  if(DECISION == "GLOBAL_COMMIT")
  {
    write("GLOBAL_COMMIT to local log");
  }
  else if(DECISION== "GLOBAL_ABORT")
  {
    write("GLOBAL_ABORT to local log");
  }
}
else
{
    write("GLOBAL_ABORT to local log");
    send("GLOBAL_ABORT to coordinator");
}
</code></pre>

<h3>参考文献:</h3>

<p>  [1] 两阶段提交(2PC)协议, <a href="http://blog.chinaunix.net/uid-20761674-id-75164.html">http://blog.chinaunix.net/uid-20761674-id-75164.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[undo 日志和redo 日志]]></title>
    <link href="http://cxh.me/2014/07/05/redo-undo-log/"/>
    <updated>2014-07-05T21:20:00+08:00</updated>
    <id>http://cxh.me/2014/07/05/redo-undo-log</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="/images/2014/interesting.gif" title="&ldquo;贴张图&rdquo; &ldquo;贴张图&rdquo;" ></p>

<p>  具体的可以看<a href="http://blog.csdn.net/ggxxkkll/article/details/7616739" title="数据库日志文件-- undo log 、redo log、 undo/redo log">这里</a>，解释几个作者没解释清楚的问题：</p>

<ol>
<li><p>只用REDO日志为什么数据修改要每次修改刷盘</p>

<p> 如果不刷盘，不会导致数据不一致，但是数据修改过程相当于写redo日志-修改内存-写commit日志（修改内存的顺序也无所谓了），这个过程结束已经应答用户了，但是修改没有刷下去断电恢复的话也无法通过redolog恢复到当前状态，所以会丢失修改。</p></li>
<li><p>修改数据和写redo/undo log/commit log之间的关系是什么</p>

<p> 任何对磁盘的数据修改落实之前都需要先写log，无论是redo还是undo。undo保证了一旦数据写了一半（脏数据）能够回滚，redo保证了写了日志的事务能够回放出来。</p>

<p> 只使用undo的时候commit日志要等待刷盘成功，写了commit的事务不会再回滚。</p>

<p> 只使用redo的时候需要先写commit日志再修改缓冲区，因为数据有刷盘和不刷盘的可能，写完commit日志意味着修改已经完整记录下来了不会丢失。否则，没有commit的日志不会回放，如果之前修改数据并刷盘了，系统不知道处于哪个阶段：写了一半的log？写成功log?修改了一半数据？成功修改全部数据？。<del>如果修改不刷盘，那么如果在修改数据阶段宕机，就丢失了此条本来可以写成功的数据，好在这时候也没有回复用户。</del>确保数据不刷盘的情况下，是可以先修改缓冲区再写commit日志的。</p>

<p> <del>其实redo log + commit log写成功就可以回复用户了啊，异步修改数据好了。至少能保证不丢失。不过万一修改失败了或者这时候有读取怎么办&hellip;</del></p></li>
<li><p>只使用redo日志的时候checkpoint为什么不能直接刷盘</p>

<p> 如果只使用redo日志，而且修改顺序是写redo日志-写commit日志-修改缓冲区，那么缓冲区是可以在checkpoint的时候刷下去的，因为下次回放的时候已经有了redo日志和commit标记，可以回放覆盖之前的脏数据，问题在于如果这个事务被回滚了，只有redo日志是不能做回滚操作的。如果使用redo-undo log那么可以直接把脏数据刷盘。</p></li>
</ol>


<h3>参考文献:</h3>

<p>  [1] 数据库日志文件&mdash; undo log 、redo log、 undo/redo log, <a href="http://blog.csdn.net/ggxxkkll/article/details/7616739">http://blog.csdn.net/ggxxkkll/article/details/7616739</a></p>
]]></content>
  </entry>
  
</feed>
