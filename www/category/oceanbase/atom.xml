<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Oceanbase | CXH.ME]]></title>
  <link href="http://cxh.me/category/oceanbase/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-07-29T17:43:05+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分布式系统/NOSQL入门书单]]></title>
    <link href="http://cxh.me/2014/10/20/distribute-system-guide/"/>
    <updated>2014-10-20T11:26:00+08:00</updated>
    <id>http://cxh.me/2014/10/20/distribute-system-guide</id>
    <content type="html"><![CDATA[<p>  简单记一下我看过的和觉得值得看的。主要是给@赵龙作为参考。</p>

<ul>
<li>分布式相关</li>
</ul>


<blockquote><p>[1] 大规模分布式存储系统, <a href="http://book.douban.com/subject/25723658/">http://book.douban.com/subject/25723658/</a>
  阿里日照的书，全面介绍了分布式系统的原理和实践，入门不可多得的书</p>

<p>[2] 分布式系统原理介绍, <a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=31413">http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=31413</a>
  百度刘杰的，讲基本的分布式原理，有些笔误什么的。</p>

<p>[3] paxos算法相关, <a href="http://cxh.me/2014/08/26/paxos-study/">http://cxh.me/2014/08/26/paxos-study/</a>
  总结了paxos算法一些资料。</p>

<p>[5] 分布式数据库系统原理, <a href="http://product.dangdang.com/23466507.html">http://product.dangdang.com/23466507.html</a>
  分布式数据库的一本教材。</p>

<p>[6] The Raft Consensus Algorithm, <a href="http://raftconsensus.github.io/">http://raftconsensus.github.io/</a>
  raft相关的资料，论文和一些实现都能在里面找到，另外有一个图形化的展示很方便。</p>

<p>[7] Raft介绍, <a href="http://www.slideboom.com/presentations/956855/Raft%E4%BB%8B%E7%BB%8D">http://www.slideboom.com/presentations/956855/Raft%E4%BB%8B%E7%BB%8D</a>
  raft的一个ppt。</p></blockquote>

<ul>
<li>数据库相关</li>
</ul>


<blockquote><p>[1] 数据库系统实现, <a href="http://item.jd.com/10060181.html">http://item.jd.com/10060181.html</a>
  数据库的一本教材，偏重于实现。</p>

<p>[2] 数据挖掘概念与技术, <a href="http://book.douban.com/subject/2038599/">http://book.douban.com/subject/2038599/</a>>[3] 事务相关, <a href="http://cxh.me/2014/07/02/article-on-transaction/">http://cxh.me/2014/07/02/article-on-transaction/</a></p>

<p>[3] 事务相关, <a href="http://cxh.me/2014/07/02/article-on-transaction/">http://cxh.me/2014/07/02/article-on-transaction/</a>
  总结了事务相关的一些资料。</p></blockquote>

<ul>
<li>NOSQL相关</li>
</ul>


<blockquote><p>[1] Dynamo论文, <a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a></p>

<p>[2] bigtable论文, <a href="http://research.google.com/archive/bigtable-osdi06.pdf">http://research.google.com/archive/bigtable-osdi06.pdf</a></p>

<p>[3] gfs论文, <a href="http://research.google.com/archive/gfs-sosp2003.pdf">http://research.google.com/archive/gfs-sosp2003.pdf</a></p>

<p>[4] map reduce论文, <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf">http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf</a></p>

<p>[5] Redis 设计与实现, <a href="http://redisbook.com/en/latest/">http://redisbook.com/en/latest/</a>
  一本不错的讲redis的书。</p>

<p>[6] 数据分析与处理之二（Leveldb 实现原理）, <a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html</a>
  leveldb的实现。</p>

<p>[7] Memcached 源码剖析笔记, <a href="http://files.cppblog.com/xguru/Memcached.pdf">http://files.cppblog.com/xguru/Memcached.pdf</a>
  memcache的源码。</p></blockquote>

<ul>
<li>基础</li>
</ul>


<blockquote><p>[1] UNIX环境高级编程, <a href="http://book.douban.com/subject/1788421/">http://book.douban.com/subject/1788421/</a></p>

<p>[2] UNIX网络编程, <a href="http://book.douban.com/subject/1500149/">http://book.douban.com/subject/1500149/</a></p></blockquote>

<ul>
<li>一些博客</li>
</ul>


<blockquote><p>[1] 银河里的星星的博客, <a href="http://duanple.blog.163.com/">http://duanple.blog.163.com/</a>
  主要是分布式领域的论文和翻译。</p>

<p>[2] 章炎的技术博客, <a href="http://dirlt.com/">http://dirlt.com/</a></p>

<p>[3] 何登成的技术博客, <a href="http://hedengcheng.com/">http://hedengcheng.com/</a> 大牛不解释</p>

<p>[4] 淘宝核心系统团队博客, <a href="http://csrd.aliapp.com/">http://csrd.aliapp.com/</a></p>

<p>[5] 吴镝 <a href="http://www.cnblogs.com/foxmailed/">http://www.cnblogs.com/foxmailed/</a> 专注系统，基础架构，分布式系统</p></blockquote>

<p>  都看还是需要时间的，我只是读完了一部分翻完了一部分，很多还需要再看一遍。分布式系统最好的学习方法当时是实现一个分布式系统，像晓楚<a href="https://github.com/raywill/macraykv" title="Macrakv">macrakv</a>这样，但是工程量和难度比较大，退而求其次的办法是看源码，redis/hbase/leveldb/memcached都是不错的例子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paxos算法学习]]></title>
    <link href="http://cxh.me/2014/08/26/paxos-study/"/>
    <updated>2014-08-26T20:53:00+08:00</updated>
    <id>http://cxh.me/2014/08/26/paxos-study</id>
    <content type="html"><![CDATA[<p>  本来想写点东西，后来觉得都是一知半解。这里转载一点学习资料吧。</p>

<p>  一个是知行学社的分布式系统与Paxos算法视频课程，循序渐进，讲解地比较浅显易懂。</p>

<p>  <embed src="http://www.tudou.com/v/e8zM8dAL6hM/&bid=05&rpid=51943457&resourceId=51943457_05_05_99/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"></embed></p>

<p>  另一个是百度刘杰<a href="http://www.valleytalk.org/2012/07/12/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%8B-%E3%80%82%E7%99%BE%E5%BA%A6-%E3%80%82%E5%88%98%E6%9D%B0/" title="《分布式系统原理介绍》">《分布式系统原理介绍》</a>。当然Lamport的几篇论文是不能不看的，虽然都不太好懂。</p>

<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" title="The Part-Time Parliament">The Part-Time Parliament</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" title="paxos made simple">Paxos Made Simple</a></li>
<li><a href="https://www.andrew.cmu.edu/course/15-749/READINGS/required/resilience/lamport82.pdf" title="The Byzantine Generals Problem">The Byzantine Generals Problem</a></li>
</ul>


<p>  相比较而言，<a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)" title="Paxos (computer science)">paxos的wiki</a>可能更好懂一些。有余力的同学可以做一下<a href="http://css.csail.mit.edu/6.824/2014/" title="MIT Distributed Systems Labs">MIT Distributed Systems Labs</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两阶段提交协议的异常处理]]></title>
    <link href="http://cxh.me/2014/07/07/two-process-commit-exceptions/"/>
    <updated>2014-07-07T11:57:00+08:00</updated>
    <id>http://cxh.me/2014/07/07/two-process-commit-exceptions</id>
    <content type="html"><![CDATA[<p>  两阶段提交的协议大家都比较熟悉了，解释一下每个阶段的异常处理。首先，我们需要持久化协议过程中的状态，这样如果server宕机，那么恢复的时候还能通过日志知道宕机前处于那个阶段。同时，所有对数据的修改都会先写write ahead log，保证宕机重启的之后数据也不会丢失。写日志的顺序假定为:写write ahead log-修改缓冲区-写commit/abort log。</p>

<p>  在这个前提下，我们根据如下的时序图来讨论异常情况和处理方法。</p>

<p><img class="img-polaroid center" src="/images/2014/2pc.png" title="&ldquo;两阶段提交协议时序&rdquo; &ldquo;两阶段提交协议时序&rdquo;" ></p>

<ol>
<li><p> 过程a没有成功，即协调者没有收到部分参与者的回应。超时后，协调者发送abort消息给参与者取消事务。参与者存在两种情况：</p>

<ul>
<li>过程1失败，网络问题导致参与者没有收到vote request消息或者此时参与者宕机。参与者重启恢复后无需做任何事。</li>
<li>过程2失败，参与者收到了vote request，网络问题协调者没有收到回复或此时参与者宕机。参与者宕机恢复或等待超时后广播DECISION_REQUEST消息向其他参与者询问是否收到commit/abort消息。</li>
</ul>
</li>
<li><p> 过程b没有成功，即协调者发送commit消息之后没有收到部分参与者的回应。协调者需要重试，确认参与者的提交完毕消息，如果多次尝试不能联系上，则等待参与者上线之后解决。参与者存在两种情况：</p>

<ul>
<li>过程3失败，网络问题导致参与者没有收到commit消息或此时参与者宕机。参与者上线发现在本地日志中发现尚未提交成功，因为到达这里，可以肯定本地已做好提交准备，但是不知道协调者是决定提交，所以向协调者询问，按协调者的回复来进行提交或回滚。如果无法联系上协调者，则向其他参与者询问事务状态，如果有某一个节点已经做了提交或异常终止(说明协调者已发送了相关消息)，则做同样的操作。</li>
<li>过程4失败，参与者完成了commit/rollback，但是网络问题协调者没有收到回应或者此时参与者宕机。参与者在本地日志中发现已完成本地提交，所以可能由于网络故障导致提交完成消息没有到达协调者。所以直接忽略。这时可能协调者在等待该参与者的提交完成回应消息，所以参与者主动联系协调者告知事务状态。</li>
</ul>
</li>
<li><p> 过程c没有成功，即参与者发送vote回应消息之后没有等到协调者的commit/rollback消息。这个过程参与者的异常处理已经讨论过了，这里讨论协调者的异常处理。存在两种情况：</p>

<ul>
<li>过程2失败，网络问题导致协调者没有收到回复或此时协调者宕机。协调者恢复重启后，发现并未做提交操作，保险操作(因为不知道它是否发送过准备消息，或其他参与者是否做好提交准备)，直接发送abort消息给所有参与者，终止事务</li>
<li>过程3失败，网络问题导致参与者没有收到commit/rollback消息或者此时协调者宕机。协调者恢复重启后，不能保证所有参与者都已收到了提交消息，所以给所有的参与者发送commit消息，保证事务的正常提交。</li>
</ul>
</li>
</ol>


<!--more-->


<p>  算法的伪代码可以参考如下代码，摘自《Distributed Systems: Principles and Paradigms》。</p>

<p>  <strong>Actions of Coordinator</strong></p>

<pre><code>write("START_2PC tolocal log");
multicast("VOTE_REQUESTto all participants");
while(not all votes have been collected)
{
  waitfor("any incoming vote");
  if(timeout)
  {
    write("GLOBAL_ABORT to local host");
    multicast("GLOBAL_ABORT to all participants");
    exit();
  }
  record(vote);
}
if(all participants send VOTE_COMMIT and coordinatorvotes COMMIT)
{
  write("GLOBAL_COMMIT to local log");
  multicast("GLOBAL_COMMIT to all participants");
}
else
{
  write("GLOBAL_ABORT to local log");
  multicast("GLOBAL_ABORT to all participants");
}

**Actions of Participants**

write("INIT to locallog");
waitfor("VOTE_REQUESTfrom coordinator");
if(timeout)
{
  write("VOTE_ABORT to local log");
  exit();
}
if("participantvotes COMMIT")
{
  write("VOTE_COMMIT to local log");
  send("VOTE_COMMIT to coordinator");
  waitfor("DESCISION from coordinator");
  if(timeout)
  {
    multicast("DECISION_REQUEST to other participants");
    waituntil("DECISION is received"); /// remain blocked
    write("DECISION to local log");
  }
  if(DECISION == "GLOBAL_COMMIT")
  {
    write("GLOBAL_COMMIT to local log");
  }
  else if(DECISION== "GLOBAL_ABORT")
  {
    write("GLOBAL_ABORT to local log");
  }
}
else
{
    write("GLOBAL_ABORT to local log");
    send("GLOBAL_ABORT to coordinator");
}
</code></pre>

<h3>参考文献:</h3>

<p>  [1] 两阶段提交(2PC)协议, <a href="http://blog.chinaunix.net/uid-20761674-id-75164.html">http://blog.chinaunix.net/uid-20761674-id-75164.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[undo 日志和redo 日志]]></title>
    <link href="http://cxh.me/2014/07/05/redo-undo-log/"/>
    <updated>2014-07-05T21:20:00+08:00</updated>
    <id>http://cxh.me/2014/07/05/redo-undo-log</id>
    <content type="html"><![CDATA[<p><img class="img-polaroid center" src="/images/2014/interesting.gif" title="&ldquo;贴张图&rdquo; &ldquo;贴张图&rdquo;" ></p>

<p>  具体的可以看<a href="http://blog.csdn.net/ggxxkkll/article/details/7616739" title="数据库日志文件-- undo log 、redo log、 undo/redo log">这里</a>，解释几个作者没解释清楚的问题：</p>

<ol>
<li><p>只用REDO日志为什么数据修改要每次修改刷盘</p>

<p> 如果不刷盘，不会导致数据不一致，但是数据修改过程相当于写redo日志-修改内存-写commit日志（修改内存的顺序也无所谓了），这个过程结束已经应答用户了，但是修改没有刷下去断电恢复的话也无法通过redolog恢复到当前状态，所以会丢失修改。</p></li>
<li><p>修改数据和写redo/undo log/commit log之间的关系是什么</p>

<p> 任何对磁盘的数据修改落实之前都需要先写log，无论是redo还是undo。undo保证了一旦数据写了一半（脏数据）能够回滚，redo保证了写了日志的事务能够回放出来。</p>

<p> 只使用undo的时候commit日志要等待刷盘成功，写了commit的事务不会再回滚。</p>

<p> 只使用redo的时候需要先写commit日志再修改缓冲区，因为数据有刷盘和不刷盘的可能，写完commit日志意味着修改已经完整记录下来了不会丢失。否则，没有commit的日志不会回放，如果之前修改数据并刷盘了，系统不知道处于哪个阶段：写了一半的log？写成功log?修改了一半数据？成功修改全部数据？。<del>如果修改不刷盘，那么如果在修改数据阶段宕机，就丢失了此条本来可以写成功的数据，好在这时候也没有回复用户。</del>确保数据不刷盘的情况下，是可以先修改缓冲区再写commit日志的。</p>

<p> <del>其实redo log + commit log写成功就可以回复用户了啊，异步修改数据好了。至少能保证不丢失。不过万一修改失败了或者这时候有读取怎么办&hellip;</del></p></li>
<li><p>只使用redo日志的时候checkpoint为什么不能直接刷盘</p>

<p> 如果只使用redo日志，而且修改顺序是写redo日志-写commit日志-修改缓冲区，那么缓冲区是可以在checkpoint的时候刷下去的，因为下次回放的时候已经有了redo日志和commit标记，可以回放覆盖之前的脏数据，问题在于如果这个事务被回滚了，只有redo日志是不能做回滚操作的。如果使用redo-undo log那么可以直接把脏数据刷盘。</p></li>
</ol>


<h3>参考文献:</h3>

<p>  [1] 数据库日志文件&mdash; undo log 、redo log、 undo/redo log, <a href="http://blog.csdn.net/ggxxkkll/article/details/7616739">http://blog.csdn.net/ggxxkkll/article/details/7616739</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跟事务相关的一些文章]]></title>
    <link href="http://cxh.me/2014/07/02/article-on-transaction/"/>
    <updated>2014-07-02T16:45:00+08:00</updated>
    <id>http://cxh.me/2014/07/02/article-on-transaction</id>
    <content type="html"><![CDATA[<p>  主要纪录一下跟事务相关的一些文章。主要是博客，有论文加论文。顺便纪念下女神订婚。图是转载。</p>

<p>  <img class="img-polaroid center" src="/images/2014/tangwei.jpg"></p>

<h3>参考文献:</h3>

<p>  [1] 数据库事务隔离级别和锁实现机制, <a href="http://comedsh.iteye.com/blog/698733">http://comedsh.iteye.com/blog/698733</a></p>

<p>  [2] 数据库事务的实现（一） 故障恢复 （undo日志）, <a href="http://www.cnblogs.com/clam/archive/2012/08/27/2657943.html">http://www.cnblogs.com/clam/archive/2012/08/27/2657943.html</a></p>

<p>  [3] 数据库事务的实现-故障恢复（二）（undo日志检查点）, <a href="http://www.cnblogs.com/clam/archive/2012/08/27/2657944.html">http://www.cnblogs.com/clam/archive/2012/08/27/2657944.html</a></p>

<p>  [4] 为 Key-Value 数据库实现MVCC 事务, <a href="http://juliashine.com/implementation-of-mvcc-transactions-for-key-value-stores/">http://juliashine.com/implementation-of-mvcc-transactions-for-key-value-stores/</a></p>

<p>  [5] 数据库日志文件&mdash; undo log 、redo log、 undo/redo log, <a href="http://blog.csdn.net/ggxxkkll/article/details/7616739">http://blog.csdn.net/ggxxkkll/article/details/7616739</a></p>

<p>  [6] 两阶段提交-2PC, <a href="http://blog.csdn.net/ggxxkkll/article/details/7631545">http://blog.csdn.net/ggxxkkll/article/details/7631545</a></p>

<p>  [7] 分布式系统的事务处理, <a href="http://coolshell.cn/articles/10910.html">http://coolshell.cn/articles/10910.html</a></p>

<p>  [8] 两阶段提交(2PC)协议" , <a href="http://blog.chinaunix.net/uid-20761674-id-75164.html">http://blog.chinaunix.net/uid-20761674-id-75164.html</a></p>
]]></content>
  </entry>
  
</feed>
