<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Oceanbase | CXH.ME]]></title>
  <link href="http://cxh.me/category/oceanbase/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-11-01T18:47:13+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何构建按高可用系统（分享的笔记）]]></title>
    <link href="http://cxh.me/2013/11/01/how-to-build-high-available-system/"/>
    <updated>2013-11-01T18:42:00+08:00</updated>
    <id>http://cxh.me/2013/11/01/how-to-build-high-available-system</id>
    <content type="html"><![CDATA[<p>版权所有：<a href="">解伦师兄</a></p>

<h3>介绍篇</h3>

<p><strong>可用性vs可靠性</strong></p>

<p>  可用性主要是从时间的角度看，可靠的时间。可靠性主要是看不可用的频率。如果一个系统1小时宕机1ms，可用性非常高，可靠性非常低。</p>

<p>  可用性可靠性是系统的工程，设计开发，管理，运维等等。</p>

<p>  宕机几大因素：软件-硬件-网络-人为</p>

<p>  data loss的最大因素：drop table, 所以要做好充分的容错。</p>

<!-- more -->


<h3>设计篇</h3>

<p><strong>减少故障发生的可能</strong></p>

<p>  避免单点故障，防止扩散，有效的监控运维配合</p>

<p>  常见的<strong>冗余</strong>设计。</p>

<ul>
<li>RAID,Replica,Erasure Code</li>
<li>BackUp, Reassign,Retry</li>
<li>Master-Slave,Mirror,RAC..</li>
</ul>


<p>  减少对外部系统强依赖</p>

<ul>
<li>缓存</li>
<li>异步替代同步</li>
</ul>


<p>  对外部依赖不信任</p>

<ul>
<li>结果进行</li>
<li>失败情况下failover（重试时间次数需要控制）</li>
</ul>


<p>  有效的内部监控</p>

<p><strong>减少故障恢复时间</strong></p>

<p>  无状态最好</p>

<ul>
<li>有状态定期做持久化（checkpoint/commitlog)</li>
</ul>


<p>  有效的故障隔离</p>

<ul>
<li>故障检测，黑白名单，流量分配</li>
<li>黑名单要有恢复机制</li>
</ul>


<p><strong>减少损失</strong></p>

<p>  过载保护</p>

<ul>
<li>发现故障，并限制资源</li>
</ul>


<p>  应用降级</p>

<ul>
<li>关闭部分不重要的功能(某些情况下用户也感觉不出来)</li>
</ul>


<p>  有个故事：二战的时候（好背景），坦克设计的时候每次发射炮弹，都会有电磁波导致所有软件挂掉，所以故障恢复就很重要。</p>

<h3>案例篇</h3>

<p><strong>Twitter</strong></p>

<p>  世界杯额时候twitter经常会时常挂掉</p>

<ul>
<li>memcache规划的问题</li>
<li>cache也要注意设计</li>
</ul>


<p><strong>Foursquare</strong></p>

<p>  数据不均，mongodb数据量超过内存之后性能非常差(mmap的问题)</p>

<ul>
<li>数据迁走之后有空洞，页不释放</li>
<li>还好毕设的时候数据量不大</li>
</ul>


<p><strong>Amazon</strong></p>

<p>  EBS主网络走数据，备网络走控制，操作失误，主网络切到备网络</p>

<ul>
<li>相应超时，认为丢失副本</li>
<li>副本复制，继续加剧网络问题</li>
</ul>


<p><strong>Weibo</strong></p>

<p>  热点存在，cache失效，一瞬间所有访问db</p>

<ul>
<li>加锁，一个人获取内容回填cache之后就不会有人去访问db了</li>
</ul>


<p><strong>Facebook</strong></p>

<p>  cache没取到就删除了原cache</p>

<p><strong>OB</strong></p>

<p>  客户端要做分流，业务高峰，超时严重，把cluster都加入黑名单，重试风暴</p>

<h3>总结篇</h3>

<p><strong>可用性</strong></p>

<ul>
<li>BASE:基本可用</li>
<li>CAP:No CAP, No CP, A是很重要的</li>
<li><a href="">20 Key High Availability Design Principles</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用gdb调试分布式系统（OB中的应用）]]></title>
    <link href="http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob/"/>
    <updated>2013-10-29T13:40:00+08:00</updated>
    <id>http://cxh.me/2013/10/29/use-gdb-to-test-multi-servers-in-ob</id>
    <content type="html"><![CDATA[<p>  分布式系统开发的时候我们最经常遇到的问题就是，从一个server发送了一条报文之后怎么在另一个server查看这条报文的处理逻辑是否正确，单机的debug都不是问题，但是多机debug怎么做呢？</p>

<p>  在ob团队里面，正常情况下我们有如下三种方式处理这些问题：</p>

<ol>
<li> 做mock，写单测，隔离开集群环境</li>
<li> 加调试日志，部署集群环境，看日志。</li>
<li> 非daemon模式下通过gdb调试。</li>
</ol>


<p>  这里我们详细说一下第三种。这也是最有效果的一种。</p>

<!-- more -->


<p>  需要强调的是，正常情况下ob启动之后各个server会以守护进程方式运行，这时候如果用gdb启动server的话，gdb不知道在fork之后跟哪个进程，而在我测试下，<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/" title="使用 GDB 调试多进程程序">set follow-fork-mode</a>貌似也没成功过。</p>

<p>  所以最好的方法是直接不要通过守护进程启动，我们在部署ob到home目录下，集群名用ob1，.gdbinit里面写入：</p>

<pre><code>cd ~/ob1
file bin/rootserver
set args -r 10.235.162.8:3500 -R 10.235.162.8:3500 -i eth0 -C 1 -N
break "/home/xiaohui.cpc/roottable_dev/src/rootserver/ob_root_worker.cpp:2053"
break "/home/xiaohui.cpc/roottable_dev/src/rootserver/ob_root_worker.cpp:941"
</code></pre>

<p>  参数里面加-N表示不以daemon方式启动。</p>

<p>  这样通过gdb可以启动rootserver，然后同样启动其他需要的server，就可以调试在gdb里面看到程序执行后停在断点的位置。启动脚本如下，这里我们只启动了chunkserver。</p>

<pre><code>#!/bin/bash
rs_ip=10.235.162.8
rs_port=3500
cs_port=3501
ups_port=3502
ms_port=3503
freeze_port=3504
mysql_port=3505
net=bond0
appname=ob1.xiaohui.cpc
no_daemon=-N

#bin/rootserver -r $rs_ip:$rs_port -R $rs_ip:$rs_port -i $net -C 1 $no_daemon
bin/chunkserver -r $rs_ip:$rs_port -p $cs_port -n $appname -i $net $no_daemon

#bin/updateserver -r $rs_ip:$rs_port -p $ups_port -m $freeze_port -i $net $no_daemon
#bin/mergeserver -r $rs_ip:$rs_port -p $ms_port -z $mysql_port -i $net $no_daemon

#bin/rs_admin -r $rs_ip -p $rs_port set_obi_role -o OBI_MASTER
#bin/rs_admin -r $rs_ip -p $rs_port -t 60000000 boot_strap $no
</code></pre>

<p>  断点命中的情况如图1所示：</p>

<p>  <img class="img-polaroid center" src="/images/2013-10/gdb_multi_server.png" title="&ldquo;图1：断点命中的情况&rdquo; &ldquo;图1：断点命中的情况&rdquo;" ></p>

<p>  唯一的问题是gdb有时候会退出，如图2。感觉上是rpc超时了？</p>

<p>  <img class="img-polaroid center" src="/images/2013-10/gdb_quit.png" title="&ldquo;图2：gdb退出&rdquo; &ldquo;图2：gdb退出&rdquo;" ></p>

<p>  感谢玩大数据的<a href="http://weibo.com/hanfooo" title="韩富晟 支付宝颜然，玩大数据的，OceanBase工程师">颜然师兄</a>提供非daemon方式启动的方法。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 使用 GDB 调试多进程程序, <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/">http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/</a></p>

<p>[2] 韩富晟 支付宝颜然，玩大数据的，OceanBase工程师, <a href="http://weibo.com/hanfooo">http://weibo.com/hanfooo</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
