<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | CXH.ME]]></title>
  <link href="http://cxh.me/category/linux/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-01-12T00:26:10+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过搭建代理来共享网络]]></title>
    <link href="http://cxh.me/2015/01/11/linux-proxy-setup/"/>
    <updated>2015-01-11T17:16:00+08:00</updated>
    <id>http://cxh.me/2015/01/11/linux-proxy-setup</id>
    <content type="html"><![CDATA[<p>   遇到这样一个问题，开发机只有一台能上外网，其他的机器上手动更新依赖包简直是要死的感觉。尝试了如下几种方式：</p>

<ol>
<li>. vpn

<ol>
<li><a href="http://5323197.blog.51cto.com/5313197/1285738" title=" centos6.4 安装配置 pptp vpn">pptp</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-setup-and-configure-an-openvpn-server-on-centos-6" title="How to Setup and Configure an OpenVPN Server on CentOS 6 | DigitalOcean">openvpn</a></li>
</ol>
</li>
<li>. ssh反向代理（其实不是干这个事情的貌似）</li>
<li>. proxy</li>
</ol>


<p>   开始一直不想用proxy，毕竟需要为yum什么的单独配置，不是所有的程序都会去读shell的http_proxy配置。但是vpn配置搞了一天都不成功。openvpn能连接，但是不能共享网络，大概是路由配错了，pptp linux下直接链接不上，可能是只用了chap的握手？反正没成功。最后还是配了proxy，配完才觉得proxy简单易行啊，大部分问题能解决，出现了特别的需求就单独为其设置代理好了。问题不大。</p>

<p>   tinyproxy的配置如下：</p>

<pre><code>yum install tinyproxy

# vi /etc/tinyproxy/tinyproxy.conf
Allow 192.168.1.0/24 # 限制可以使用Proxy的来源网段

service tinyproxy start

shell配置：
export http_proxy='xxx:8888'
export https_proxy='xxx:8888'

yum配置：
vi /etc/yum.conf
  proxy=http://xxxx:8888
ConnectPort 443     
</code></pre>

<p>  配置难度真不是一个数量级的，可见有时候能满足大部分情况，就是最好的解决方案了。</p>

<p>  <strong>补充：easy_install和pip是默认读取http_proxy的，但是一直不能连接。尝试了很久之后发现是sudo的问题，sudo环境没有执行.bashrc，所以root的http_proxy和当前用户的http_proxy都没有生效。su到root下就可以了。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux上的远程log监控]]></title>
    <link href="http://cxh.me/2015/01/04/linux-remote-log-watch/"/>
    <updated>2015-01-04T17:34:00+08:00</updated>
    <id>http://cxh.me/2015/01/04/linux-remote-log-watch</id>
    <content type="html"><![CDATA[<p>  名字太大，其实只是遇到了一个问题，想远程实时看一个log文件的变化。开始是这么做的。</p>

<pre><code>vim 里面 :e scp://xxx@xxx//filePath
:e! 来刷新
</code></pre>

<p>   太low了。直接用ssh：</p>

<pre><code>ssh xx@xxx "less filePath"
</code></pre>

<p>   发现less直接就退出了。 换成:</p>

<pre><code>ssh -t xx@xxx "less filePath"
</code></pre>

<p>   也不能实时刷新。测试less 本地一个文件同时写入，发现less没有实时刷新的功能。看来是在ob的时候deploy给我的错觉啊。</p>

<p>   换tail:</p>

<pre><code>ssh -t xx@xxx "tail filePath"
</code></pre>

<p>   还是直接执行完毕退出。查tail有没有自动刷新的模式，有一个follow：</p>

<pre><code>ssh xx@xx "tail -f filePath"
</code></pre>

<p>   搞定。<em>配合[TMux]绝对好用</em>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[du显示只显示一层子目录/文件的大小]]></title>
    <link href="http://cxh.me/2014/11/13/du-to-display-one-level/"/>
    <updated>2014-11-13T17:55:00+08:00</updated>
    <id>http://cxh.me/2014/11/13/du-to-display-one-level</id>
    <content type="html"><![CDATA[<p>  经常需要看当前目录下的子目录大小，比如开发机被人占满的情况，<code>du -lh</code>显示的是递归的所有文件大小，<code>du -s</code>又只统计了所有文件/文件夹合起来的大小。正常情况下需要执行：</p>

<pre><code>du -lh --max-depth=1
</code></pre>

<p>  未免太过麻烦。后来肖总提示发现这样就行了：</p>

<pre><code>du -sh *
</code></pre>

<p>  果然是学无止境啊</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于得到当前执行文件所在的目录]]></title>
    <link href="http://cxh.me/2013/11/19/method-to-get-absolute-path-of-current-program/"/>
    <updated>2013-11-19T21:47:00+08:00</updated>
    <id>http://cxh.me/2013/11/19/method-to-get-absolute-path-of-current-program</id>
    <content type="html"><![CDATA[<p>  今天遇到一个问题，程序里面用相对路径引用了同一级目录下的一个文件，shell在上一级目录调用程序的时候，发现当前目录变成了上一级目录，于是程序在上一级目录找那个文件。最简单的办法当然是shell脚本里面加cd操作，但是暂时不方便修改脚本。所以直接通过程序获取绝对路径好了。</p>

<p>  首先，直接 realpath(&ldquo;./&rdquo;) 和 getcwd 获取的都是当前路径，也就是当前shell所在的路径。<strong>FILE</strong>获取的是文件名，不包含路径，而且是编译过程确定的，最简单的办法当然是argv[0]，但是在test_case(gtest)里面不方便传来传去，后来发现最好的办法是这样的：</p>

<pre><code>#include "libgen.h"
#define MAX_PATH_SIZE 100
char current_absolute_path[MAX_PATH_SIZE] = {'\0'};
if (readlink("/proc/self/exe", current_absolute_path, MAX_PATH_SIZE - 1) &lt; 0)
{
  //error
}
else
{
  sprintf(current_absolute_path, "%s/%s", dirname(current_absolute_path), schema_file_name);
}
</code></pre>

<p>  这样就可以拼合当前程序所在目录和schema_file_name得到这个文件的绝对路径了。这里/proc/self/exe是运行时的当前执行程序软链接。看来proc目录下要好好研究一下啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级到ubuntu13.10]]></title>
    <link href="http://cxh.me/2013/10/18/update-to-ubuntu-13-10/"/>
    <updated>2013-10-18T10:49:00+08:00</updated>
    <id>http://cxh.me/2013/10/18/update-to-ubuntu-13-10</id>
    <content type="html"><![CDATA[<p>  Ubuntu13.10可以升级了，版本名称是：“俏丽的蝾螈”。</p>

<p><img class="img-polaroid center" src="/images/2013/ubuntu13_10.jpg" title="&ldquo;俏丽的蝾螈&rdquo; &ldquo;俏丽的蝾螈&rdquo;" ></p>
]]></content>
  </entry>
  
</feed>
