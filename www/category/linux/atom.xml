<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | CXH.ME]]></title>
  <link href="http://cxh.me/category/linux/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-03-07T19:36:38+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux ssh免密登陆和调试]]></title>
    <link href="http://cxh.me/2015/03/07/ssh-debug-and-passless-login/"/>
    <updated>2015-03-07T17:56:00+08:00</updated>
    <id>http://cxh.me/2015/03/07/ssh-debug-and-passless-login</id>
    <content type="html"><![CDATA[<p>   把一个公钥上传到服务器配置了免密登陆，ok之后再配置几台服务器之间的免密，发现不成功。尝试了如下几种定位方法：</p>

<ol>
<li>ssh目录权限。修改成.ssh 700，下面文件600。解决了一个的问题。其他几台还是不行。</li>
<li>查看sshd_config是否允许公钥登陆。看来不是这个问题。</li>
<li>ssh -v 看调试信息，发现尝试过publickey但是验证未通过。手动比对ssh 公钥发现无误。</li>
<li><p>搜索错误信息：Offering public key: /root/.ssh/id_rsa，有人说<a href="http://segmentfault.com/q/1010000000445726" title="CentOS SSH公钥登录问题">是因为.ssh目录没有ssh_home_t标签</a>， 通过这个命令查看文件夹或文件的标签</p>

<pre><code>[root@localhost ~]# ls -laZ
</code></pre>

<p>通过</p>

<pre><code>restorecon -r -vv /root/.ssh
</code></pre>

<p>来重置标签，但是没起作用。</p></li>
<li><p>设想可能是手动建立.ssh目录的问题，删除.ssh，通过ssh-keygen本地生成密钥并建立目录。问题解决。</p></li>
</ol>


<p>   补充一点细节。bash下似乎单行的function必须以分号结尾，我说怎么server登陆总报error end line xxx..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sudo的环境变量]]></title>
    <link href="http://cxh.me/2015/03/03/sudo-env/"/>
    <updated>2015-03-03T18:34:00+08:00</updated>
    <id>http://cxh.me/2015/03/03/sudo-env</id>
    <content type="html"><![CDATA[<p>  sudo的时候不会加载.bashrc什么的，今天就遇到了一个比较扯的问题。在home下安装了高版本的vim，bashrc里面PATH是home高于/bin的，但sudo vi的时候会调用系统的。尝试如下方式：</p>

<ol>
<li> 修改其他配置如.profile什么的。比较麻烦。</li>
<li> 修改sudoers里面env_keep，发现还是不起作用。</li>
<li><p> 修改sudoers里面secure_path，如下：</p>

<pre><code>Defaults    secure_path = /root/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
</code></pre></li>
</ol>


<p>  OK。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[区分下shell和makefile中的特殊字符]]></title>
    <link href="http://cxh.me/2015/02/04/distinguish-special-symbol-in-shell-and-makefile/"/>
    <updated>2015-02-04T14:51:00+08:00</updated>
    <id>http://cxh.me/2015/02/04/distinguish-special-symbol-in-shell-and-makefile</id>
    <content type="html"><![CDATA[<p>  主要是在Makefile中看到了这种字符($@)，不理解含义，查阅了一下，跟shell中意义不一样：</p>

<pre><code>$@     -is the name of the target currently being processed.
$&lt;     -is the name of the first dependency.
</code></pre>

<p>  顺便提下shell下的</p>

<pre><code>$#    Stores the number of command-line arguments that were passed to the shell program.
$?    Stores the exit value of the last command that was executed.
$0    Stores the first word of the entered command (the name of the shell program).
$*    Stores all the arguments that were entered on thecommand line ($1 $2 ...).
"$@"  Stores all the arguments that were entered on the command line, individually quoted ("$1" "$2" ...).
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bash下模拟group by功能]]></title>
    <link href="http://cxh.me/2015/01/22/simulate-group-by-in-bash/"/>
    <updated>2015-01-22T15:56:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/simulate-group-by-in-bash</id>
    <content type="html"><![CDATA[<p>  遇到这样一个问题：有一堆数据，需要统计相同key下相同的column的重复出现次数，实际上就是数据库里面的group by功能，但是建表导入然后计算未免麻烦，何况数据是临时数据，导入计算完毕之后就不需要了。这里用shell下的一些命令来完成。</p>

<p>  数据格式</p>

<pre><code>user            tag_id  type        time
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag1    Click       2015:13:37:16
AAAAAAAAAAA     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    Click       2015:13:37:16
BBBBBBBBBBB     tag2    EXPOSURE    2015:13:37:16
</code></pre>

<p>  目的：</p>

<pre><code>统计同一个用户下，同一个tag的点击次数：
</code></pre>

<p>  实现如下：</p>

<ol>
<li><p> 排序</p>

<p>首先对数据进行排序。这是最基本的，见<a href="http://cxh.me/2015/01/22/sort-using-multiple-columns/" title="Sort多列排序">上篇文章</a>。</p>

<pre><code>sort -k 1 
</code></pre></li>
<li><p> 过滤不需要的行和列。</p>

<pre><code>awk '{print $1, $2, $3}' |grep "Click" 
</code></pre></li>
<li><p> 这时候出现了一些重复列了，这也就是我们要做group by的数据。</p>

<pre><code>uniq -c | awk {'print $2, $3, $1'} 
</code></pre></li>
</ol>


<p>  后面awk只是调了一下位置。合并起来就是：</p>

<pre><code>sort -k 1  test.txt|awk '{print $1, $2, $3}' |grep "Click"|uniq -c | awk {'print $2, $3, $1'} 
</code></pre>

<p>  输出结果：</p>

<pre><code>AAAAAAAAAAA tag1 2
AAAAAAAAAAA tag2 1
BBBBBBBBBBB tag2 2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sort多列排序]]></title>
    <link href="http://cxh.me/2015/01/22/sort-using-multiple-columns/"/>
    <updated>2015-01-22T13:38:00+08:00</updated>
    <id>http://cxh.me/2015/01/22/sort-using-multiple-columns</id>
    <content type="html"><![CDATA[<p>  遇到这样一个需求，希望按照第二列排序，第二列相同的情况下按照第一列排序，数据如下：</p>

<pre><code>b   2   c
c   2   b
a   1   b
</code></pre>

<p>  习惯性的用:</p>

<pre><code>sort -k 2 -k 1 input.txt
</code></pre>

<p>  输出结果是：</p>

<pre><code>a   1   b
c   2   b
b   2   c
</code></pre>

<p>  可以看到实际上先按照第二列排序，第二列相同按照第三列排序了。问题在于sort -k默认是按照顺序排序到末尾的。如果要打破默认，需要指定从哪个列到哪个列。</p>

<pre><code>sort -k 2，2 -k 1 input.txt
</code></pre>

<p>  换个角度说，<code>sort -k 1 -k 2</code> 的效果跟 <code>sort -k 1</code> 是一样的。所以最好还是让数据按照排序列生成，这样看起来也最直观。</p>
]]></content>
  </entry>
  
</feed>
