<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | CXH.ME]]></title>
  <link href="http://cxh.me/category/linux/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-06-06T15:03:17+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[有关coredump没有符号的问题]]></title>
    <link href="http://cxh.me/2016/06/06/glibc-no-symbol-problem/"/>
    <updated>2016-06-06T15:02:00+08:00</updated>
    <id>http://cxh.me/2016/06/06/glibc-no-symbol-problem</id>
    <content type="html"><![CDATA[<p>  线上server core掉了，看dmesg能看到core的日志，</p>

<pre><code>s3store[16586]: segfault at 2a28000 ip 00007fda20543b58 sp 00007fd9e9894128 error 4 in libc-2.12.so[7fda204ba000+18a000]
</code></pre>

<p>  但是/proc/sys/kernel/core_pattern指向的位置并没有core文件，改一下core_pattern再跑应该能core出来，不过并不是稳定复现的。所以只能先凭这条日志来分析了。从core的位置看，大概率应该是malloc里面的问题。用</p>

<pre><code>addr2line -e xxx  00007fda20543b58
</code></pre>

<p>  看到的结果是??:0。怀疑是glibc没有调试信息。看一下系统的glibc版本：</p>

<pre><code>rpm -qa |grep glibc
glibc-common-2.12-1.166.el6_7.7.x86_64
glibc-static-2.12-1.166.el6_7.7.x86_64
glibc-2.12-1.166.el6_7.7.x86_64
glibc-devel-2.12-1.166.el6_7.7.x86_64
glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64
glibc-headers-2.12-1.166.el6_7.7.x86_64
glibc-debuginfo-2.12-1.166.el6_7.7.x86_64
</code></pre>

<p>  去centos网站上下对应版本的glibc debuginfo并安装</p>

<pre><code>http://debuginfo.centos.org/6/x86_64/
wget http://debuginfo.centos.org/6/x86_64/glibc-debuginfo-2.12-1.166.el6_7.7.x86_64.rpm
wget http://debuginfo.centos.org/6/x86_64/glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64.rpm
rpm -ivh glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64.rpm
rpm -ivh  glibc-debuginfo-2.12-1.166.el6_7.7.x86_64.rpm
</code></pre>

<p>  之后继续addr2line -e xxx 00007fda20543b58还是没有&hellip;</p>

<p>  我擦嘞。改天继续。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[logrotate版本问题]]></title>
    <link href="http://cxh.me/2016/05/18/loglogrotate-version-problem/"/>
    <updated>2016-05-18T16:02:00+08:00</updated>
    <id>http://cxh.me/2016/05/18/loglogrotate-version-problem</id>
    <content type="html"><![CDATA[<p>  线上运维过程中切日志用了logrotate，但无奈日志打的太多，一天的日志几十G难以分析，遂决定改成每小时切分一次日志。从logrotate的说明看有hourly的支持，但是直接把daily改成hourly之后启动报错：</p>

<pre><code>unknown option 'hourly'
</code></pre>

<p>  感觉是logrotate 3.8.7的版本不支持hourly语法</p>

<p>  rpm安装logrotate高版本的包提示缺少fillup和其他的依赖，同时glibc的版本也要求高版本。于是下载了logrotate的源码安装，以最新版本3.9.2为例</p>

<pre><code>./autogen.sh
./configure
</code></pre>

<p>  提示缺少libpopt头文件，下载了libpopt 1.5的源码安装，提示libtool版本不对。我擦嘞。</p>

<p>  后来突然想到libpopt是debian下的命名，试一下centos下</p>

<pre><code>yum install popt-devel -y
</code></pre>

<p>  搞定。于是继续源码安装，直接用logrotate的官网版本好了。</p>

<pre><code>yum install popt-devel -y
wget https://fedorahosted.org/releases/l/o/logrotate/logrotate-3.8.6.tar.gz
tar zxvf  logrotate-3.8.6.tar.gz
cd logrotate-3.8.6 &amp;&amp; make &amp;&amp; make install
</code></pre>

<p>  这个版本是可以稳定使用的。中间试了几个别的版本，3.8.3还是不支持hourly语法，3.8.5支持了语法，但是测试的时候</p>

<pre><code>logrotate -d /etc/logrotate.conf
</code></pre>

<p>  有core，跟进源码去感觉是依赖bug，换到3.8.6终于ok了&hellip;回去看作者更新日志：</p>

<pre><code>3.8.4 -&gt; 3.8.5
     - Improved rotation during daylight saving time and between timezone
       changes.
     - Fixed ACL setting problem caused by ext3 erroneously reporting ENOSYS
       instead of ENOSUP.
     - Do not continue with rotation if state file is corrupted.
     - Make logrotate.status creation atomic.
     - Allow "hourly" rotation. See manpage for more information.
     - Use "/bin/echo" in tests. Fixes tests execution in Dash.
     - Do no try to parse config files bigger than 16MB.
     - Improved manpage consistency and formatting.
     - Fix race condition between acl_set_fd() and fchmod().
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dirname和basename的一些细节]]></title>
    <link href="http://cxh.me/2016/05/15/dirname-and-basename-cautions/"/>
    <updated>2016-05-15T14:42:00+08:00</updated>
    <id>http://cxh.me/2016/05/15/dirname-and-basename-cautions</id>
    <content type="html"><![CDATA[<p>  作为获取文件名和文件路径的函数，dirname和basename的签名是：</p>

<pre><code>#include &lt;libgen.h&gt;

char *dirname(char *path);

char *basename(char *path);
</code></pre>

<p>  之前没注意的地方是这个函数的输入输出都不是const的，也就意味着这个函数调用过程可能会修改char*指向的string内容。所以直接输出一个不可变字符串是不行的，同理，也要考虑这个非const函数会破坏入参。也就是：</p>

<pre><code>char *str = "/abc/def";
printf("%s\n", dirname(str));
</code></pre>

<p>  会core掉。而</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;libgen.h&gt;
int main(int argc, const char *argv[]) {
  char str[] = "/abc/def";
  printf("%s\n", dirname(str));
  printf("%s\n", basename(str));
  printf("%s\n", str);
  return 0;
}
</code></pre>

<p>  输出结果是：</p>

<pre><code>/abc
abc
/abc
</code></pre>

<p>  还有一个更有意思的问题&hellip;.如果对同一个path先后调用dirname和basename，那么返回的只有一个是对的&hellip;.因为源已经被修改了。反过来可以。</p>

<p>  path在执行过程中被修改了。C系的函数很多面临这个问题，如果不这么做的话要申请一块额外的内存，然后返回，而释放这块内存的工作得调用方完成，这种情况下，内存泄露的可能性很大，所以很多c库函数的选择是用全局变量（getopt等)或者修改入参（basename等）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记录一个网络库设计的bug]]></title>
    <link href="http://cxh.me/2016/03/25/netlib-bug-analysis/"/>
    <updated>2016-03-25T00:14:00+08:00</updated>
    <id>http://cxh.me/2016/03/25/netlib-bug-analysis</id>
    <content type="html"><![CDATA[<p>   今天遇到一个设计上没考虑好的问题，记录一下。</p>

<p>   之前Libeasy的逻辑如果一个连接上有超时的报文的话，整个连接会destroy掉。考虑网络拥塞的情况，如果AB两个报文同时在等待发送，A报文先进入发送队列（链表，非TCP发送buffer），B后进入，而A超时时间长，B立即超时，那么清理掉B的待发送报文的时候，如果destroy掉连接，那么本来可以发送出去的A报文就被强制失败了。</p>

<p>   考虑这种情况做了一点修改，让超时的报文被清理掉的时候不会destroy连接。这样编码的时候需要指定一个报文被编码出来的buffer是属于哪个会话（session）的，同时记录一下每个session对应的最后一个buffer位置。清理的时候可以从上述位置回溯到不属于当前session的buffer或者到头部为止。看似没啥问题。今天发现了如下的bug：</p>

<p>   考虑如果一个会话编码的多个buffer（或者一个buffer）被部分发送完毕（write返回大小为准），这时候会话超时，这个会话所属的所有编码过的buffer都被干掉，但是连接并没有被destroy，之后的报文继续发送的话，客户端实际上收到了不完整的报文，相当于之后的TCP流都错位了。这种情况下，destroy连接是明显更安全的做法。</p>

<p>   所以还是要考虑周全啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh绑定其他端口]]></title>
    <link href="http://cxh.me/2015/11/01/ssh-bind-other-port/"/>
    <updated>2015-11-01T14:14:00+08:00</updated>
    <id>http://cxh.me/2015/11/01/ssh-bind-other-port</id>
    <content type="html"><![CDATA[<p>  首先修改/ssh/sshd_config，把Port 22解注释，然后加一行Port xx。之后修改 /etc/sysconfig/iptables，加入该端口的Rules:</p>

<pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport xx -j ACCEPT  
</code></pre>

<p>  重启即可。</p>

<pre><code>/etc/init.d/sshd restart
</code></pre>

<p>  这么做的目的是如果出现问题，还有一个端口可以上去修改。登录的时候需要对应的指定一下端口：</p>

<pre><code>ssh -p xx user@host
scp -P xx ... user@host
</code></pre>

<p>  补充两个SSH技巧：</p>

<ol>
<li><p> 客户端配置中转，主要是通过跳板机登录：</p>

<pre><code>Host xx
HostName 192.168.1.1
User xx
ProxyCommand ssh -q xxx@login2.xxx.xx nc %h %p
</code></pre></li>
<li><p> 保持会话。 ssh会在.ssh目录下生成一个会话选项，下次登录同一个server公用会话，不需要验证。</p>

<pre><code>Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
</code></pre>

<p>上面会话共享，所以不能关闭会话。可以通过 <code>ssh -fN xxx</code> 把第一个会话放到后台不退出</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
