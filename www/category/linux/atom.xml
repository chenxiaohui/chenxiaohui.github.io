<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | CXH.ME]]></title>
  <link href="http://cxh.me/category/linux/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-06-28T14:35:21+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用timecat来定位日志]]></title>
    <link href="http://cxh.me/2016/06/28/search-log-with-timcat/"/>
    <updated>2016-06-28T14:33:00+08:00</updated>
    <id>http://cxh.me/2016/06/28/search-log-with-timcat</id>
    <content type="html"><![CDATA[<p>  介绍一个日志grep的神器。
  做系统开发的人都有从海量日志里面定位bug的经历，大家一般用如下几种方法：</p>

<ol>
<li>head -n xxx|tail -n 1，大概定位位置</li>
<li>直接grep日志来找到对应的行号并用sed cut一段出来。</li>
<li>把日志灌倒hive等ETL工具里面。</li>
</ol>


<p>  但是如上几种方式要么太慢，要么太复杂。最近突然想到有没有二分·grep的工具，搜到如下一个工具timcat:</p>

<p>  安装：</p>

<pre><code>pip install timecat
</code></pre>

<p>  使用：</p>

<pre><code>timecat -d '2016-01-02' -s '20:13:14' -e '20:14:13' LOGFILE1.log LOGFILE2.log ...
imecat -s '2016-01-02 20:13:14' -e '2016-01-02 20:14:13' LOGFILE1.log LOGFILE2.log ...
For more: timecat -h
</code></pre>

<p>  非常快。</p>

<p>  作者的<a href="http://blog.reetsee.com/archives/502" title="如何对日志文件进行二分查找？开源文件二分查找工具『timecat』介绍">博客</a>讲解如下：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用nfs挂载网络磁盘]]></title>
    <link href="http://cxh.me/2016/06/17/export-disk-using-nfs/"/>
    <updated>2016-06-17T11:58:00+08:00</updated>
    <id>http://cxh.me/2016/06/17/export-disk-using-nfs</id>
    <content type="html"><![CDATA[<p>  分布式环境下经常需要到各个节点启动server，常见的方式推的方式，比如scp到各个结点，但是有时候更新的文件少儿需要scp的文件比较多。这时候可以选择nfs挂载的方式把编译好的文件放到网络磁盘上，然后共享到其他的服务器，这样可以按需使用。</p>

<p>  首先配置一下nfs服务器。假设系统都是centos：</p>

<pre><code>yum install -y nfs-utils
yum install -y portmap
rpm -qa | grep nfs
</code></pre>

<p>  事实上看centos6.5以上portmap应该被rpcbind替代了，而已安装nfs-utils的时候应该顺便安装了rpcbind。之后配置一下需要挂载的磁盘：</p>

<pre><code>文件/etc/exports:
/tmp rz*(rw,async) yf*(ro)
</code></pre>

<p>  简单解释一下： /tmp是挂载的目录路径，后面跟权限控制，可以是主机名或者ip，rz*表示rz开头的主机，括号里面是权限。整条语句表示把/tmp目录共享以rw权限和async方式共享给rz开头的机器，同时以ro权限共享给yf开头的机器。其他属性可以参考<a href="http://www.liusuping.com/ubuntu-linux/Redhat-Linux-NFS-setting.html" title="Redhat Linux下NFS的配置及操作">这里</a>:</p>

<p>  之后启动nfs服务：</p>

<pre><code>service nfs start
</code></pre>

<p>  需要挂载机器上同样安装客户端：</p>

<pre><code>yum install -y nfs-utils
</code></pre>

<p>  挂载到指定的目录：</p>

<pre><code>mkdir fs &amp;&amp; mount -t nfs xxx.xxx.xx.xx:/tmp ./fs
</code></pre>

<p>  xxx指定机器名或者ip</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Redhat Linux下NFS的配置及操作, <a href="http://www.liusuping.com/ubuntu-linux/Redhat-Linux-NFS-setting.html">http://www.liusuping.com/ubuntu-linux/Redhat-Linux-NFS-setting.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关coredump没有符号的问题]]></title>
    <link href="http://cxh.me/2016/06/06/glibc-no-symbol-problem/"/>
    <updated>2016-06-06T15:02:00+08:00</updated>
    <id>http://cxh.me/2016/06/06/glibc-no-symbol-problem</id>
    <content type="html"><![CDATA[<p>  线上server core掉了，看dmesg能看到core的日志，</p>

<pre><code>s3store[16586]: segfault at 2a28000 ip 00007fda20543b58 sp 00007fd9e9894128 error 4 in libc-2.12.so[7fda204ba000+18a000]
</code></pre>

<p>  但是/proc/sys/kernel/core_pattern指向的位置并没有core文件，改一下core_pattern再跑应该能core出来，不过并不是稳定复现的。所以只能先凭这条日志来分析了。从core的位置看，大概率应该是malloc里面的问题。用</p>

<pre><code>addr2line -e xxx  00007fda20543b58
</code></pre>

<p>  看到的结果是??:0。怀疑是glibc没有调试信息。看一下系统的glibc版本：</p>

<pre><code>rpm -qa |grep glibc
glibc-common-2.12-1.166.el6_7.7.x86_64
glibc-static-2.12-1.166.el6_7.7.x86_64
glibc-2.12-1.166.el6_7.7.x86_64
glibc-devel-2.12-1.166.el6_7.7.x86_64
glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64
glibc-headers-2.12-1.166.el6_7.7.x86_64
glibc-debuginfo-2.12-1.166.el6_7.7.x86_64
</code></pre>

<p>  去centos网站上下对应版本的glibc debuginfo并安装</p>

<pre><code>http://debuginfo.centos.org/6/x86_64/
wget http://debuginfo.centos.org/6/x86_64/glibc-debuginfo-2.12-1.166.el6_7.7.x86_64.rpm
wget http://debuginfo.centos.org/6/x86_64/glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64.rpm
rpm -ivh glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64.rpm
rpm -ivh  glibc-debuginfo-2.12-1.166.el6_7.7.x86_64.rpm
</code></pre>

<p>  之后继续addr2line -e xxx 00007fda20543b58还是没有&hellip;</p>

<p>  我擦嘞。改天继续。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[logrotate版本问题]]></title>
    <link href="http://cxh.me/2016/05/18/loglogrotate-version-problem/"/>
    <updated>2016-05-18T16:02:00+08:00</updated>
    <id>http://cxh.me/2016/05/18/loglogrotate-version-problem</id>
    <content type="html"><![CDATA[<p>  线上运维过程中切日志用了logrotate，但无奈日志打的太多，一天的日志几十G难以分析，遂决定改成每小时切分一次日志。从logrotate的说明看有hourly的支持，但是直接把daily改成hourly之后启动报错：</p>

<pre><code>unknown option 'hourly'
</code></pre>

<p>  感觉是logrotate 3.8.7的版本不支持hourly语法</p>

<p>  rpm安装logrotate高版本的包提示缺少fillup和其他的依赖，同时glibc的版本也要求高版本。于是下载了logrotate的源码安装，以最新版本3.9.2为例</p>

<pre><code>./autogen.sh
./configure
</code></pre>

<p>  提示缺少libpopt头文件，下载了libpopt 1.5的源码安装，提示libtool版本不对。我擦嘞。</p>

<p>  后来突然想到libpopt是debian下的命名，试一下centos下</p>

<pre><code>yum install popt-devel -y
</code></pre>

<p>  搞定。于是继续源码安装，直接用logrotate的官网版本好了。</p>

<pre><code>yum install popt-devel -y
wget https://fedorahosted.org/releases/l/o/logrotate/logrotate-3.8.6.tar.gz
tar zxvf  logrotate-3.8.6.tar.gz
cd logrotate-3.8.6 &amp;&amp; make &amp;&amp; make install
</code></pre>

<p>  这个版本是可以稳定使用的。中间试了几个别的版本，3.8.3还是不支持hourly语法，3.8.5支持了语法，但是测试的时候</p>

<pre><code>logrotate -d /etc/logrotate.conf
</code></pre>

<p>  有core，跟进源码去感觉是依赖bug，换到3.8.6终于ok了&hellip;回去看作者更新日志：</p>

<pre><code>3.8.4 -&gt; 3.8.5
     - Improved rotation during daylight saving time and between timezone
       changes.
     - Fixed ACL setting problem caused by ext3 erroneously reporting ENOSYS
       instead of ENOSUP.
     - Do not continue with rotation if state file is corrupted.
     - Make logrotate.status creation atomic.
     - Allow "hourly" rotation. See manpage for more information.
     - Use "/bin/echo" in tests. Fixes tests execution in Dash.
     - Do no try to parse config files bigger than 16MB.
     - Improved manpage consistency and formatting.
     - Fix race condition between acl_set_fd() and fchmod().
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dirname和basename的一些细节]]></title>
    <link href="http://cxh.me/2016/05/15/dirname-and-basename-cautions/"/>
    <updated>2016-05-15T14:42:00+08:00</updated>
    <id>http://cxh.me/2016/05/15/dirname-and-basename-cautions</id>
    <content type="html"><![CDATA[<p>  作为获取文件名和文件路径的函数，dirname和basename的签名是：</p>

<pre><code>#include &lt;libgen.h&gt;

char *dirname(char *path);

char *basename(char *path);
</code></pre>

<p>  之前没注意的地方是这个函数的输入输出都不是const的，也就意味着这个函数调用过程可能会修改char*指向的string内容。所以直接输出一个不可变字符串是不行的，同理，也要考虑这个非const函数会破坏入参。也就是：</p>

<pre><code>char *str = "/abc/def";
printf("%s\n", dirname(str));
</code></pre>

<p>  会core掉。而</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;libgen.h&gt;
int main(int argc, const char *argv[]) {
  char str[] = "/abc/def";
  printf("%s\n", dirname(str));
  printf("%s\n", basename(str));
  printf("%s\n", str);
  return 0;
}
</code></pre>

<p>  输出结果是：</p>

<pre><code>/abc
abc
/abc
</code></pre>

<p>  还有一个更有意思的问题&hellip;.如果对同一个path先后调用dirname和basename，那么返回的只有一个是对的&hellip;.因为源已经被修改了。反过来可以。</p>

<p>  path在执行过程中被修改了。C系的函数很多面临这个问题，如果不这么做的话要申请一块额外的内存，然后返回，而释放这块内存的工作得调用方完成，这种情况下，内存泄露的可能性很大，所以很多c库函数的选择是用全局变量（getopt等)或者修改入参（basename等）。</p>
]]></content>
  </entry>
  
</feed>
