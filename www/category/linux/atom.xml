<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | CXH.ME]]></title>
  <link href="http://cxh.me/category/linux/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-03-25T00:25:07+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记录一个网络库设计的bug]]></title>
    <link href="http://cxh.me/2016/03/25/netlib-bug-analysis/"/>
    <updated>2016-03-25T00:14:00+08:00</updated>
    <id>http://cxh.me/2016/03/25/netlib-bug-analysis</id>
    <content type="html"><![CDATA[<p>   今天遇到一个设计上没考虑好的问题，记录一下。</p>

<p>   之前Libeasy的逻辑如果一个连接上有超时的报文的话，整个连接会destroy掉。考虑网络拥塞的情况，如果AB两个报文同时在等待发送，A报文先进入发送队列（链表，非TCP发送buffer），B后进入，而A超时时间长，B立即超时，那么清理掉B的待发送报文的时候，如果destroy掉连接，那么本来可以发送出去的A报文就被强制失败了。</p>

<p>   考虑这种情况做了一点修改，让超时的报文被清理掉的时候不会destroy连接。这样编码的时候需要指定一个报文被编码出来的buffer是属于哪个会话（session）的，同时记录一下每个session对应的最后一个buffer位置。清理的时候可以从上述位置回溯到不属于当前session的buffer或者到头部为止。看似没啥问题。今天发现了如下的bug：</p>

<p>   考虑如果一个会话编码的多个buffer（或者一个buffer）被部分发送完毕（write返回大小为准），这时候会话超时，这个会话所属的所有编码过的buffer都被干掉，但是连接并没有被destroy，之后的报文继续发送的话，客户端实际上收到了不完整的报文，相当于之后的TCP流都错位了。这种情况下，destroy连接是明显更安全的做法。</p>

<p>   所以还是要考虑周全啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh绑定其他端口]]></title>
    <link href="http://cxh.me/2015/11/01/ssh-bind-other-port/"/>
    <updated>2015-11-01T14:14:00+08:00</updated>
    <id>http://cxh.me/2015/11/01/ssh-bind-other-port</id>
    <content type="html"><![CDATA[<p>  首先修改/ssh/sshd_config，把Port 22解注释，然后加一行Port xx。之后修改 /etc/sysconfig/iptables，加入该端口的Rules:</p>

<pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport xx -j ACCEPT  
</code></pre>

<p>  重启即可。</p>

<pre><code>/etc/init.d/sshd restart
</code></pre>

<p>  这么做的目的是如果出现问题，还有一个端口可以上去修改。登录的时候需要对应的指定一下端口：</p>

<pre><code>ssh -p xx user@host
scp -P xx ... user@host
</code></pre>

<p>  补充两个SSH技巧：</p>

<ol>
<li><p> 客户端配置中转，主要是通过跳板机登录：</p>

<pre><code>Host xx
HostName 192.168.1.1
User xx
ProxyCommand ssh -q xxx@login2.xxx.xx nc %h %p
</code></pre></li>
<li><p> 保持会话。 ssh会在.ssh目录下生成一个会话选项，下次登录同一个server公用会话，不需要验证。</p>

<pre><code>Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
</code></pre>

<p>上面会话共享，所以不能关闭会话。可以通过 <code>ssh -fN xxx</code> 把第一个会话放到后台不退出</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log4cxx安装]]></title>
    <link href="http://cxh.me/2015/07/30/log4cxx-setup/"/>
    <updated>2015-07-30T15:55:00+08:00</updated>
    <id>http://cxh.me/2015/07/30/log4cxx-setup</id>
    <content type="html"><![CDATA[<p>  log4cxx是apache基金会的log开源项目，log4j的c++实现，安装的时候遇到一个小问题：</p>

<p>  首先正常安装：</p>

<pre><code>wget http://mirrors.cnnic.cn/apache/logging/log4cxx/0.10.0/apache-log4cxx-0.10.0.tar.gz
tar zxvf apache-log4cxx-0.10.0.tar.gz
cd apache-log4cxx-0.10.0
./configure
make
</code></pre>

<p>   报错libdb-4.3.so 格式错误。开始以为是文件损坏了，查了一下这个文件</p>

<pre><code>yum provides */libdb-4.3.so
</code></pre>

<p>   提示在db4里面，重新安装db4</p>

<pre><code>yum reinstall db4
</code></pre>

<p>   回去还是报错。后来看了一下格式，貌似链接到了32位版本。修改软连接：</p>

<pre><code>cd /usr/lib/
rm libdb-4.3.so
ln -s ../../lib64/libdb-4.3.so .
</code></pre>

<p>   同样处理另外一个库</p>

<pre><code>rm libexpat.so
ln -s ../../lib64/libexpat.so.0.5.0 libexpat.so
</code></pre>

<p>   应该就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git远程分支不存在的问题]]></title>
    <link href="http://cxh.me/2015/05/11/git-remote-branch-not-exists/"/>
    <updated>2015-05-11T12:11:00+08:00</updated>
    <id>http://cxh.me/2015/05/11/git-remote-branch-not-exists</id>
    <content type="html"><![CDATA[<p>  建立了一个远程分支，提交到origin上之后，发现之前有一个同样的远程Repository存在，而且名字一样，这就比较D疼了，git branch -a 显示的分支里面的分支提交到了另一个Repository，但是这个Repository已经改名字了，虽然地址一样。</p>

<p>  搞来搞去之后发现git checkout远程分支的时候报不存在的问题，删除这个分支的时候同样有这个问题：</p>

<pre><code>unable to delete 'refactor': remote ref does not exist
</code></pre>

<p>  导致这个分支就这么存在着删不掉了。查stackoverflow有人给出<a href="http://stackoverflow.com/questions/10292480/when-deleting-remote-git-branch-error-unable-to-push-to-unqualified-destinatio" title="When deleting remote git branch “error: unable to push to unqualified destination”">如下的方案</a>：</p>

<pre><code>git fetch -p origin
</code></pre>

<p>  问题是能解决了，但是不太理解为什么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于sendmail邮件服务器的搭建]]></title>
    <link href="http://cxh.me/2015/04/01/something-about-sendmail-setup/"/>
    <updated>2015-04-01T20:14:00+08:00</updated>
    <id>http://cxh.me/2015/04/01/something-about-sendmail-setup</id>
    <content type="html"><![CDATA[<p>  还是reviewboard的事情，我们需要一个自己的邮件服务器来发通知邮件。sendmail是一个比较好的选择，搭建的方式很简单，安装sendmail，修改配置文件，修改local_host_name就行。如果不需要登陆验证，这样也就直接能用了。现在的问题是reviewboard是必须登陆验证的。至少看报错上是这样。</p>

<pre><code>SMTPException: SMTP AUTH extension not supported by server. reviewboard
</code></pre>

<p>  具体代码没细看，但是应该默认都有认证，只是认证方式不一样。我们telnet到25端口，执行</p>

<pre><code>ehlo localhost


/usr/sbin/testsaslauthd -u username -p sohutest

mail -s "test" xxx@xxx.com &lt;content.txt
</code></pre>

<!--more-->


<p>  如果邮件不能正常发送可以通过如下方式debug：</p>

<pre><code>1. 查看/var/log/messages
2. 查看用户mail
3. 通过telnet模拟一下登陆发邮件的过程：

        HELO localhost
        AUTH LOGIN 
        aGFycnljaGVu
        password
        MAIL FROM:&lt;test@xxx.com&gt;
        RCPT TO:&lt;username@xxx.com&gt;
        DATA
        To: username@xxx.com
        From:test@xxx.com
        Subject:test mail
        From:test@xxx.com
        test body
        .
        quit
</code></pre>

<p>  安装reviewboard的过程还发现一个问题，邮件服务器已经可以正常发邮件了，reviewboard还是失败，看到如下报错：</p>

<pre><code>- Error sending e-mail notification with subject 'Review Request 2: [retrieval-ad][master][NewFeature] Readme' on behalf of '"UserName" &lt;xxx@xxx.com&gt;' to '"UserName" &lt;xxx@xxx.com&gt;,xxx@xxx.com'
Traceback (most recent call last):
  File "/opt/xxx/rb/lib/python2.7/site-packages/ReviewBoard-2.0.15-py2.7.egg/reviewboard/notifications/email.py", line 294, in send_review_mail
    message.send()
  File "/opt/xxx/rb/lib/python2.7/site-packages/Django-1.6.11-py2.7.egg/django/core/mail/message.py", line 276, in send
    return self.get_connection(fail_silently).send_messages([self])
  File "/opt/xxx/rb/lib/python2.7/site-packages/Django-1.6.11-py2.7.egg/django/core/mail/backends/smtp.py", line 87, in send_messages
    new_conn_created = self.open()
  File "/opt/xxx/rb/lib/python2.7/site-packages/Django-1.6.11-py2.7.egg/django/core/mail/backends/smtp.py", line 54, in open
    self.connection.login(self.username, self.password)
  File "/usr/local/lib/python2.7/smtplib.py", line 613, in login
    raise SMTPAuthenticationError(code, resp)
SMTPAuthenticationError: (535, '5.7.0 authentication failed')
</code></pre>

<p>  跟到如下smtplib.py里面看验证方法，调整了顺序（我这支持AUTH LOGIN PLAIN，没支持PAM)，然后保证用户名密码正确就基本可以使用了。</p>
]]></content>
  </entry>
  
</feed>
