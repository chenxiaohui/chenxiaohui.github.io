<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | CXH.ME]]></title>
  <link href="http://cxh.me/category/vim/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-05T17:23:53+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自己写的一个根据路径打开文件的插件]]></title>
    <link href="http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list/"/>
    <updated>2013-11-08T21:26:00+08:00</updated>
    <id>http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list</id>
    <content type="html"><![CDATA[<p>这个其实修改了很多次，最初的目的是在linux下嘛，找电影不方便，只能用locate打印出一个电影列表来，但是每次复制路径到命令行多不方便啊，最好能在vim里面操作，于是想想干脆做成通用的好了，就有了这个filelist.vim</p>

<!-- more -->


<pre><code>"=============================================================================
"     FileName: filelist.vim
"         Desc:
"       Author: ChenXiaohui
"        Email: sdqxcxh@gmail.com
"     HomePage: http://www.cxh.me
"      Version: 0.0.1
"   LastChange: 2013-11-06 20:31:23
"      History:
"=============================================================================
function! GetCmd(type,line)
    let cmd=get(g:applist,a:type)
    if empty(cmd)
        let cmd=get(g:applist,'default')
    endif
    "no %
    if cmd[0] != '!' &amp;&amp; cmd[0] != ':'
        let cmd='!nohup '.cmd.' '.Trans(a:line).' &gt;/dev/null 2&gt;&amp;1 &amp;'
    else
        let cmd=substitute(cmd,'%',Trans(Trans(a:line)),'g')
    endif

    "let cmd=substitute(cmd,'%&lt;',a:line,'g')
    return cmd
endfunction

function! OpenFileWithDefApp()
    let cmd=''
    let origin_line = Trim(Trim(getline("."),'\\'), ' ')

    let idx = stridx(origin_line,':')
    echo idx
    if idx &gt; -1
        let line = strpart(origin_line, 0, idx)
        let linenum = strpart(origin_line, idx)
    else
        let line = origin_line
    endif

    if !filereadable(line)
        "Directory
        let cmd=GetCmd('pwd',line)
    else
        let idx=strridx(line,".")
        "has no ext
        if idx==-1
            let cmd=GetCmd('default',line)
        else
            let fileExt = tolower(matchstr(line,'\.\w\+'))
            let fileExt=tolower(strpart(fileExt,1))
            for [exts,app] in items(g:applist)
                let supportExt=split(exts,',')
                if index(supportExt,fileExt)&gt;=0
                    let cmd=GetCmd(exts,line)
                endif
            endfor
        endif
    endif

    if empty(cmd)
        let cmd=GetCmd('default',line)
    endif
    execute cmd
    if exists('linenum')
        execute linenum
        execute ':call Vm_toggle_sign()'
        "execute ':set cursorline'
        "normal V
    endif
endf

function! DelFile ()
    let line=getline(".")
    if !filereadable(line)
        "echo "!rm -ri ".Trans(getline("."))
        :execute "!rm -ri ".Trans(getline("."))
    else
        "echo "!rm -i ".Trans(getline("."))
        :execute "!rm -i ".Trans(getline("."))
    endif
    :del
endf

function! CopyFile()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd='!cp -a'.Trans(line).' '.Trans(g:dst_dir)
    else
        let cmd='!cp '.Trans(line).' '.Trans(g:dst_dir)
    endif
    :execute cmd
endf

function! ChDir()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd=':cd '.Trans(line)
    else
        let cmd=':cd '.Trans(DirName(line))
    endif
    :execute cmd
    ":echo cmd
    :sh
endf

function! DirName(line)
    let idx=strridx(a:line,'/')
    return strpart(a:line,0,idx)
endf

function! Trans(line)
    let line=Trim(a:line, ' ')
    let line=substitute(line,"'","\\\\'","g")
    let line=substitute(line,' ','\\ ','g')
    let line=substitute(line,'!','\\!','g')
    let line=substitute(line,'#','\\#','g')
    let line=substitute(line,'&amp;','\\&amp;','g')
    let line=substitute(line,'(','\\(','g')
    let line=substitute(line,')','\\)','g')
    return line
    "return "'".line."'"
    "return "'".substitute(a:line,"'","'\\\\''","g")."'"
endf
</code></pre>

<p>  原理还是很简单的，分析当前行，得到文件路径，根据类型找到关联命令，然后替换关联命令得到最后的shell命令并执行。就是一堆转义比较罗嗦，在vimrc里面定义关联程序信息：</p>

<pre><code>" plugin- deal with filelist
nnoremap &lt;leader&gt;co :call OpenFileWithDefApp()&lt;cr&gt;
nnoremap &lt;leader&gt;rm :call DelFile()&lt;cr&gt;
nnoremap &lt;leader&gt;cd :call ChDir()&lt;cr&gt;
nnoremap &lt;leader&gt;to :call CopyFile()&lt;cr&gt;
let g:dst_dir="/media/cxh/MY MP3/"
let g:applist={
            \'pdf':'evince',
            \'png,gif,jpg':'eog',
            \'rmvb,mkv,flv,avi,mp4,m4v':'mplayer',
            \'rar':'!unrar l %',
            \'epub':'!calibre %',
            \'zip':'!unzip -O CP936 -l %',
            \'pwd':'nautilus',
            \'docx,xlsx,pptx,ppt':'libreoffice',
            \'default':':e %'
            \}
</code></pre>

<p>  需要特别说明的是：</p>

<ol>
<li> 几个函数的作用分别是调用执行程序打开当前文件，删除，到当前文件所在路径下，和copy当前文件到制定的dst_dir（这个我主要用在替代windows下的发动到移动存储介质用了）</li>
<li> applist是类型-程序关联数组，说明一下，%会被替换成当前行所指定的文件路径。如果applist里面的命令既不是!开头（shell执行）也不是:开头（vim内部命令），就会被转换成类似于：!nohup mplayer /media/xx.rmvb >/dev/null 2>&amp;1 &amp;的命令，相当于windows的调用默认程序打开。</li>
<li> 支持这种形式的行号调用 xxx.cpp:123 默认用:e 打开之后会定位到对应行，然后标红，标红使用三种方式：<strong>visualmark</strong>, <strong>cursorline</strong>和<strong>normal V</strong>，第一种需要<a href="http://www.vim.org/scripts/script.php?script_id=1026" title="Visual Mark : Visual mark, similar to UltraEdit's bookmark">安装插件</a></li>
</ol>


<p>  钦此。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Visual Mark : Visual mark, similar to UltraEdit&rsquo;s bookmark, <a href="http://www.vim.org/scripts/script.php?script_id=1026">http://www.vim.org/scripts/script.php?script_id=1026</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress的一些技巧]]></title>
    <link href="http://cxh.me/2013/09/14/tricks-about-octopress/"/>
    <updated>2013-09-14T15:03:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/tricks-about-octopress</id>
    <content type="html"><![CDATA[<p>自从把wordpress换成Octopress, 腰不酸了背不疼了, 写博客也有劲了~</p>

<p>以上只是吐个槽而已, Octopress是基于Jekyll的博客系统, Jekyll是从markdown生成静态网页的网页生成器. 这是背景. 详细的不表.</p>

<p>主要说下面几个小技巧:</p>

<!-- more -->


<h3>1. alias(别名)</h3>

<p>话说每次写博客的时候要敲rake new_post/ rake generate/ rake preview/ rake deploy&hellip;等等, 中间再出一点什么git同步的错误, 严重影响写博客的心情.可以通过alias简化命令:</p>

<pre><code>alias rg='rake generate &amp;&amp; rake preview'
alias rd='rake deploy &amp;&amp; git add . &amp;&amp; git commit "`date`" &amp;&amp; git push origin source'
alias rn='rake new_post'
</code></pre>

<h3>2. 插入图片</h3>

<p>octopress的一大优点是插图片方便, 拷贝到source/images目录下, 然后在markdown里插入就行了, 但是不是很智能啊&hellip;其实如果大家在vim里装了nerdtree的话, 完全可以通过nerdtree找到图片, 然后拷贝图片链接. 问题是nerd_tree不支持这个操作&hellip;</p>

<p><img src="/images/2013-9/are-you-fucking-kidding-me.jpg" title="你特么在逗我?" alt="" /></p>

<p>不过我们可以 <a href="http://stackoverflow.com/questions/16368771/copy-path-file-with-nerdtree-vim-plugin" title="Copy path file with NERDtree Vim plugin">扩展一下nerd_tree</a>. 在$VIM/nerdtree_plugin下建立yank_mapping.vim, 内容如下</p>

<pre><code>call NERDTreeAddKeyMap({
        \ 'key': 'yy',
        \ 'callback': 'NERDTreeYankCurrentNode',
        \ 'quickhelpText': 'put full path of current node into the default register' })
function! NERDTreeYankCurrentNode()
    let n = g:NERDTreeFileNode.GetSelected()
    if n != {}
        call setreg('"', n.path.str())
    endif
endfunction
</code></pre>

<p>这样找到文件之后就可以yy了~~~    yy&hellip;yy&hellip;</p>

<h3>3. 生成文件直接打开</h3>

<p>我们执行rake new_post之后, 填好title之后会在_post下生成一个markdown文件(先不讨论title翻译slug的蛋疼之处), 每次那么长的文件命不能让我每次都敲进去或者复制进去吧. 我们可以修改Rakefile在task:new_post最后加一句自动打开生成的文件:</p>

<pre><code>system "vi #{filename}"
</code></pre>

<h3>4. 加快生成速度</h3>

<p>Jekyll每次都会生成所有的_posts, 这会导致生成速度的极度下降, 而且官方也没有给出什么解决方案啊. Octopress实现一个比较笨的办法, Rake Isolate和 Rake Integrate, 从名字就可以看出, 是把需要生成的文件保留, 其他的都移出去, 生成完毕之后再移动回来. 不管怎么说吧, 至少是个方案. 写了一段简单的vimscript实现这个功能跟vim的集成.</p>

<pre><code>"plugin -ocotpress  写octopress博客的插件
function! RakePreview()
  silent! execute "!rake isolate['".expand("%&lt;")."']"
  silent! execute "!rake generate"
  silent! execute "!rake integrate"
  silent! execute "!google-chrome http://localhost:4000"
  silent! execute "!rake preview"
endf

nmap &lt;leader&gt;rp :call RakePreview()&lt;cr&gt;
</code></pre>

<p>chrome打开的时候还没有执行preview, 所以需要再刷新一下&hellip;preview有些输出, 觉得不想看的可以重定向.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用vimdiff来显示gitdiff]]></title>
    <link href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/"/>
    <updated>2013-09-14T11:40:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff</id>
    <content type="html"><![CDATA[<p>git diff默认是调用linux的diff工具的, 一眼看上去毕竟还是不知所云, 不像其他两栏的diff工具那么直观. 我们可以考虑用vimdiff来显示gitdiff的结果.</p>

<p>具体说来有两种办法:</p>

<!-- more -->


<p>在~/.gitconfig中我们可以通过如下语句添加一个配置项, 指明使用的diff工具.</p>

<p>git config &mdash;global diff.tool vimdiff<br/>
git config &mdash;global difftool.prompt No</p>

<p>这里需要注意的是我们需要通过git difftool来调用vimdiff, 默认的gitdiff依然是调用Linux diff工具的.</p>

<p>第二行[difftool].prompt 的作用是免除gitdiff时的提示, 否则会有如下的结果:</p>

<p><img src="/images/2013-9/difftool-prompt.png" title="git diff prompt" alt="" /></p>

<p>当然我们也可以替换掉默认的diff工具, 可以指定</p>

<pre><code>git config --global diff.external git_diff_wrapper
</code></pre>

<p>然后在PATH的某个目录下建立git_diff_wrapper, 比如/usr/bin/git_diff_wrapper, 内容如下:</p>

<pre><code>#!/bin/sh
vimdiff "$2" "$5"
</code></pre>

<p>最后加执行权限</p>

<pre><code>chmod +x git_diff_wrapper
</code></pre>

<p>执行git diff的时候就可以看到效果</p>

<p><img src="/images/2013-9/git-vimdiff.png" title="vim diff 效果" alt="" /></p>

<p>可以看出git其实就是调用了一个外部命令然后把参数传入(分别是当前修改的文件和从版本库获取的文件, 这个文件会在tmp下生成).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim轻量级缓冲区管理插件Buf_it修订版Buf_itv2]]></title>
    <link href="http://cxh.me/2012/06/28/light-vim-buffer-management-plugin-bufit-v2/"/>
    <updated>2012-06-28T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/06/28/light-vim-buffer-management-plugin-bufit-v2</id>
    <content type="html"><![CDATA[<h1></h1>

<p>之前发布了Vim的缓冲区管理插件Buf_it的一个修正版，但是后来发现在windows下命令行使用的时候有问题，同时与Nertree和Taglist等插件也有冲突。于是继续fix了几个bug，然后解决了这部分冲突，新的代码放在我的<a href="https://github.com/BitRobt" title="Bitrobt">github</a>上，或者也可以这里下载，有问题可以继续留言，谢谢。</p>

<p>效果如下：</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="效果图" alt="效果图" /></p>

<h2>安装：</h2>

<blockquote><p>扔进plugin目录就行</p></blockquote>

<h2>配置</h2>

<pre><code>nnoremap wq :w:call BufClose(0)
nnoremap q :call BufClose(0)
nnoremap w :w
nnoremap x :call BufClose(1)
</code></pre>

<h2>使用</h2>

<blockquote><p>shift h,l ：左右切换tab</p>

<p>\be ：BufEcho 显示当前缓冲区名字</p>

<p>\bo ：只保留当前缓冲区，其他的都关掉</p>

<p>alt i : 切换到序号为i的缓冲区</p>

<p>\wq: 保存关闭当前缓冲区并退出</p>

<p>\q: 关闭当前缓冲区并退出</p>

<p>\w: 保存当前缓冲区</p>

<p>\x: 不保存关闭当前缓冲区</p></blockquote>

<h2>参考文献：</h2>

<blockquote><p><a href="https://github.com/BitRobt" title="Bitrobt">1</a> buf_it : Buffer list in statusline,</p>

<p><a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="效果图">2</a> 在windows下给你的右键菜单添加”edit with vim”的方法,</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布VIM缓冲区切换插件buf_it升级版]]></title>
    <link href="http://cxh.me/2012/03/28/publish-the-vim-buffer-management-plugin/"/>
    <updated>2012-03-28T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/03/28/publish-the-vim-buffer-management-plugin</id>
    <content type="html"><![CDATA[<h1></h1>

<p>VIM默认使用的过程中有一个重要的问题，就是打开多个文件的时候无法可视化看到打开的文件，并在这些文件中切换。MiniBufExplorer是一个常用的buffer切换插件，但是这个插件在Windows下使用的时候有许多问题，同时也太繁琐。buf_it<a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="image">1</a>则实现了轻量的buffer管理，但是buf_it同样在windows下有许多问题，而buf_it的退出机制也会出现只想关闭一个文件确关闭了整个vim的情况。</p>

<p>基于这两个问题，我修改了buf_it插件，这里共享出来，欢迎大家提意见。先给张图</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="image" alt="image" /></p>

<p>修改：</p>

<blockquote><p>1 windows下使用GVIM优化，方式多开一个空白缓冲区，windows下gvim右键配置见参考文献2</p>

<p>2 增加自定义退出方式</p>

<p>3 修改了部分快捷键，只是个人习惯，可无视之</p></blockquote>

<p>安装：</p>

<blockquote><p>直接扔到plugin目录就行，原作者没写doc，那我也不写啦。</p></blockquote>

<p>配置：</p>

<blockquote><p>nnoremap wq :w:call BufClose()
nnoremap q :call BufClose()
nnoremap w :w
nnoremap x :bd!:call BufClose()</p></blockquote>

<p>使用：</p>

<blockquote><p>shift h,l ：左右切换tab</p>

<p>be ：BufEcho 显示当前缓冲区名字</p>

<p>bo ：只保留当前缓冲区，其他的都关掉</p>

<p>alt i : 切换到序号为i的缓冲区</p>

<p>wq: 保存关闭当前缓冲区并退出</p>

<p>q: 关闭当前缓冲区并退出</p>

<p>w: 保存当前缓冲区</p>

<p>x: 不保存关闭当前缓冲区</p></blockquote>

<p>下载:<a href="http://www.roybit.com/wp-content/uploads/2012/03/buf_it.rar">buf_it</a></p>

<p>参考文献：</p>

<blockquote><p><a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="image">1</a> buf_it : Buffer list in statusline,</p>

<p><a href="http://www.roybit.com/wp-content/uploads/2012/03/buf_it.rar">2</a> 在windows下给你的右键菜单添加"edit with vim"的方法,</p></blockquote>
]]></content>
  </entry>
  
</feed>
