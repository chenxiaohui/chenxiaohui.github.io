<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | CXH.ME]]></title>
  <link href="http://cxh.me/category/vim/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-16T20:35:41+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[vim7.4 && vimgdb编译]]></title>
    <link href="http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile/"/>
    <updated>2014-06-09T10:52:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile</id>
    <content type="html"><![CDATA[<p>  首先，你下载的vim7.4代码的一般结构跟常见的工程是不一样的，主要体现在configure不会生成Makefile，make的时候是通过Makefile的配置生成config.h的，也就是说你想的好好的希望如下操作：</p>

<pre><code> ./configure --prefix=$HOME --with-features=huge --enable-multibyte --enable-pythoninterp --enable-cscope --enable-fontset --enable-gdb --enable-largefile \
 --enable-gui=gnome2 \
 --enable-luainterp \
 --enable-tclinterp \
 --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu  #编译配置
 --with-lua-prefix=/usr/local/bin/lua

    make &amp;&amp; make install
</code></pre>

<p>  来编译的话，那么实际配置跟上面configure里面是没有关系的。</p>

<p>  以你需要做的是修改Makefile，打开必要的开关，比如安装目录，lua支持什么的</p>

<pre><code># Uncomment the next line to install Vim in your home directory.
prefix = $(HOME)
# LUA
# Uncomment one of these when you want to include the Lua interface.
# First one is for static linking, second one for dynamic loading.
# Use --with-luajit if you want to use LuaJIT instead of Lua.
# Set PATH environment variable to find lua or luajit executable.
CONF_OPT_LUA = --enable-luainterp
#CONF_OPT_LUA = --enable-luainterp=dynamic
#CONF_OPT_LUA = --enable-luainterp --with-luajit
#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit
</code></pre>

<p>  其他的操作按如下步骤就行，摘自<a href="https://github.com/larrupingpig/vimgdb-for-vim7.4" title="vimgdb">larrupingpig/vimgdb-for-vim7.4</a>：</p>

<h3>vimgdb install</h3>

<p>  You need:</p>

<p>  vim-7.4.tar.bz2 <a href="http://www.vim.org/sources.php">http://www.vim.org/sources.php</a></p>

<p>  vimgdb-for-vim7.4 (this patch) <a href="https://github.com/larrupingpig/vimgdb-for-vim7.4">https://github.com/larrupingpig/vimgdb-for-vim7.4</a></p>

<p>  Untar all files, apply the patch and make Vim:</p>

<pre><code>tar xjvf vim-7.4.tar.bz2 -C /tmp

tar xzvf vimgdb-for-vim7.4.tar.gz -C /tmp

cd /tmp

patch -p0 &lt; vimgdb-for-vim7.4/vim74.patch

cd vim74/src

make

sudo make install
</code></pre>

<h3>Install vimGdb runtime:</h3>

<p>  Copy the file vimgdb_runtime found in the vimgdb tarball, to your runtime path. To find your runtime path location execute the vim command (this is usually $HOME/.vim): :set runtimepath?</p>

<pre><code>cp -rf /tmp/vimgdb-for-vim7.4/vimgdb_runtime/* ~/.vim
</code></pre>

<p>  Change to the doc directory, start Vim and run the &ldquo;:helptags .&rdquo; command to process the taglist help file. Without this step, you cannot jump to the taglist help topics. You can now use the &ldquo;:help vimgdb&rdquo; command to get the vimGdb documentation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己写的一个根据路径打开文件的插件]]></title>
    <link href="http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list/"/>
    <updated>2013-11-08T21:26:00+08:00</updated>
    <id>http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list</id>
    <content type="html"><![CDATA[<p>这个其实修改了很多次，最初的目的是在linux下嘛，找电影不方便，只能用locate打印出一个电影列表来，但是每次复制路径到命令行多不方便啊，最好能在vim里面操作，于是想想干脆做成通用的好了，就有了这个filelist.vim</p>

<!-- more -->


<pre><code>"=============================================================================
"     FileName: filelist.vim
"         Desc:
"       Author: ChenXiaohui
"        Email: sdqxcxh@gmail.com
"     HomePage: http://www.cxh.me
"      Version: 0.0.1
"   LastChange: 2013-11-06 20:31:23
"      History:
"=============================================================================
function! GetCmd(type,line)
    let cmd=get(g:applist,a:type)
    if empty(cmd)
        let cmd=get(g:applist,'default')
    endif
    "no %
    if cmd[0] != '!' &amp;&amp; cmd[0] != ':'
        let cmd='!nohup '.cmd.' '.Trans(a:line).' &gt;/dev/null 2&gt;&amp;1 &amp;'
    else
        let cmd=substitute(cmd,'%',Trans(Trans(a:line)),'g')
    endif

    "let cmd=substitute(cmd,'%&lt;',a:line,'g')
    return cmd
endfunction

function! OpenFileWithDefApp()
    let cmd=''
    let origin_line = Trim(Trim(getline("."),'\\'), ' ')

    let idx = stridx(origin_line,':')
    echo idx
    if idx &gt; -1
        let line = strpart(origin_line, 0, idx)
        let linenum = strpart(origin_line, idx)
    else
        let line = origin_line
    endif

    if !filereadable(line)
        "Directory
        let cmd=GetCmd('pwd',line)
    else
        let idx=strridx(line,".")
        "has no ext
        if idx==-1
            let cmd=GetCmd('default',line)
        else
            let fileExt = tolower(matchstr(line,'\.\w\+'))
            let fileExt=tolower(strpart(fileExt,1))
            for [exts,app] in items(g:applist)
                let supportExt=split(exts,',')
                if index(supportExt,fileExt)&gt;=0
                    let cmd=GetCmd(exts,line)
                endif
            endfor
        endif
    endif

    if empty(cmd)
        let cmd=GetCmd('default',line)
    endif
    execute cmd
    if exists('linenum')
        execute linenum
        execute ':call Vm_toggle_sign()'
        "execute ':set cursorline'
        "normal V
    endif
endf

function! DelFile ()
    let line=getline(".")
    if !filereadable(line)
        "echo "!rm -ri ".Trans(getline("."))
        :execute "!rm -ri ".Trans(getline("."))
    else
        "echo "!rm -i ".Trans(getline("."))
        :execute "!rm -i ".Trans(getline("."))
    endif
    :del
endf

function! CopyFile()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd='!cp -a'.Trans(line).' '.Trans(g:dst_dir)
    else
        let cmd='!cp '.Trans(line).' '.Trans(g:dst_dir)
    endif
    :execute cmd
endf

function! ChDir()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd=':cd '.Trans(line)
    else
        let cmd=':cd '.Trans(DirName(line))
    endif
    :execute cmd
    ":echo cmd
    :sh
endf

function! DirName(line)
    let idx=strridx(a:line,'/')
    return strpart(a:line,0,idx)
endf

function! Trans(line)
    let line=Trim(a:line, ' ')
    let line=substitute(line,"'","\\\\'","g")
    let line=substitute(line,' ','\\ ','g')
    let line=substitute(line,'!','\\!','g')
    let line=substitute(line,'#','\\#','g')
    let line=substitute(line,'&amp;','\\&amp;','g')
    let line=substitute(line,'(','\\(','g')
    let line=substitute(line,')','\\)','g')
    return line
    "return "'".line."'"
    "return "'".substitute(a:line,"'","'\\\\''","g")."'"
endf
</code></pre>

<p>  原理还是很简单的，分析当前行，得到文件路径，根据类型找到关联命令，然后替换关联命令得到最后的shell命令并执行。就是一堆转义比较罗嗦，在vimrc里面定义关联程序信息：</p>

<pre><code>" plugin- deal with filelist
nnoremap &lt;leader&gt;co :call OpenFileWithDefApp()&lt;cr&gt;
nnoremap &lt;leader&gt;rm :call DelFile()&lt;cr&gt;
nnoremap &lt;leader&gt;cd :call ChDir()&lt;cr&gt;
nnoremap &lt;leader&gt;to :call CopyFile()&lt;cr&gt;
let g:dst_dir="/media/cxh/MY MP3/"
let g:applist={
            \'pdf':'evince',
            \'png,gif,jpg':'eog',
            \'rmvb,mkv,flv,avi,mp4,m4v':'mplayer',
            \'rar':'!unrar l %',
            \'epub':'!calibre %',
            \'zip':'!unzip -O CP936 -l %',
            \'pwd':'nautilus',
            \'docx,xlsx,pptx,ppt':'libreoffice',
            \'default':':e %'
            \}
</code></pre>

<p>  需要特别说明的是：</p>

<ol>
<li> 几个函数的作用分别是调用执行程序打开当前文件，删除，到当前文件所在路径下，和copy当前文件到制定的dst_dir（这个我主要用在替代windows下的发动到移动存储介质用了）</li>
<li> applist是类型-程序关联数组，说明一下，%会被替换成当前行所指定的文件路径。如果applist里面的命令既不是!开头（shell执行）也不是:开头（vim内部命令），就会被转换成类似于：!nohup mplayer /media/xx.rmvb >/dev/null 2>&amp;1 &amp;的命令，相当于windows的调用默认程序打开。</li>
<li> 支持这种形式的行号调用 xxx.cpp:123 默认用:e 打开之后会定位到对应行，然后标红，标红使用三种方式：<strong>visualmark</strong>, <strong>cursorline</strong>和<strong>normal V</strong>，第一种需要<a href="http://www.vim.org/scripts/script.php?script_id=1026" title="Visual Mark : Visual mark, similar to UltraEdit's bookmark">安装插件</a></li>
</ol>


<p>  钦此。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Visual Mark : Visual mark, similar to UltraEdit&rsquo;s bookmark, <a href="http://www.vim.org/scripts/script.php?script_id=1026">http://www.vim.org/scripts/script.php?script_id=1026</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress的一些技巧]]></title>
    <link href="http://cxh.me/2013/09/14/tricks-about-octopress/"/>
    <updated>2013-09-14T15:03:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/tricks-about-octopress</id>
    <content type="html"><![CDATA[<p>自从把wordpress换成Octopress, 腰不酸了背不疼了, 写博客也有劲了~</p>

<p>以上只是吐个槽而已, Octopress是基于Jekyll的博客系统, Jekyll是从markdown生成静态网页的网页生成器. 这是背景. 详细的不表.</p>

<p>主要说下面几个小技巧:</p>

<!-- more -->


<h3>1. alias(别名)</h3>

<p>话说每次写博客的时候要敲rake new_post/ rake generate/ rake preview/ rake deploy&hellip;等等, 中间再出一点什么git同步的错误, 严重影响写博客的心情.可以通过alias简化命令:</p>

<pre><code>alias rg='rake generate &amp;&amp; rake preview'
alias rd='rake deploy &amp;&amp; git add . &amp;&amp; git commit "`date`" &amp;&amp; git push origin source'
alias rn='rake new_post'
</code></pre>

<h3>2. 插入图片</h3>

<p>octopress的一大优点是插图片方便, 拷贝到source/images目录下, 然后在markdown里插入就行了, 但是不是很智能啊&hellip;其实如果大家在vim里装了nerdtree的话, 完全可以通过nerdtree找到图片, 然后拷贝图片链接. 问题是nerd_tree不支持这个操作&hellip;</p>

<p><img src="/images/2013-9/are-you-fucking-kidding-me.jpg" title="你特么在逗我?" alt="" /></p>

<p>不过我们可以 <a href="http://stackoverflow.com/questions/16368771/copy-path-file-with-nerdtree-vim-plugin" title="Copy path file with NERDtree Vim plugin">扩展一下nerd_tree</a>. 在$VIM/nerdtree_plugin下建立yank_mapping.vim, 内容如下</p>

<pre><code>call NERDTreeAddKeyMap({
        \ 'key': 'yy',
        \ 'callback': 'NERDTreeYankCurrentNode',
        \ 'quickhelpText': 'put full path of current node into the default register' })
function! NERDTreeYankCurrentNode()
    let n = g:NERDTreeFileNode.GetSelected()
    if n != {}
        call setreg('"', n.path.str())
    endif
endfunction
</code></pre>

<p>这样找到文件之后就可以yy了~~~    yy&hellip;yy&hellip;</p>

<h3>3. 生成文件直接打开</h3>

<p>我们执行rake new_post之后, 填好title之后会在_post下生成一个markdown文件(先不讨论title翻译slug的蛋疼之处), 每次那么长的文件命不能让我每次都敲进去或者复制进去吧. 我们可以修改Rakefile在task:new_post最后加一句自动打开生成的文件:</p>

<pre><code>system "vi #{filename}"
</code></pre>

<h3>4. 加快生成速度</h3>

<p>Jekyll每次都会生成所有的_posts, 这会导致生成速度的极度下降, 而且官方也没有给出什么解决方案啊. Octopress实现一个比较笨的办法, Rake Isolate和 Rake Integrate, 从名字就可以看出, 是把需要生成的文件保留, 其他的都移出去, 生成完毕之后再移动回来. 不管怎么说吧, 至少是个方案. 写了一段简单的vimscript实现这个功能跟vim的集成.</p>

<pre><code>"plugin -ocotpress  写octopress博客的插件
function! RakePreview()
  silent! execute "!rake isolate['".expand("%&lt;")."']"
  silent! execute "!rake generate"
  silent! execute "!rake integrate"
  silent! execute "!google-chrome http://localhost:4000"
  silent! execute "!rake preview"
endf

nmap &lt;leader&gt;rp :call RakePreview()&lt;cr&gt;
</code></pre>

<p>chrome打开的时候还没有执行preview, 所以需要再刷新一下&hellip;preview有些输出, 觉得不想看的可以重定向.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用vimdiff来显示gitdiff]]></title>
    <link href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/"/>
    <updated>2013-09-14T11:40:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff</id>
    <content type="html"><![CDATA[<p>git diff默认是调用linux的diff工具的, 一眼看上去毕竟还是不知所云, 不像其他两栏的diff工具那么直观. 我们可以考虑用vimdiff来显示gitdiff的结果.</p>

<p>具体说来有两种办法:</p>

<!-- more -->


<p>在~/.gitconfig中我们可以通过如下语句添加一个配置项, 指明使用的diff工具.</p>

<p>git config &mdash;global diff.tool vimdiff<br/>
git config &mdash;global difftool.prompt No</p>

<p>这里需要注意的是我们需要通过git difftool来调用vimdiff, 默认的gitdiff依然是调用Linux diff工具的.</p>

<p>第二行[difftool].prompt 的作用是免除gitdiff时的提示, 否则会有如下的结果:</p>

<p><img src="/images/2013-9/difftool-prompt.png" title="git diff prompt" alt="" /></p>

<p>当然我们也可以替换掉默认的diff工具, 可以指定</p>

<pre><code>git config --global diff.external git_diff_wrapper
</code></pre>

<p>然后在PATH的某个目录下建立git_diff_wrapper, 比如/usr/bin/git_diff_wrapper, 内容如下:</p>

<pre><code>#!/bin/sh
vimdiff "$2" "$5"
</code></pre>

<p>最后加执行权限</p>

<pre><code>chmod +x git_diff_wrapper
</code></pre>

<p>执行git diff的时候就可以看到效果</p>

<p><img src="/images/2013-9/git-vimdiff.png" title="vim diff 效果" alt="" /></p>

<p>可以看出git其实就是调用了一个外部命令然后把参数传入(分别是当前修改的文件和从版本库获取的文件, 这个文件会在tmp下生成).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim轻量级缓冲区管理插件Buf_it修订版Buf_itv2]]></title>
    <link href="http://cxh.me/2012/06/28/light-vim-buffer-management-plugin-bufit-v2/"/>
    <updated>2012-06-28T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/06/28/light-vim-buffer-management-plugin-bufit-v2</id>
    <content type="html"><![CDATA[<h1></h1>

<p>之前发布了Vim的缓冲区管理插件Buf_it的一个修正版，但是后来发现在windows下命令行使用的时候有问题，同时与Nertree和Taglist等插件也有冲突。于是继续fix了几个bug，然后解决了这部分冲突，新的代码放在我的<a href="https://github.com/BitRobt" title="Bitrobt">github</a>上，或者也可以这里下载，有问题可以继续留言，谢谢。</p>

<p>效果如下：</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="效果图" alt="效果图" /></p>

<h3>安装：</h3>

<blockquote><p>扔进plugin目录就行</p></blockquote>

<h3>配置</h3>

<pre><code>nnoremap wq :w:call BufClose(0)
nnoremap q :call BufClose(0)
nnoremap w :w
nnoremap x :call BufClose(1)
</code></pre>

<h3>使用</h3>

<blockquote><p>shift h,l ：左右切换tab</p>

<p>\be ：BufEcho 显示当前缓冲区名字</p>

<p>\bo ：只保留当前缓冲区，其他的都关掉</p>

<p>alt i : 切换到序号为i的缓冲区</p>

<p>\wq: 保存关闭当前缓冲区并退出</p>

<p>\q: 关闭当前缓冲区并退出</p>

<p>\w: 保存当前缓冲区</p>

<p>\x: 不保存关闭当前缓冲区</p></blockquote>

<h3>参考文献：</h3>

<blockquote><p><a href="https://github.com/BitRobt" title="Bitrobt">1</a> buf_it : Buffer list in statusline,</p>

<p><a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="效果图">2</a> 在windows下给你的右键菜单添加”edit with vim”的方法,</p></blockquote>
]]></content>
  </entry>
  
</feed>
