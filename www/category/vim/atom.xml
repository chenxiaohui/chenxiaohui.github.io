<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | CXH.ME]]></title>
  <link href="http://cxh.me/category/vim/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-03-03T20:27:44+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自动生成ifdef标记和作者信息的插件]]></title>
    <link href="http://cxh.me/2014/10/11/ifdef-generator/"/>
    <updated>2014-10-11T14:28:00+08:00</updated>
    <id>http://cxh.me/2014/10/11/ifdef-generator</id>
    <content type="html"><![CDATA[<p>  针对团队开发为了统一代码风格往往有比较严格的代码规范。为了自动化的生成一些不变的内容，写了如下两个插件（有的是改动）：</p>

<blockquote><ol>
<li>ifdef.vim 生成ifndef标记，防止重复包含。</li>
<li>author_info.vim 生成更新作者信息版权声明</li>
</ol>
</blockquote>

<p>  详见<a href="https://github.com/chenxiaohui/ifdef_generator">https://github.com/chenxiaohui/ifdef_generator</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review插件]]></title>
    <link href="http://cxh.me/2014/06/21/ppost-review-plugin/"/>
    <updated>2014-06-21T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/ppost-review-plugin</id>
    <content type="html"><![CDATA[<h3>post-review.vim</h3>

<p>A plugin to generate post-review script</p>

<h3>Usage</h3>

<h4>install:</h4>

<pre><code>git clone https://github.com/chenxiaohui/post-review.vim 
</code></pre>

<p>put post-review.vim to your $VIM/plugin</p>

<p>add this to your vimrc</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>process:</h4>

<p>svndiff use vimdiff: see <a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">link</a></p>

<p>gitdiff use vimdiff: see <a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">link</a></p>

<p><img src="/images/2013/git-vimdiff.png"></p>

<!--more-->


<p>first use svn diff/git diff and open vimdiff to see the difference</p>

<p>secondly when you consider the changed file needs to be posted , use <leader>pr to add it to post-review.sh</p>

<p>if you has no post-review.sh on your base_dir( specified by the g:base_dir_mark), you need to input the review id or just enter for a new review.</p>

<p>after you added all files you need to review, chmod +x post-review.sh and execute it.</p>

<p>(if you set g:chmod_after_create to 1 you will not need to chmod +x)</p>

<hr />

<p>  请无视楼主以上装逼的英文:</p>

<h3>post-review.vim</h3>

<p>  就是一个用来从vimdiff记录需要Post-review的文件的插件</p>

<p>  不知道Post-review的同学请google之, 用百度搜索的同学自觉面壁去</p>

<h3>用法</h3>

<h4>安装</h4>

<p>  统共分三步:</p>

<p>1.下载解压(或者git clone) url:<a href="https://github.com/chenxiaohui/post-review.vim">https://github.com/chenxiaohui/post-review.vim</a>
2.放到$VIM/plugin目录下(原谅我不写doc的习惯)
3.在vimrc中添加</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>使用</h4>

<p>  比如说Jack正欢快的写着代码呢，然后Jack要提交, 猛然发现好多修改啊</p>

<p><img src="/images/common/ask.jpg"></p>

<blockquote><p>难道不应该写一部分就post-review的嘛</p></blockquote>

<p>  好了不要care这种细节, 然后Jack需要一个一个查看修改的文件, 确定是放到哪个Post-review中提交</p>

<p><img src="/images/common/ask.jpg"></p>

<pre><code>What a fucking job!!!
</code></pre>

<p>  这时候你需要的就是这一款全自动, 人性化, 帮你生成post-review命令的插件, 只要998, 打进电话你就能拥有它&hellip;</p>

<p><img src="/images/common/ask.jpg"></p>

<blockquote><p>跑题了&hellip;</p></blockquote>

<p>  好了, 我们先svn diff或者git diff一下, 为了保证你看到的是如下界面请参考<a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">这里</a>或者<a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">这里</a>.</p>

<p><img src="http://www.ccvita.com/usr/uploads/2011/svn_diff.png" title="svndiff" alt="" /></p>

<p>  好了, 在你需要提交文件的那个窗口用快捷键<leader>pr, 标记完了所有的文件之后进入你的根目录(根目录是什么, 这个待会再说, 不要care这种细节), 下面是不是有一个post-review.sh了? 没有? 卧槽&hellip;男子汉大丈夫, 我写的插件, 有问题&hellip;.我也不承认&hellip;</p>

<p>  最后, 两个配置项:</p>

<pre><code>let g:base_dir_mark = 'cscope.out'
</code></pre>

<p>  制定了一个根目录标志, 也就是说你需要在你的项目根目录找一个(或者建一个)独一无二的文件(比如.git, cscope.out, tags)之类, 让插件去寻找这个文件, 找到之后就标识这个目录为根目录. 跟ctrlp学的.</p>

<pre><code>let g:chmod_after_create = 0
</code></pre>

<p>  无聊的选项, 建立完post-review之后是不是chmod +x, 无视它.</p>

<p>  发起新的post-review的时候建议把post-review.sh清空或者删除, 重复添加同一个文件的时候会判断.</p>

<p>  好了, 也就想到这么多了, 有其他的再补充, 钦此.</p>

<p>注：其实最后我发现还是这样更容易：</p>

<pre><code>alias st='svn st'
alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias po="echo 'post-review -d' &gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; stm &gt;&gt; post-review.sh ; chmod +x post-review.sh ;sed -i 's/^[MA]\s\+//g' post-review.sh;sed -i 's/$/ \\\\/g' post-review.sh;vi post-review.sh"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim7.4 && vimgdb编译]]></title>
    <link href="http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile/"/>
    <updated>2014-06-09T10:52:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile</id>
    <content type="html"><![CDATA[<p>  首先，你下载的vim7.4代码的一般结构跟常见的工程是不一样的，主要体现在configure不会生成Makefile，make的时候是通过Makefile的配置生成config.h的，也就是说你想的好好的希望如下操作：</p>

<pre><code> ./configure --prefix=$HOME --with-features=huge --enable-multibyte --enable-pythoninterp --enable-cscope --enable-fontset --enable-gdb --enable-largefile \
 --enable-gui=gnome2 \
 --enable-luainterp \
 --enable-tclinterp \
 --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu  #编译配置
 --with-lua-prefix=/usr/local/bin/lua

    make &amp;&amp; make install
</code></pre>

<p>  来编译的话，那么实际配置跟上面configure里面是没有关系的。</p>

<p>  以你需要做的是修改Makefile，打开必要的开关，比如安装目录，lua支持什么的</p>

<pre><code># Uncomment the next line to install Vim in your home directory.
prefix = $(HOME)
# LUA
# Uncomment one of these when you want to include the Lua interface.
# First one is for static linking, second one for dynamic loading.
# Use --with-luajit if you want to use LuaJIT instead of Lua.
# Set PATH environment variable to find lua or luajit executable.
CONF_OPT_LUA = --enable-luainterp
#CONF_OPT_LUA = --enable-luainterp=dynamic
#CONF_OPT_LUA = --enable-luainterp --with-luajit
#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit
</code></pre>

<p>  其他的操作按如下步骤就行，摘自<a href="https://github.com/larrupingpig/vimgdb-for-vim7.4" title="vimgdb">larrupingpig/vimgdb-for-vim7.4</a>：</p>

<h3>vimgdb install</h3>

<p>  You need:</p>

<p>  vim-7.4.tar.bz2 <a href="http://www.vim.org/sources.php">http://www.vim.org/sources.php</a></p>

<p>  vimgdb-for-vim7.4 (this patch) <a href="https://github.com/larrupingpig/vimgdb-for-vim7.4">https://github.com/larrupingpig/vimgdb-for-vim7.4</a></p>

<p>  Untar all files, apply the patch and make Vim:</p>

<pre><code>tar xjvf vim-7.4.tar.bz2 -C /tmp

tar xzvf vimgdb-for-vim7.4.tar.gz -C /tmp

cd /tmp

patch -p0 &lt; vimgdb-for-vim7.4/vim74.patch

cd vim74/src

make

sudo make install
</code></pre>

<h3>Install vimGdb runtime:</h3>

<p>  Copy the file vimgdb_runtime found in the vimgdb tarball, to your runtime path. To find your runtime path location execute the vim command (this is usually $HOME/.vim): :set runtimepath?</p>

<pre><code>cp -rf /tmp/vimgdb-for-vim7.4/vimgdb_runtime/* ~/.vim
</code></pre>

<p>  Change to the doc directory, start Vim and run the &ldquo;:helptags .&rdquo; command to process the taglist help file. Without this step, you cannot jump to the taglist help topics. You can now use the &ldquo;:help vimgdb&rdquo; command to get the vimGdb documentation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己写的一个根据路径打开文件的插件]]></title>
    <link href="http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list/"/>
    <updated>2013-11-08T21:26:00+08:00</updated>
    <id>http://cxh.me/2013/11/08/a-vim-plugin-to-deal-with-file-list</id>
    <content type="html"><![CDATA[<p>  这个其实修改了很多次，最初的目的是在linux下嘛，找电影不方便，只能用locate打印出一个电影列表来，但是每次复制路径到命令行多不方便啊，最好能在vim里面操作，于是想想干脆做成通用的好了，就有了这个filelist.vim</p>

<!-- more -->


<pre><code>"=============================================================================
"     FileName: filelist.vim
"         Desc:
"       Author: ChenXiaohui
"        Email: sdqxcxh@gmail.com
"     HomePage: http://www.cxh.me
"      Version: 0.0.1
"   LastChange: 2013-11-06 20:31:23
"      History:
"=============================================================================
function! GetCmd(type,line)
    let cmd=get(g:applist,a:type)
    if empty(cmd)
        let cmd=get(g:applist,'default')
    endif
    "no %
    if cmd[0] != '!' &amp;&amp; cmd[0] != ':'
        let cmd='!nohup '.cmd.' '.Trans(a:line).' &gt;/dev/null 2&gt;&amp;1 &amp;'
    else
        let cmd=substitute(cmd,'%',Trans(Trans(a:line)),'g')
    endif

    "let cmd=substitute(cmd,'%&lt;',a:line,'g')
    return cmd
endfunction

function! OpenFileWithDefApp()
    let cmd=''
    let origin_line = Trim(Trim(getline("."),'\\'), ' ')

    let idx = stridx(origin_line,':')
    echo idx
    if idx &gt; -1
        let line = strpart(origin_line, 0, idx)
        let linenum = strpart(origin_line, idx)
    else
        let line = origin_line
    endif

    if !filereadable(line)
        "Directory
        let cmd=GetCmd('pwd',line)
    else
        let idx=strridx(line,".")
        "has no ext
        if idx==-1
            let cmd=GetCmd('default',line)
        else
            let fileExt = tolower(matchstr(line,'\.\w\+'))
            let fileExt=tolower(strpart(fileExt,1))
            for [exts,app] in items(g:applist)
                let supportExt=split(exts,',')
                if index(supportExt,fileExt)&gt;=0
                    let cmd=GetCmd(exts,line)
                endif
            endfor
        endif
    endif

    if empty(cmd)
        let cmd=GetCmd('default',line)
    endif
    execute cmd
    if exists('linenum')
        execute linenum
        execute ':call Vm_toggle_sign()'
        "execute ':set cursorline'
        "normal V
    endif
endf

function! DelFile ()
    let line=getline(".")
    if !filereadable(line)
        "echo "!rm -ri ".Trans(getline("."))
        :execute "!rm -ri ".Trans(getline("."))
    else
        "echo "!rm -i ".Trans(getline("."))
        :execute "!rm -i ".Trans(getline("."))
    endif
    :del
endf

function! CopyFile()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd='!cp -a'.Trans(line).' '.Trans(g:dst_dir)
    else
        let cmd='!cp '.Trans(line).' '.Trans(g:dst_dir)
    endif
    :execute cmd
endf

function! ChDir()
    let cmd=''
    let line=getline(".")

    if !filereadable(line)
        "Directory
        let cmd=':cd '.Trans(line)
    else
        let cmd=':cd '.Trans(DirName(line))
    endif
    :execute cmd
    ":echo cmd
    :sh
endf

function! DirName(line)
    let idx=strridx(a:line,'/')
    return strpart(a:line,0,idx)
endf

function! Trans(line)
    let line=Trim(a:line, ' ')
    let line=substitute(line,"'","\\\\'","g")
    let line=substitute(line,' ','\\ ','g')
    let line=substitute(line,'!','\\!','g')
    let line=substitute(line,'#','\\#','g')
    let line=substitute(line,'&amp;','\\&amp;','g')
    let line=substitute(line,'(','\\(','g')
    let line=substitute(line,')','\\)','g')
    return line
    "return "'".line."'"
    "return "'".substitute(a:line,"'","'\\\\''","g")."'"
endf
</code></pre>

<p>  原理还是很简单的，分析当前行，得到文件路径，根据类型找到关联命令，然后替换关联命令得到最后的shell命令并执行。就是一堆转义比较罗嗦，在vimrc里面定义关联程序信息：</p>

<pre><code>" plugin- deal with filelist
nnoremap &lt;leader&gt;co :call OpenFileWithDefApp()&lt;cr&gt;
nnoremap &lt;leader&gt;rm :call DelFile()&lt;cr&gt;
nnoremap &lt;leader&gt;cd :call ChDir()&lt;cr&gt;
nnoremap &lt;leader&gt;to :call CopyFile()&lt;cr&gt;
let g:dst_dir="/media/cxh/MY MP3/"
let g:applist={
            \'pdf':'evince',
            \'png,gif,jpg':'eog',
            \'rmvb,mkv,flv,avi,mp4,m4v':'mplayer',
            \'rar':'!unrar l %',
            \'epub':'!calibre %',
            \'zip':'!unzip -O CP936 -l %',
            \'pwd':'nautilus',
            \'docx,xlsx,pptx,ppt':'libreoffice',
            \'default':':e %'
            \}
</code></pre>

<p>  需要特别说明的是：</p>

<ol>
<li> 几个函数的作用分别是调用执行程序打开当前文件，删除，到当前文件所在路径下，和copy当前文件到制定的dst_dir（这个我主要用在替代windows下的发动到移动存储介质用了）</li>
<li> applist是类型-程序关联数组，说明一下，%会被替换成当前行所指定的文件路径。如果applist里面的命令既不是!开头（shell执行）也不是:开头（vim内部命令），就会被转换成类似于：!nohup mplayer /media/xx.rmvb >/dev/null 2>&amp;1 &amp;的命令，相当于windows的调用默认程序打开。</li>
<li> 支持这种形式的行号调用 xxx.cpp:123 默认用:e 打开之后会定位到对应行，然后标红，标红使用三种方式：<strong>visualmark</strong>, <strong>cursorline</strong>和<strong>normal V</strong>，第一种需要<a href="http://www.vim.org/scripts/script.php?script_id=1026" title="Visual Mark : Visual mark, similar to UltraEdit's bookmark">安装插件</a></li>
</ol>


<p>  钦此。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Visual Mark : Visual mark, similar to UltraEdit&rsquo;s bookmark, <a href="http://www.vim.org/scripts/script.php?script_id=1026">http://www.vim.org/scripts/script.php?script_id=1026</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress的一些技巧]]></title>
    <link href="http://cxh.me/2013/09/14/tricks-about-octopress/"/>
    <updated>2013-09-14T15:03:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/tricks-about-octopress</id>
    <content type="html"><![CDATA[<p>  自从把wordpress换成Octopress, 腰不酸了背不疼了, 写博客也有劲了~</p>

<p>  以上只是吐个槽而已, Octopress是基于Jekyll的博客系统, Jekyll是从markdown生成静态网页的网页生成器. 这是背景. 详细的不表.</p>

<p>  主要说下面几个小技巧:</p>

<p>  <!-- more --></p>

<h3>1. alias(别名)</h3>

<p>  话说每次写博客的时候要敲rake new_post/ rake generate/ rake preview/ rake deploy&hellip;等等, 中间再出一点什么git同步的错误, 严重影响写博客的心情.可以通过alias简化命令:</p>

<pre><code>  alias rg='rake generate &amp;&amp; rake preview'
  alias rd='rake deploy &amp;&amp; git add . &amp;&amp; git commit "`date`" &amp;&amp; git push origin source'
  alias rn='rake new_post'
</code></pre>

<h3>2. 插入图片</h3>

<p>  octopress的一大优点是插图片方便, 拷贝到source/images目录下, 然后在markdown里插入就行了, 但是不是很智能啊&hellip;其实如果大家在vim里装了nerdtree的话, 完全可以通过nerdtree找到图片, 然后拷贝图片链接. 问题是nerd_tree不支持这个操作&hellip;</p>

<p><img src="/images/2013/are-you-fucking-kidding-me.jpg" title="你特么在逗我?" alt="" /></p>

<p>  不过我们可以 <a href="http://stackoverflow.com/questions/16368771/copy-path-file-with-nerdtree-vim-plugin" title="Copy path file with NERDtree Vim plugin">扩展一下nerd_tree</a>. 在$VIM/nerdtree_plugin下建立yank_mapping.vim, 内容如下</p>

<pre><code>call NERDTreeAddKeyMap({
        \ 'key': 'yy',
        \ 'callback': 'NERDTreeYankCurrentNode',
        \ 'quickhelpText': 'put full path of current node into the default register' })
function! NERDTreeYankCurrentNode()
    let n = g:NERDTreeFileNode.GetSelected()
    if n != {}
        call setreg('"', n.path.str())
    endif
endfunction
</code></pre>

<p>  这样找到文件之后就可以yy了~~~    yy&hellip;yy&hellip;</p>

<h3>3. 生成文件直接打开</h3>

<p>  我们执行rake new_post之后, 填好title之后会在_post下生成一个markdown文件(先不讨论title翻译slug的蛋疼之处), 每次那么长的文件命不能让我每次都敲进去或者复制进去吧. 我们可以修改Rakefile在task:new_post最后加一句自动打开生成的文件:</p>

<pre><code>system "vi #{filename}"
</code></pre>

<h3>4. 加快生成速度</h3>

<p>  Jekyll每次都会生成所有的_posts, 这会导致生成速度的极度下降, 而且官方也没有给出什么解决方案啊. Octopress实现一个比较笨的办法, Rake Isolate和 Rake Integrate, 从名字就可以看出, 是把需要生成的文件保留, 其他的都移出去, 生成完毕之后再移动回来. 不管怎么说吧, 至少是个方案. 写了一段简单的vimscript实现这个功能跟vim的集成.</p>

<pre><code>"plugin -ocotpress  写octopress博客的插件
function! RakePreview()
  silent! execute "!rake isolate['".expand("%&lt;")."']"
  silent! execute "!rake generate"
  silent! execute "!rake integrate"
  silent! execute "!google-chrome http://localhost:4000"
  silent! execute "!rake preview"
endf

nmap &lt;leader&gt;rp :call RakePreview()&lt;cr&gt;
</code></pre>

<p>  chrome打开的时候还没有执行preview, 所以需要再刷新一下&hellip;preview有些输出, 觉得不想看的可以重定向.</p>
]]></content>
  </entry>
  
</feed>
