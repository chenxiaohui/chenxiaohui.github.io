<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | CXH.ME]]></title>
  <link href="http://cxh.me/category/vim/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-11-06T21:29:10+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Octopress的一些技巧]]></title>
    <link href="http://cxh.me/2013/09/14/tricks-about-octopress/"/>
    <updated>2013-09-14T15:03:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/tricks-about-octopress</id>
    <content type="html"><![CDATA[<p>自从把wordpress换成Octopress, 腰不酸了背不疼了, 写博客也有劲了~</p>

<p>以上只是吐个槽而已, Octopress是基于Jekyll的博客系统, Jekyll是从markdown生成静态网页的网页生成器. 这是背景. 详细的不表.</p>

<p>主要说下面几个小技巧:</p>

<!-- more -->


<h3>1. alias(别名)</h3>

<p>话说每次写博客的时候要敲rake new_post/ rake generate/ rake preview/ rake deploy&hellip;等等, 中间再出一点什么git同步的错误, 严重影响写博客的心情.可以通过alias简化命令:</p>

<pre><code>alias rg='rake generate &amp;&amp; rake preview'
alias rd='rake deploy &amp;&amp; git add . &amp;&amp; git commit "`date`" &amp;&amp; git push origin source'
alias rn='rake new_post'
</code></pre>

<h3>2. 插入图片</h3>

<p>octopress的一大优点是插图片方便, 拷贝到source/images目录下, 然后在markdown里插入就行了, 但是不是很智能啊&hellip;其实如果大家在vim里装了nerdtree的话, 完全可以通过nerdtree找到图片, 然后拷贝图片链接. 问题是nerd_tree不支持这个操作&hellip;</p>

<p><img src="/images/2013-9/are-you-fucking-kidding-me.jpg" title="你特么在逗我?" alt="" /></p>

<p>不过我们可以 <a href="http://stackoverflow.com/questions/16368771/copy-path-file-with-nerdtree-vim-plugin" title="Copy path file with NERDtree Vim plugin">扩展一下nerd_tree</a>. 在$VIM/nerdtree_plugin下建立yank_mapping.vim, 内容如下</p>

<pre><code>call NERDTreeAddKeyMap({
        \ 'key': 'yy',
        \ 'callback': 'NERDTreeYankCurrentNode',
        \ 'quickhelpText': 'put full path of current node into the default register' })
function! NERDTreeYankCurrentNode()
    let n = g:NERDTreeFileNode.GetSelected()
    if n != {}
        call setreg('"', n.path.str())
    endif
endfunction
</code></pre>

<p>这样找到文件之后就可以yy了~~~    yy&hellip;yy&hellip;</p>

<h3>3. 生成文件直接打开</h3>

<p>我们执行rake new_post之后, 填好title之后会在_post下生成一个markdown文件(先不讨论title翻译slug的蛋疼之处), 每次那么长的文件命不能让我每次都敲进去或者复制进去吧. 我们可以修改Rakefile在task:new_post最后加一句自动打开生成的文件:</p>

<pre><code>system "vi #{filename}"
</code></pre>

<h3>4. 加快生成速度</h3>

<p>Jekyll每次都会生成所有的_posts, 这会导致生成速度的极度下降, 而且官方也没有给出什么解决方案啊. Octopress实现一个比较笨的办法, Rake Isolate和 Rake Integrate, 从名字就可以看出, 是把需要生成的文件保留, 其他的都移出去, 生成完毕之后再移动回来. 不管怎么说吧, 至少是个方案. 写了一段简单的vimscript实现这个功能跟vim的集成.</p>

<pre><code>"plugin -ocotpress  写octopress博客的插件
function! RakePreview()
  silent! execute "!rake isolate['".expand("%&lt;")."']"
  silent! execute "!rake generate"
  silent! execute "!rake integrate"
  silent! execute "!google-chrome http://localhost:4000"
  silent! execute "!rake preview"
endf

nmap &lt;leader&gt;rp :call RakePreview()&lt;cr&gt;
</code></pre>

<p>chrome打开的时候还没有执行preview, 所以需要再刷新一下&hellip;preview有些输出, 觉得不想看的可以重定向.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用vimdiff来显示gitdiff]]></title>
    <link href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/"/>
    <updated>2013-09-14T11:40:00+08:00</updated>
    <id>http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff</id>
    <content type="html"><![CDATA[<p>git diff默认是调用linux的diff工具的, 一眼看上去毕竟还是不知所云, 不像其他两栏的diff工具那么直观. 我们可以考虑用vimdiff来显示gitdiff的结果.</p>

<p>具体说来有两种办法:</p>

<!-- more -->


<p>在~/.gitconfig中我们可以通过如下语句添加一个配置项, 指明使用的diff工具.</p>

<p>git config &mdash;global diff.tool vimdiff<br/>
git config &mdash;global difftool.prompt No</p>

<p>这里需要注意的是我们需要通过git difftool来调用vimdiff, 默认的gitdiff依然是调用Linux diff工具的.</p>

<p>第二行[difftool].prompt 的作用是免除gitdiff时的提示, 否则会有如下的结果:</p>

<p><img src="/images/2013-9/difftool-prompt.png" title="git diff prompt" alt="" /></p>

<p>当然我们也可以替换掉默认的diff工具, 可以指定</p>

<pre><code>git config --global diff.external git_diff_wrapper
</code></pre>

<p>然后在PATH的某个目录下建立git_diff_wrapper, 比如/usr/bin/git_diff_wrapper, 内容如下:</p>

<pre><code>#!/bin/sh
vimdiff "$2" "$5"
</code></pre>

<p>最后加执行权限</p>

<pre><code>chmod +x git_diff_wrapper
</code></pre>

<p>执行git diff的时候就可以看到效果</p>

<p><img src="/images/2013-9/git-vimdiff.png" title="vim diff 效果" alt="" /></p>

<p>可以看出git其实就是调用了一个外部命令然后把参数传入(分别是当前修改的文件和从版本库获取的文件, 这个文件会在tmp下生成).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim轻量级缓冲区管理插件Buf_it修订版Buf_itv2]]></title>
    <link href="http://cxh.me/2012/06/28/light-vim-buffer-management-plugin-bufit-v2/"/>
    <updated>2012-06-28T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/06/28/light-vim-buffer-management-plugin-bufit-v2</id>
    <content type="html"><![CDATA[<h1></h1>

<p>之前发布了Vim的缓冲区管理插件Buf_it的一个修正版，但是后来发现在windows下命令行使用的时候有问题，同时与Nertree和Taglist等插件也有冲突。于是继续fix了几个bug，然后解决了这部分冲突，新的代码放在我的<a href="https://github.com/BitRobt" title="Bitrobt">github</a>上，或者也可以这里下载，有问题可以继续留言，谢谢。</p>

<p>效果如下：</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="效果图" alt="效果图" /></p>

<h2>安装：</h2>

<blockquote><p>扔进plugin目录就行</p></blockquote>

<h2>配置</h2>

<pre><code>nnoremap wq :w:call BufClose(0)
nnoremap q :call BufClose(0)
nnoremap w :w
nnoremap x :call BufClose(1)
</code></pre>

<h2>使用</h2>

<blockquote><p>shift h,l ：左右切换tab</p>

<p>\be ：BufEcho 显示当前缓冲区名字</p>

<p>\bo ：只保留当前缓冲区，其他的都关掉</p>

<p>alt i : 切换到序号为i的缓冲区</p>

<p>\wq: 保存关闭当前缓冲区并退出</p>

<p>\q: 关闭当前缓冲区并退出</p>

<p>\w: 保存当前缓冲区</p>

<p>\x: 不保存关闭当前缓冲区</p></blockquote>

<h2>参考文献：</h2>

<blockquote><p><a href="https://github.com/BitRobt" title="Bitrobt">1</a> buf_it : Buffer list in statusline,</p>

<p><a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="效果图">2</a> 在windows下给你的右键菜单添加”edit with vim”的方法,</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布VIM缓冲区切换插件buf_it升级版]]></title>
    <link href="http://cxh.me/2012/03/28/publish-the-vim-buffer-management-plugin/"/>
    <updated>2012-03-28T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/03/28/publish-the-vim-buffer-management-plugin</id>
    <content type="html"><![CDATA[<h1></h1>

<p>VIM默认使用的过程中有一个重要的问题，就是打开多个文件的时候无法可视化看到打开的文件，并在这些文件中切换。MiniBufExplorer是一个常用的buffer切换插件，但是这个插件在Windows下使用的时候有许多问题，同时也太繁琐。buf_it<a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="image">1</a>则实现了轻量的buffer管理，但是buf_it同样在windows下有许多问题，而buf_it的退出机制也会出现只想关闭一个文件确关闭了整个vim的情况。</p>

<p>基于这两个问题，我修改了buf_it插件，这里共享出来，欢迎大家提意见。先给张图</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="image" alt="image" /></p>

<p>修改：</p>

<blockquote><p>1 windows下使用GVIM优化，方式多开一个空白缓冲区，windows下gvim右键配置见参考文献2</p>

<p>2 增加自定义退出方式</p>

<p>3 修改了部分快捷键，只是个人习惯，可无视之</p></blockquote>

<p>安装：</p>

<blockquote><p>直接扔到plugin目录就行，原作者没写doc，那我也不写啦。</p></blockquote>

<p>配置：</p>

<blockquote><p>nnoremap wq :w:call BufClose()
nnoremap q :call BufClose()
nnoremap w :w
nnoremap x :bd!:call BufClose()</p></blockquote>

<p>使用：</p>

<blockquote><p>shift h,l ：左右切换tab</p>

<p>be ：BufEcho 显示当前缓冲区名字</p>

<p>bo ：只保留当前缓冲区，其他的都关掉</p>

<p>alt i : 切换到序号为i的缓冲区</p>

<p>wq: 保存关闭当前缓冲区并退出</p>

<p>q: 关闭当前缓冲区并退出</p>

<p>w: 保存当前缓冲区</p>

<p>x: 不保存关闭当前缓冲区</p></blockquote>

<p>下载:<a href="http://www.roybit.com/wp-content/uploads/2012/03/buf_it.rar">buf_it</a></p>

<p>参考文献：</p>

<blockquote><p><a href="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb4.png" title="image">1</a> buf_it : Buffer list in statusline,</p>

<p><a href="http://www.roybit.com/wp-content/uploads/2012/03/buf_it.rar">2</a> 在windows下给你的右键菜单添加"edit with vim"的方法,</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文件查找利器&mdash;&mdash;FuzzyFinder]]></title>
    <link href="http://cxh.me/2011/09/29/file-find-tool-fuzzy-finder/"/>
    <updated>2011-09-29T00:00:00+08:00</updated>
    <id>http://cxh.me/2011/09/29/file-find-tool-fuzzy-finder</id>
    <content type="html"><![CDATA[<h1></h1>

<p>这个东东太华丽了……相当VisualAssist的查找符号和查找文件，不过功能更强大，支持正则表达式，支持全文检索。</p>

<blockquote><p>下载地址：</p>

<p>需要的支持库：</p>

<p>L9Library</p></blockquote>

<p>另外，由于命令较多，可以配置一下命令提示，如下所示：</p>

<pre><code>"fuzzyfinder
"
" F4和shift F4调用FuzzyFinder命令行菜单"
"
function! GetAllCommands()
  redir =&gt; commands
  silent command
  redir END
  return map((split(commands, "
")[3:]),
      \      '":" . matchstr(v:val, ''^....\zs\S*'')')
endfunction

" 自定义命令行
let g:fuf_com_list=[':FufBuffer',':FufFile',':FufCoverageFile',':FufDir',
            \':FufMruFile',':FufMruCmd',':FufBookmarkFile',
            \':FufBookmarkDir',':FufTag',':FufBufferTag',
            \':FufTaggedFile',':FufJumpList',':FufChangeList',
            \':FufQuickfix',':FufLine',':FufHelp',
            \":FufFile \=expand('%:~:.')[:-1-len(expand('%:~:.:t'))]\",
            \":FufDir \=expand('%:p:~')[:-1-len(expand('%:p:~:t'))]\",
            \]
nnoremap   :call fuf#givencmd#launch('', 0, '选择命令&gt;', GetAllCommands())
nnoremap   :call fuf#givencmd#launch('', 0, '选择命令&gt;', g:fuf_com_list)
</code></pre>
]]></content>
  </entry>
  
</feed>
