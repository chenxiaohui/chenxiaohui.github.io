<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | CXH.ME]]></title>
  <link href="http://cxh.me/category/vim/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-03-06T14:53:52+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[vim编译错误：PyUnicodeUCS4_AsEncodedString]]></title>
    <link href="http://cxh.me/2016/03/06/vim-comple-error-with-pyunicodeucs4-asencodedstring/"/>
    <updated>2016-03-06T14:45:00+08:00</updated>
    <id>http://cxh.me/2016/03/06/vim-comple-error-with-pyunicodeucs4-asencodedstring</id>
    <content type="html"><![CDATA[<p>  换了个ubuntu的环境想编译一下vim，为了防止不兼容手动编译了python2.7，之后把改过的vim源码放上去编译发现有问题：</p>

<pre><code>undefined symbol: PyUnicodeUCS4_AsEncodedString
</code></pre>

<p>  于是换回标准的vim源码还是一样的问题，我擦嘞。上网搜一下说Python模式是UnicodeUCS2的支持，从源码里面直接grep一下这个函数发现是有的：</p>

<pre><code>Include/unicodeobject.h:# define PyUnicode_AsEncodedString PyUnicodeUCS4_AsEncodedString
</code></pre>

<p>  那只可能是没有开启编译选项了，./configure &mdash;help发现有如下一项：</p>

<pre><code>  --enable-unicode[=ucs[24]]
                      Enable Unicode strings (default is ucs2)
</code></pre>

<p>  configure到ucs4重新编译python2.7，完美。没毛病。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim配置符号和跳转]]></title>
    <link href="http://cxh.me/2015/03/28/configure-vim-tags-and-jump/"/>
    <updated>2015-03-28T12:05:00+08:00</updated>
    <id>http://cxh.me/2015/03/28/configure-vim-tags-and-jump</id>
    <content type="html"><![CDATA[<p>  对于一个简单的开发环境，能实现tags的定位跳转，以及查询就够用了。这种情况下，vim + 一些插件完全能够满足要求，尤其对于python这样的脚本语言开发，vim比IDE更简洁。这里我们尝试把vim配置成一个精简的IDE。</p>

<p>  首先升级你的ctags，换成exuberantCtags，后者功能更强大，且对c++等语言的支持更好。</p>

<pre><code>ubuntu下可以直接：
    apt-get install exuberant-ctags
centos下：
    yum install ctags
mac下：
    brew install ctags-exuberant
windows下：
    什么是windows?
</code></pre>

<p>  cscope如果系统没有默认安装的话也装一下。</p>

<p>  之后安装tags插件，相对<a href="http://www.vim.org/scripts/script.php?script_id=273" title="taglist.vim : Source code browser (supports C/C++, java, perl, python, tcl, sql, php, etc) ">taglist.vim</a>其实我们更推荐<a href="http://www.vim.org/scripts/script.php?script_id=3465" title="Tagbar : Display tags of the current file ordered by scope">tagbar.vim</a>，因其对面向对象特性支持的更好。</p>

<!--more-->


<p>  然后配置tagbar，第一部分只是配置了下system标记，效果如图所示:</p>

<pre><code>" system mark
if(has("win32") || has("win95") || has("win64") || has("win16"))
    let g:system='win'
else
    if has("unix")
        let s:uname = system("uname")
        if s:uname == "Darwin\n"
            let g:system='mac'
        else
            let g:system='unix'
        endif
    endif
endif

"{ tagbar - taglist replacement
    nmap &lt;silent&gt;&lt;S-f8&gt; :TagbarToggle&lt;CR&gt;
    if g:system=='win'
        let g:tagbar_ctags_bin = 'ctags.exe'
    else
        let g:tagbar_ctags_bin = 'ctags'
    endif
    let g:tagbar_autoclose = 1
    let g:tagbar_width = 30
    let g:tagbar_autofocus = 1
    let g:tagbar_sort = 0
    let g:tagbar_compact = 1
    let g:tagbar_autofocus = 1
"}
</code></pre>

<p>  <img class="img-polaroid center" src="/images/2015/tagbar.png" title="&ldquo;tagbar界面&rdquo; &ldquo;tagbar界面&rdquo;" ></p>

<p>  现在有了tag显示，我们希望能够自动加载tags，这样打开一个文件的时候就可以直接操作这个文件所在项目的tags了，针对这种情况，需要先定义一个项目的根目录，这就需要用到base_dir_mark（只是一个变量..名字你随便），我们对一个项目生成且只生成一次tags(和cscope.out)，放在这个目录下。我（改进）的插件cscope_maps.vim包含了对base_dir_mark的查找和定义：</p>

<pre><code>if !exists('g:base_dir_mark')
    "set base_dir_mark to indicate where to generate tags
    let g:base_dir_mark = 'tags'
endif

function! GetBaseDirectory()
    let max = 5
    let dir = getcwd()
    let i = 0
    while isdirectory(dir) &amp;&amp; i &lt; max
        if filereadable(dir .'/'. g:base_dir_mark)
            return dir.'/'
        endif
        let idx = strridx(dir, '/')
        let dir = dir[:idx-1]
        let i = i + 1
    endwhile
    return ''
endf

function! AutoLoadCTagsAndCScope()
    silent! execute 'cs kill -1'

    let base_dir=GetBaseDirectory()
    if !empty(base_dir)
        silent! execute 'cs add ' .base_dir . 'cscope.out'
    endif

    let ctags_dir=base_dir
    if !empty(ctags_dir)
        silent! execute 'set tags =' . ctags_dir . 'tags,'.$VIMFILES.'/tags/'.&amp;ft.'/tags'
    else
        silent! execute 'set tags ='.$VIMFILES.'/tags/'.&amp;ft.'/tags'
    endif
endf
</code></pre>

<p>  之后就可以配置让每次打开一个文件的时候都自动去项目根目录下找tags(和cscope.out)，把这个目录作为项目根目录了。</p>

<pre><code>"{ plugin -ctags 对tag的操作
set tags=tags
augroup TagGroup
    autocmd!
    "autocmd BufEnter *.* :exec 'set tags=tags,'.$VIMFILES.'/tags/'.&amp;ft.'/tags'
    autocmd BufEnter * :call AutoLoadCTagsAndCScope()
    "autocmd BufWritePost *.cpp,*.c,*.h :silent! execute "!ctags -R  -c++-kinds=+p --fields=+iaS --extra=+q ."
augroup END
"}
</code></pre>

<p>  注释掉的一行，我们放到shell中实现</p>

<pre><code>alias cr='find `pwd` -name "*.[ch]" -o -name "*.cpp" &gt; cscope.files &amp;&amp; ctags -R `pwd` --languages=c++ --c++-kinds=+px --fields=+iaKSz --extra=+q &amp;&amp; cscope -Rb &amp;&amp; rm -f cscope.files'
</code></pre>

<p>  这样在项目根目录执行一下cr来生成tags和cscope.out，这个操作同时确定了项目的根目录是哪里。至于自动更新tags，意义不是很大，而且开销有点高。</p>

<p>  最后是cscope的插件绑定，插件详见这个<a href="https://github.com/chenxiaohui/vim_cscope" title="vim_cscope - a vim plugin to configure vim_cscope">github repo</a>。配置如下：</p>

<pre><code>"{ plugin - cscopemaps.vim里面定义了键盘映射
let g:base_dir_mark = 'tags'
map &lt;silent&gt;&lt;F7&gt; :call AutoLoadCTagsAndCScope()&lt;CR&gt;
map &lt;silent&gt;&lt;C-F7&gt; :call Do_CsTag()&lt;CR&gt;
"map &lt;F3&gt; &lt;C-]&gt;
map &lt;F3&gt; :execute(":tj ".expand("&lt;cword&gt;"))&lt;cr&gt;
map &lt;m-left&gt; &lt;C-o&gt;
map &lt;m-right&gt; &lt;c-i&gt;

"map &lt;silent&gt;&lt;S-F4&gt;&lt;Esc&gt;:!ctags -R *&lt;CR&gt;
"map &lt;silent&gt;&lt;C-F4&gt;&lt;Esc&gt;:silent! execute "!ctags -R -c++-kinds=+p --fields=+iaS --extra=+q ."&lt;CR&gt;
"查找调用这个定义
"nmap &lt;C-\&gt;g :cs find g &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;
"查找调用这个c符号的地方
nmap &lt;leader&gt;cf :cs find c &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;
nmap &lt;leader&gt;ck :cs find s &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;
nmap &lt;leader&gt;cg :cs find g &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;
nmap &lt;leader&gt;ct :cs find t &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;

"查找调用这个函数的地方
"nmap &lt;C-\&gt;c :cs find c &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;
"}
</code></pre>

<p>  这样就实现了在tag的跳转和查找。 Do_CsTag函数实现的功能跟shell alias基本一样。没有安装neocomplcache的可以map &lt;m-left> &lt;C-t>。效果如下所示：</p>

<p>  <img class="img-polaroid center" src="/images/2015/tags.png" title="&ldquo;自动load tags&rdquo; &ldquo;自动load tags&rdquo;" >
  <img class="img-polaroid center" src="/images/2015/cscope.png" title="&ldquo;cscope find reference结果&rdquo; &ldquo;cscope find reference结果&rdquo;" ></p>

<h3>Bibliography:</h3>

<p>  [1] Tagbar : Display tags of the current file ordered by scope, <a href="http://www.vim.org/scripts/script.php?script_id=3465">http://www.vim.org/scripts/script.php?script_id=3465</a></p>

<p>  [2] taglist.vim : Source code browser (supports C/C++, java, perl, python, tcl, sql, php, etc) , <a href="http://www.vim.org/scripts/script.php?script_id=273">http://www.vim.org/scripts/script.php?script_id=273</a></p>

<p>  [3] vim_cscope &ndash; a vim plugin to configure vim_cscope, <a href="https://github.com/chenxiaohui/vim_cscope">https://github.com/chenxiaohui/vim_cscope</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动生成ifdef标记和作者信息的插件]]></title>
    <link href="http://cxh.me/2014/10/11/ifdef-generator/"/>
    <updated>2014-10-11T14:28:00+08:00</updated>
    <id>http://cxh.me/2014/10/11/ifdef-generator</id>
    <content type="html"><![CDATA[<p>  针对团队开发为了统一代码风格往往有比较严格的代码规范。为了自动化的生成一些不变的内容，写了如下两个插件（有的是改动）：</p>

<blockquote><ol>
<li>ifdef.vim 生成ifndef标记，防止重复包含。</li>
<li>author_info.vim 生成更新作者信息版权声明</li>
</ol>
</blockquote>

<p>  详见<a href="https://github.com/chenxiaohui/ifdef_generator">https://github.com/chenxiaohui/ifdef_generator</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review插件]]></title>
    <link href="http://cxh.me/2014/06/21/ppost-review-plugin/"/>
    <updated>2014-06-21T20:57:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/ppost-review-plugin</id>
    <content type="html"><![CDATA[<h3>post-review.vim</h3>

<p>A plugin to generate post-review script</p>

<h3>Usage</h3>

<h4>install:</h4>

<pre><code>git clone https://github.com/chenxiaohui/post-review.vim 
</code></pre>

<p>put post-review.vim to your $VIM/plugin</p>

<p>add this to your vimrc</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>process:</h4>

<p>svndiff use vimdiff: see <a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">link</a></p>

<p>gitdiff use vimdiff: see <a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">link</a></p>

<p><img src="/images/2013/git-vimdiff.png"></p>

<!--more-->


<p>first use svn diff/git diff and open vimdiff to see the difference</p>

<p>secondly when you consider the changed file needs to be posted , use <leader>pr to add it to post-review.sh</p>

<p>if you has no post-review.sh on your base_dir( specified by the g:base_dir_mark), you need to input the review id or just enter for a new review.</p>

<p>after you added all files you need to review, chmod +x post-review.sh and execute it.</p>

<p>(if you set g:chmod_after_create to 1 you will not need to chmod +x)</p>

<hr />

<p>  请无视楼主以上装逼的英文:</p>

<h3>post-review.vim</h3>

<p>  就是一个用来从vimdiff记录需要Post-review的文件的插件</p>

<p>  不知道Post-review的同学请google之, 用百度搜索的同学自觉面壁去</p>

<h3>用法</h3>

<h4>安装</h4>

<p>  统共分三步:</p>

<p>1.下载解压(或者git clone) url:<a href="https://github.com/chenxiaohui/post-review.vim">https://github.com/chenxiaohui/post-review.vim</a>
2.放到$VIM/plugin目录下(原谅我不写doc的习惯)
3.在vimrc中添加</p>

<pre><code>nmap &lt;leader&gt;pr :call PostReview()&lt;cr&gt;
</code></pre>

<h4>使用</h4>

<p>  比如说Jack正欢快的写着代码呢，然后Jack要提交, 猛然发现好多修改啊</p>

<p><img src="/images/common/ask.jpg"></p>

<blockquote><p>难道不应该写一部分就post-review的嘛</p></blockquote>

<p>  好了不要care这种细节, 然后Jack需要一个一个查看修改的文件, 确定是放到哪个Post-review中提交</p>

<p><img src="/images/common/ask.jpg"></p>

<pre><code>What a fucking job!!!
</code></pre>

<p>  这时候你需要的就是这一款全自动, 人性化, 帮你生成post-review命令的插件, 只要998, 打进电话你就能拥有它&hellip;</p>

<p><img src="/images/common/ask.jpg"></p>

<blockquote><p>跑题了&hellip;</p></blockquote>

<p>  好了, 我们先svn diff或者git diff一下, 为了保证你看到的是如下界面请参考<a href="http://www.ccvita.com/445.html" title="svndiff use vimdiff">这里</a>或者<a href="http://cxh.me/2013/09/14/show-gitdiff-using-vimdiff/" title="svn diff use vimdiff">这里</a>.</p>

<p><img src="http://www.ccvita.com/usr/uploads/2011/svn_diff.png" title="svndiff" alt="" /></p>

<p>  好了, 在你需要提交文件的那个窗口用快捷键<leader>pr, 标记完了所有的文件之后进入你的根目录(根目录是什么, 这个待会再说, 不要care这种细节), 下面是不是有一个post-review.sh了? 没有? 卧槽&hellip;男子汉大丈夫, 我写的插件, 有问题&hellip;.我也不承认&hellip;</p>

<p>  最后, 两个配置项:</p>

<pre><code>let g:base_dir_mark = 'cscope.out'
</code></pre>

<p>  制定了一个根目录标志, 也就是说你需要在你的项目根目录找一个(或者建一个)独一无二的文件(比如.git, cscope.out, tags)之类, 让插件去寻找这个文件, 找到之后就标识这个目录为根目录. 跟ctrlp学的.</p>

<pre><code>let g:chmod_after_create = 0
</code></pre>

<p>  无聊的选项, 建立完post-review之后是不是chmod +x, 无视它.</p>

<p>  发起新的post-review的时候建议把post-review.sh清空或者删除, 重复添加同一个文件的时候会判断.</p>

<p>  好了, 也就想到这么多了, 有其他的再补充, 钦此.</p>

<p>注：其实最后我发现还是这样更容易：</p>

<pre><code>alias st='svn st'
alias sta='st|grep ^A '
alias stm='st|grep ^M '
alias po="echo 'post-review -d' &gt;post-review.sh  &amp;&amp; sta &gt;&gt; post-review.sh ; stm &gt;&gt; post-review.sh ; chmod +x post-review.sh ;sed -i 's/^[MA]\s\+//g' post-review.sh;sed -i 's/$/ \\\\/g' post-review.sh;vi post-review.sh"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim7.4 && vimgdb编译]]></title>
    <link href="http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile/"/>
    <updated>2014-06-09T10:52:00+08:00</updated>
    <id>http://cxh.me/2014/06/09/vim7-dot-4-and-vimgdb-compile</id>
    <content type="html"><![CDATA[<p>  首先，你下载的vim7.4代码的一般结构跟常见的工程是不一样的，主要体现在configure不会生成Makefile，make的时候是通过Makefile的配置生成config.h的，也就是说你想的好好的希望如下操作：</p>

<pre><code> ./configure --prefix=$HOME --with-features=huge --enable-multibyte --enable-pythoninterp --enable-cscope --enable-fontset --enable-gdb --enable-largefile \
 --enable-gui=gnome2 \
 --enable-luainterp \
 --enable-tclinterp \
 --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu  #编译配置
 --with-lua-prefix=/usr/local/bin/lua

    make &amp;&amp; make install
</code></pre>

<p>  来编译的话，那么实际配置跟上面configure里面是没有关系的。</p>

<p>  以你需要做的是修改Makefile，打开必要的开关，比如安装目录，lua支持什么的</p>

<pre><code># Uncomment the next line to install Vim in your home directory.
prefix = $(HOME)
# LUA
# Uncomment one of these when you want to include the Lua interface.
# First one is for static linking, second one for dynamic loading.
# Use --with-luajit if you want to use LuaJIT instead of Lua.
# Set PATH environment variable to find lua or luajit executable.
CONF_OPT_LUA = --enable-luainterp
#CONF_OPT_LUA = --enable-luainterp=dynamic
#CONF_OPT_LUA = --enable-luainterp --with-luajit
#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit
</code></pre>

<p>  其他的操作按如下步骤就行，摘自<a href="https://github.com/larrupingpig/vimgdb-for-vim7.4" title="vimgdb">larrupingpig/vimgdb-for-vim7.4</a>：</p>

<h3>vimgdb install</h3>

<p>  You need:</p>

<p>  vim-7.4.tar.bz2 <a href="http://www.vim.org/sources.php">http://www.vim.org/sources.php</a></p>

<p>  vimgdb-for-vim7.4 (this patch) <a href="https://github.com/larrupingpig/vimgdb-for-vim7.4">https://github.com/larrupingpig/vimgdb-for-vim7.4</a></p>

<p>  Untar all files, apply the patch and make Vim:</p>

<pre><code>tar xjvf vim-7.4.tar.bz2 -C /tmp

tar xzvf vimgdb-for-vim7.4.tar.gz -C /tmp

cd /tmp

patch -p0 &lt; vimgdb-for-vim7.4/vim74.patch

cd vim74/src

make

sudo make install
</code></pre>

<h3>Install vimGdb runtime:</h3>

<p>  Copy the file vimgdb_runtime found in the vimgdb tarball, to your runtime path. To find your runtime path location execute the vim command (this is usually $HOME/.vim): :set runtimepath?</p>

<pre><code>cp -rf /tmp/vimgdb-for-vim7.4/vimgdb_runtime/* ~/.vim
</code></pre>

<p>  Change to the doc directory, start Vim and run the &ldquo;:helptags .&rdquo; command to process the taglist help file. Without this step, you cannot jump to the taglist help topics. You can now use the &ldquo;:help vimgdb&rdquo; command to get the vimGdb documentation.</p>
]]></content>
  </entry>
  
</feed>
