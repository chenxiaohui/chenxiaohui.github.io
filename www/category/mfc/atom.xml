<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MFC | CXH.ME]]></title>
  <link href="http://cxh.me/category/mfc/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-10-15T16:06:26+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[区分一下强制类型转换运算符重载/赋值运算符重载/对象定义的赋值
]]></title>
    <link href="http://cxh.me/2012/05/08/type-cast-and-overload-of-assign-operator-and-object-defination/"/>
    <updated>2012-05-08T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/05/08/type-cast-and-overload-of-assign-operator-and-object-defination</id>
    <content type="html"><![CDATA[<h1></h1>

<p>这三个名字可能很绕，看着也很不一样，但其实是三个很容易混淆的概念，并且经常在实际编程中遇到。这里拿出来比较一下。</p>

<p>首先是强制类型转换运算符的重载，作用是当前对象向其他类型的转换，常见的形式是</p>

<pre><code>operator int();
Integer::operator int()
{
    return x;
}
</code></pre>

<p>调用方式类似于</p>

<pre><code>Integer c(10);
int a=c;
</code></pre>

<p>在函数调用的时候，类型转换的重载也会被隐式调用，比如下面一种情况</p>

<pre><code>void print(int n)
{
    cout
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析C++输入输出运算符重载]]></title>
    <link href="http://cxh.me/2012/05/07/deep-understanding-of-cplusplus-input-output-operation-reload/"/>
    <updated>2012-05-07T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/05/07/deep-understanding-of-cplusplus-input-output-operation-reload</id>
    <content type="html"><![CDATA[<h1></h1>

<p>其实算不上什么深入解析，只不过最近看CArchive类的实现，其中一些写法完全颠覆了我对输入输出运算符重载的一些理解，所以在这里mark一下。</p>

<p>我们以输出运算符为例。首先输出运算符重载的一般形式是</p>

<pre><code>friend ostream&amp; operator(CArchive&amp; ar, CObject*&amp; pOb);
</code></pre>

<p>于是才发觉ostream并不是必需的，换句话说，从语法上讲，ostream的位置放什么类都可以，只不过语义上要行得通。而友元的重载从语法上讲也不是必须的，比如可以依然用成员函数重载，函数定义变成如下的格式</p>

<pre><code>ostream&amp; operator&gt;&gt;(ostream&amp; o);
</code></pre>

<p>使用的时候只能用object>>cout（或者cout>>object这就太别扭了）形式了，并且不可能连续使用了（比如obj1>>obj2>>cout），这违背了C 规范，但是语法上是的过得去的。</p>

<p>举一个简单而诡异的例子（原谅我这里诡异的代码风格，只是个演示）</p>

<pre><code>#include "stdafx.h"
#include 
using namespace std;
class output
{
public:
    output&amp; operator
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SkinMagic在WinSDK程序中的链接]]></title>
    <link href="http://cxh.me/2011/08/31/skin-magic-linking-in-winsdk-program/"/>
    <updated>2011-08-31T00:00:00+08:00</updated>
    <id>http://cxh.me/2011/08/31/skin-magic-linking-in-winsdk-program</id>
    <content type="html"><![CDATA[<h1></h1>

<p>其实这种诡异的搭我配估计没人会遇到。我只是想在SDK程序里做一下美化而已。</p>

<p>SkinMagic在MFC程序里的使用还是很常见的，网上代码有的是，至于大家手里的SkinMagic库，恐怕没有几个是正版的吧？有木有有木有！</p>

<p>其实在SDK下使用SkinMagic还是比较简单的事情，主要解决两个问题：</p>

<ol>
<li> 库的链接</li>
<li> 皮肤的导入</li>
</ol>


<p>第一个其实好说，注意InitSkinMagicLib传入WinMain的hInstance：</p>

<pre><code>VERIFY( 1 == InitSkinMagicLib(hInstance, NULL , NULL, NULL ));
VERIFY( 1 == LoadSkinFromResource(NULL,MAKEINTRESOURCE(IDR_SKIN5),"skin"));
VERIFY( 1 == SetDialogSkin( "Dialog" ) );
</code></pre>

<p>然后记得导入库就行</p>

<pre><code>#pragma  comment(lib,"SkinMagicTrial")
#include "SkinMagicLib.h"
</code></pre>

<p>第二个问题，由于是SDK程序，所以需要手动添加资源，然后在资源里建立SKIN项，再导入皮肤，这时候VS会自动建立resource.h文件。</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2011/08/image_thumb.png" title="image" alt="image" /> 然后就OK啦。如果自己建立窗口，记得对ShowWindow之前调用一下SetWindowSkin。我只弹了个对话框，效果如下</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2011/08/image_thumb1.png" title="image" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
