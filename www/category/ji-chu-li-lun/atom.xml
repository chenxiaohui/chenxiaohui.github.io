<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 基础理论 | CXH.ME]]></title>
  <link href="http://cxh.me/category/ji-chu-li-lun/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-06-28T16:42:01+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[跨线程解锁安全的spinlock]]></title>
    <link href="http://cxh.me/2016/06/13/safe-spin-lock/"/>
    <updated>2016-06-13T17:36:00+08:00</updated>
    <id>http://cxh.me/2016/06/13/safe-spin-lock</id>
    <content type="html"><![CDATA[<p>  在C语言下面我们可能会写出如下的代码：</p>

<pre><code>static pthread_spinlock_t lock;

__attribute__((constructor))
void lock_constructor () {
    if ( pthread_spin_init ( &amp;lock, 0 ) != 0 ) {
        exit ( 1 );
    }
}

int func(xx) {
  int ret = 0;
  if (xx) {
    ret = ERR1;
    goto exit;
  }
  pthread_spin_lock(&amp;lock);
  if (xx) {
    ret = ERR2;
    goto exit;
  }
exit:
  pthread_spin_unlock(&amp;lock);
  return 0;
}

__attribute__((destructor))
void lock_destructor () {
    if ( pthread_spin_destroy ( &amp;lock ) != 0 ) {
        exit ( 3 );
    }
}
</code></pre>

<p>  这段代码存在下面几个问题：</p>

<pre><code>1. spinlock没有静态初始化函数，需要确保使用前调用了pthread_spin_init.
2. 跳转到exit标记去unlock的时候，并不能保证lock已经被加过锁了。
3. func本身存在潜在的并发问题，一个线程可能跳转到exit去解别的线程加的锁。
</code></pre>

<p>  根据<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_spin_lock.html" title="The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition">文档</a>这几种情况下的行为是未定义的。</p>

<pre><code>  The pthread_spin_lock() function shall lock the spin lock referenced by lock. The calling thread shall acquire the lock if it is not held by another thread. Otherwise, the thread shall spin (that is, shall not return from the pthread_spin_lock() call) until the lock becomes available. The results are undefined if the calling thread holds the lock at the time the call is made. The pthread_spin_trylock() function shall lock the spin lock referenced by lock if it is not held by any thread. Otherwise, the function shall fail.

  The results are undefined if any of these functions is called with an uninitialized spin lock.
</code></pre>

<p>  为了情况1，我们可以考虑通过原子操作实现spin_lock，用一个volatile int64类型的整数来标识当前锁的状态。nginx里面的实现如下：</p>

<pre><code>    /* 
     * Copyright (C) Igor Sysoev 
     * Copyright (C) Nginx, Inc. 
     */  


    #include &lt;ngx_config.h&gt;  
    #include &lt;ngx_core.h&gt;  

    //Function: to achieve spin atomic operation lock method based on ngx_spinlock  
    //Parameter interpretation:   
    //lock: Lock the atomic variable expression  
    //value: Flag, whether the lock is a process  
    //spin: In a multi processor system, when the ngx_spinlock method did not get the lock, the current process in a scheduling kernel in the waiting for the other processors to release the lock time  
    void  
    ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin)  
    {  

    #if (NGX_HAVE_ATOMIC_OPS)//Support atomic operations  

        ngx_uint_t  i, n;  

        //Has been in circulation, until the lock is acquired  
        for ( ;; ) {  

            //Lock 0 said no other process holding the lock, then the lock value indicates the current process holding the lock is set to value parameters  
            if (*lock == 0 &amp;&amp; ngx_atomic_cmp_set(lock, 0, value)) {  
                return;  
            }  

            //If it is a multi processor system  
            if (ngx_ncpu &gt; 1) {  
                for (n = 1; n &lt;spin; n &lt;&lt;= 1) {  
                    //With the increasing number of the actual to wait, inspection interval and lock more  
                    for (i = 0; i &lt;n; i++) {  
                        ngx_cpu_pause();//Tell CPU now in the spin lock wait state  
                    }  

                    //Check the lock is released  
                    if (*lock == 0 &amp;&amp; ngx_atomic_cmp_set(lock, 0, value)) {  
                        return;  
                    }  
                }  
            }  

            //The current process for the processor, but still in the executable state  
            ngx_sched_yield();  
        }  

    #else  

    #if (NGX_THREADS)  

    #error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !  

    #endif  

    #endif  

    }       
</code></pre>

<p>  简单解释几个关键点：</p>

<ol>
<li> ngx_atomic_cmp_set等是nginx封装的原子操作，可以从字面意思理解。能直接对应到gcc支持的一些原子操作。</li>
<li> ngx_cpu_pause是不切换cpu上下文的让cpu让出时间片的操作，可对应到后文的<strong>asm</strong>(&ldquo;.byte 0xf3, 0x90&rdquo;);</li>
<li> ngx_sched_yield 暂时挂起上下文，让cpu调度其他任务。</li>
</ol>


<p>  nginx的实现解决了静态初始化的问题，但是解决不了上述问题2和3。为此我们可以考虑在表征spinlock状态的整形变量中加入线程id，来区分操作者是否是锁持有者。参考实现如下：</p>

<pre><code>typedef volatile int64_t Atomic;

#define _spin_unlock_safe   _unlock_safe

typedef struct {
 union {
  struct {
    int32_t tid;
    int32_t atomic32;
  };
  volatile int64_t atomic;
 };
} CACHE_ALIGNED SpinLock;

static __inline__ int64_t _get_tid() {
  static __thread int64_t tid = -1;
  if _unlikely(tid == -1) {
    tid = (int64_t)(syscall(__NR_gettid));
  }
  return tid;
}

static __inline__ int _try_lock_safe(SpinLock *lock) {
  SpinLock lock_val = };
  return lock-&gt;atomic == 0 &amp;&amp; _atomic_cmp_set(&amp;lock-&gt;atomic, 0, lock_val.atomic);
}

static __inline__ int _unlock_safe(SpinLock *lock) {
  SpinLock lock_val = };
  return _atomic_cmp_set(&amp;lock-&gt;atomic, lock_val.atomic, 0);
}

static __inline__ void _spin_lock_safe(SpinLock *lock) {
  int i, n;
  SpinLock lock_val = };
  for (; ;) {
    if (lock-&gt;atomic == 0 &amp;&amp; _atomic_cmp_set(&amp;lock-&gt;atomic, 0, lock_val.atomic)) {
      return;
    }

    for (n = 1; n &lt; 1024; n &lt;&lt;= 1) {

      for (i = 0; i &lt; n; i++) {
        __asm__(".byte 0xf3, 0x90");
      }

      if (lock-&gt;atomic == 0 &amp;&amp; _atomic_cmp_set(&amp;lock-&gt;atomic, 0, lock_val.atomic)) {
        return;
      }
    }

    sched_yield();
  }
}

static __inline__ void _spin_lock(Atomic *lock) {
  int i, n;
  for (; ;) {
    if (*lock == 0 &amp;&amp; _atomic_cmp_set(lock, 0, 1)) {
      return;
    }

    for (n = 1; n &lt; 1024; n &lt;&lt;= 1) {

      for (i = 0; i &lt; n; i++) {
        __asm__(".byte 0xf3, 0x90");
      }

      if (*lock == 0 &amp;&amp; _atomic_cmp_set(lock, 0, 1)) {
        return;
      }
    }

    sched_yield();
  }
}
</code></pre>

<p>  简单解释几个问题：</p>

<ol>
<li> <strong>asm</strong>(&ldquo;.byte 0xf3, 0x90&rdquo;);是intel的一条指令，实际上就是上面的ngx_cpu_pause</li>
<li> sched_yield实现等同于ngx_sched_yield</li>
<li> 用两个int32拼成了一个64位整数，考虑截取了tid有风险，后期可以优化成只用一位表示加锁状态，剩下63位依然给tid用。</li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_spin_lock.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_spin_lock.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过父子关系构建话题树]]></title>
    <link href="http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation/"/>
    <updated>2015-07-18T11:35:00+08:00</updated>
    <id>http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation</id>
    <content type="html"><![CDATA[<p>  一道题目，本来觉得挺简单的，后来卡在一个小问题上。mark一下：</p>

<p>  给定一个数据库表，存了所有话题的关系，形式是：parent->child，表示前面是后面话题的父话题。根据这个关系构建出话题树并打印。</p>

<pre><code>eg:
输入：
    a b
    c a
    d e
    e f
    r c
    r d
输出：
     r
       c
         a
           b
       d
         e
           f
题目隐含：
    1. DAG：有向无环
    2. 节点不重复
</code></pre>

<p>  直观看类似于Graphviz的算法，只不过保证了是棵树。C++实现上可以直接通过树来做，这里用了Python。</p>

<!--more-->


<p>  思路上先找到父节点，再找到子节点，如果都找到，那么移动子节点到父节点下形成一个新的成员，如果父节点没找到，让其成为root节点（加一个叫root的dummynode，反正是话题，我们保证这个话题是保留字）的子节点，如果子节点没找到，让其形成一个新的空节点。</p>

<p>  Python下数据结构类似于：</p>

<pre><code>ret = {
    "root": {
        "r": {
            "c": {
                "a":{
                    "b":{}
                    },
            },
            "d":{
                "e":{
                    "f":{}
                }
            }
        }
    }
}
</code></pre>

<p>  叶节点都保留了一个空的子节点集合。</p>

<p>  代码如下：</p>

<pre><code>default_indent = 2
filename='topic'

def print_result(tree, indent):
    """"""
    for key, value in tree.items():
       if key:
           print ' ' * indent, key
       if value:
           print_result(value, indent + default_indent)


def find_node(tree, element):
    """"""
    for key, value in tree.items():
        if key == element:
            return tree, tree[key]
        elif value:
            parent, child = find_node(value, element)
            if parent:
                return parent, child
    return None, None

def parse_file(ret, fp):
    """"""
    for pair in fp:
        pair = pair.strip("\n")
        if pair:
            parent, child = pair.split()
            _, parent_element = find_node(ret, parent)
            child_parent, child_element = find_node(ret, child)

            if parent_element == None:
                ret["root"][parent] = {}
                parent_element = ret["root"][parent]
            if child_element == None:
                child_element = {}

            parent_element[child] = child_element
            if child_parent:
                del child_parent[child]

if __name__ == '__main__':
    ret = {"root":{}}
    try:
        with open(filename, 'r') as fp:
            parse_file(ret, fp)
    except Exception:
        raise

    print_result(ret['root'], 0)
</code></pre>

<p>  之前出的错误是：</p>

<ol>
<li>python毕竟是引用计数，把一个节点变成另外一个节点的子节点的时候忘了remove旧的节点</li>
<li>深度优先搜索找节点的时候直接return find_node(xxx)了，这样的话深度完一个子节点，不会再继续本层循环了。这个也是大意了，随手一测这个find_node函数就没再看。</li>
</ol>


<p>  性能提升的办法主要是：</p>

<ol>
<li>hash一下所有的节点。把遍历查找的复杂度降下来</li>
<li>先排序（按照parent)，然后把reduce，这样会先把相同的部分生成一个集合，比如a:[b,c,d]这种。</li>
</ol>


<p><strong>事实上，这个题目可以直接用邻接表表示数据结构，然后DFS来打印就好了&hellip;</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[partition算法的落点讨论]]></title>
    <link href="http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis/"/>
    <updated>2015-04-20T21:27:00+08:00</updated>
    <id>http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis</id>
    <content type="html"><![CDATA[<p>  首先这里的partition算法指的是快速排序中把数据分区的算法，算法接受一个数列和一个值，返回一个位置，这个位置之前的元素都小于等于输入值，之后的元素都大于等于输入值。</p>

<p>  算法如下：</p>

<p>  还有一种常见的形式：</p>

<p>  这里我们讨论下落点的情况，如果partition算法可以传入任何的value，而不是快排中那样从序列中随机获得一个值，那么结果就会有多重情况了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用google来验证一下Maclaurin展开式]]></title>
    <link href="http://cxh.me/2014/09/07/using-google-verify-maclaurin-series/"/>
    <updated>2014-09-07T15:35:00+08:00</updated>
    <id>http://cxh.me/2014/09/07/using-google-verify-maclaurin-series</id>
    <content type="html"><![CDATA[<p>  偶然发现google可以直接画出函数图像来，精准度极高，于是想起来用这个功能来看一下Maclaurin展开是如何随精度增加而逼近展开式的。从某种角度上讲，这是一个极好的拟合过程，相对于梯度下降的逐步拟合来讲，泰勒公式或者麦克劳林展开直接推导出了每一个拟合因子。</p>

<p>  泰勒级数的定义如下：</p>

<p>  <img class="center" src="/images/2014/taylor.png" title="&ldquo;Taylor公式&rdquo; &ldquo;Taylor公式&rdquo;" ></p>

<p>  不过这是带拉格朗日余项的形式。让基准值=0可以得到 Maclaurin 展开式，当然这也就意味着Maclaurin展开式在0附近的拟合是最精确的。定义如下：</p>

<p>  <img class="center" src="/images/2014/Maclaurin.png" title="&ldquo;Maclaurin展开式&rdquo; &ldquo;Maclaurin展开式&rdquo;" ></p>

<!--more-->


<p>  几个重要的Maclaurin展开如下：</p>

<p>  <img class="center" src="/images/2014/sinx.png">
  <img class="center" src="/images/2014/cosx.png" title="&ldquo;几个重要的Maclaurin展开&rdquo; &ldquo;几个重要的Maclaurin展开&rdquo;" ></p>

<p>  这里我们验证一下sinx的逼近随着级数的增加而增加的情况。这也对应于拟合过程拟合维度的增加，相对于一元的拟合，二元或者多元就是会精确一些，但是会带来过拟合的风险。</p>

<p>  首先是sinx的图像</p>

<p>  <img class="center" src="/images/2014/sin_x.png"></p>

<p>  一元函数拟合的时候，y=x</p>

<p>  <img class="center" src="/images/2014/x_1.png"></p>

<p>  二元拟合的时候，y=x-x<sup>3</sup>/3!</p>

<p>  <img class="center" src="/images/2014/x_2.png"></p>

<p>  三元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!</p>

<p>  <img class="center" src="/images/2014/x_3.png"></p>

<p>  四元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!-x<sup>7</sup>/7!</p>

<p>  <img class="center" src="/images/2014/x_4.png"></p>

<p>  合并起来的图像大致如此：</p>

<p>  <img class="center" src="/images/2014/combine.png"></p>

<p>  再高阶的图像就不画了，上面基本保证了坐标系缩放比例是一致的(sinx的图像由于y轴比例没有跟其他的x轴保持一样的缩放比例），可以看到随着拟合维度的升高，拟合曲线越来越逼近sinx，这也直观体现了Maclaurin展开式的意义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++变量的初始化方式]]></title>
    <link href="http://cxh.me/2012/04/09/ways-to-initialize-variables-in-cplusplus/"/>
    <updated>2012-04-09T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/04/09/ways-to-initialize-variables-in-cplusplus</id>
    <content type="html"><![CDATA[<h1></h1>

<p>  写这个问题是受微软今年实习生招聘的一道笔试题启发，上一篇博客好像提到了。之前还真没细想过这些事情。</p>

<p>  首先把需要初始化的成员变量分为几类：</p>

<blockquote><p>一般变量(int)</p>

<p>静态成员变量(static int)</p>

<p>常量(const int )</p>

<p>静态常量(static const int)</p></blockquote>

<p>  对应的初始化方式是：</p>

<blockquote><p>一般变量可以在初始化列表里或者构造函数里初始化，不能直接初始化或者类外初始化</p>

<p>静态成员变量必须在类外初始化</p>

<p>常量必须在初始化列表里初始化</p>

<p>静态常量必须只能在定义的时候初始化</p></blockquote>

<p>  举一个简单的例子</p>

<pre><code>#include 
using namespace std;
class Test
{
private:
    int a;
    static int b;
    const int c;
    static const int d=4;
public:
    Test():c(3)//,a(1)或者在初始化列表里初始化
    {
        a=1;
    }
};
int Test::b=2;
void main()
{
    Test t;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
