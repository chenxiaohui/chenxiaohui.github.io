<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 基础理论 | CXH.ME]]></title>
  <link href="http://cxh.me/category/ji-chu-li-lun/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-11-21T17:37:23+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++变量的初始化方式]]></title>
    <link href="http://cxh.me/2012/04/09/ways-to-initialize-variables-in-cplusplus/"/>
    <updated>2012-04-09T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/04/09/ways-to-initialize-variables-in-cplusplus</id>
    <content type="html"><![CDATA[<h1></h1>

<p>写这个问题是受微软今年实习生招聘的一道笔试题启发，上一篇博客好像提到了。之前还真没细想过这些事情。</p>

<p>首先把需要初始化的成员变量分为几类：</p>

<blockquote><p>一般变量(int)</p>

<p>静态成员变量(static int)</p>

<p>常量(const int )</p>

<p>静态常量(static const int)</p></blockquote>

<p>对应的初始化方式是：</p>

<blockquote><p>一般变量可以在初始化列表里或者构造函数里初始化，不能直接初始化或者类外初始化</p>

<p>静态成员变量必须在类外初始化</p>

<p>常量必须在初始化列表里初始化</p>

<p>静态常量必须只能在定义的时候初始化</p></blockquote>

<p>举一个简单的例子</p>

<blockquote><h1>include</h1>

<h1>include</h1>

<p>using namespace std;
class Test
{
private:
int a;
static int b;
const int c;
static const int d=4;
public:
Test():c(3)//,a(1)或者在初始化列表里初始化
{
a=1;
}
};
int Test::b=2;</p>

<p>void main()
{
Test t;
}</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于类成员变量初始化顺序]]></title>
    <link href="http://cxh.me/2012/04/09/the-initialization-order-of-class-member-variables/"/>
    <updated>2012-04-09T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/04/09/the-initialization-order-of-class-member-variables</id>
    <content type="html"><![CDATA[<h1></h1>

<p>java和C#语言里类变量初始化的顺序是</p>

<blockquote><ol>
<li><p> 类成员变量初始化先于类的构造函数</p></li>
<li><p> 静态成员变量先于实例变量</p></li>
<li><p> 父类成员变量先于子类成员变量 C#相反</p></li>
<li><p> 父类构造函数先于子类构造函数</p></li>
</ol>
</blockquote>

<p>举一个java的例子:</p>

<pre><code>class Base
{
    public static Test a=new Test("a");
    public static Test b;
    public Test c=new Test("c");
    public Test d;
    static
    {
        b=new Test("b");
    }
    public Base()
    {
        d=new Test("d");
    }
    public static void main(String[] args) {
        new Derived();
    }
}
class Derived extends Base
{
    public static Test da=new Test("da");
    public static Test db;
    public Test dc=new Test("dc");
    public Test dd;
    static
    {
        db=new Test("db");
    }
    public Derived()
    {
        dd=new Test("dd");
    }
}

class Test
{
    public Test (String name) {
        System.out.println(name);
    }
}
</code></pre>

<p>运行结果是：</p>

<pre><code>a
b
da
db
c
d
dc
dd
</code></pre>

<p>C 中没有成员变量定义时初始化的方式，所以有如下几条：</p>

<ol>
<li><p> 构造函数初始化列表的变量优先于构造函数（至少明显的写在前面）</p></li>
<li><p> 静态成员变量先于实例变量</p></li>
<li><p> 父类成员变量先于子类成员变量</p></li>
<li><p> 父类构造函数先于子类构造函数</p></li>
</ol>


<p>举一个例子：</p>

<pre><code>#include 
#include 
using namespace std;
class Test
{
public:
    Test(string n)
    {
        cout
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于const和指针的专题]]></title>
    <link href="http://cxh.me/2012/04/07/about-const-and-pointer/"/>
    <updated>2012-04-07T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/04/07/about-const-and-pointer</id>
    <content type="html"><![CDATA[<h1></h1>

<p>const和指针的问题是笔试里经常出现的问题。这里综合一下各种不同的情况。</p>

<p>首先是几种const与指针组合的区分，比如：</p>

<blockquote><p>int b = 500;
const int<em> a = &b; [1]
int const </em>a = &b; [2]
int<em> const a = &b; [3]
const int</em> const a = &b; [4]</p></blockquote>

<p>[1]和[2]其实是一样的，都是指向int型常量的指针，而[3]是int型常量指针，两者的区别是指向常量的指针本身可以指向别的，所指向的数据不能被修改，而常量指针本身不能被修改。[4]就不用说了，啥都甭想改。</p>

<p>至于例子，可以举下面的一个例子（以[1]为例）。这里小小的牵扯了一点优先级的问题。</p>

<blockquote><h1>include</h1>

<p>using namespace std;</p>

<p>int main(int argc,char<em> argv[])
{
int a=1;
const int </em>b=&a;
<em>b ;//成立
(</em>b) ;//编译器错误
}</p></blockquote>

<p>那么我们能不能突破const去修改一个值呢？虽然这件事情本身并没有多大意义，但是还是可以做的。我们可以用const_cast来去掉一个const或者volatile限制。const_cast的作用主要分如下三种：</p>

<blockquote><p>转化一个常量指针为非常量指针</p>

<p>转化一个常量引用为非常量引用</p>

<p>转化一个常量对象为非常量对象</p></blockquote>

<p>至于例子</p>

<p>我们举如下一个例子：</p>

<blockquote><h1>include</h1>

<p>using namespace std;</p>

<p>class Test
{
public:
const int a ;
Test(int b):a(b)
{</p>

<p>}
};</p>

<p>int main(int argc,char<em> argv[])
{
Test t(1);
//t.a=2;//出错
int b=const_cast(t.a);
int&amp; c=const_cast(t.a);
int</em> d=const_cast(&amp;t.a);
b=2;
c=3;
cout</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Python的类成员和Javascript的原型]]></title>
    <link href="http://cxh.me/2011/08/24/about-python-class-member-and-javascript-prototype/"/>
    <updated>2011-08-24T00:00:00+08:00</updated>
    <id>http://cxh.me/2011/08/24/about-python-class-member-and-javascript-prototype</id>
    <content type="html"><![CDATA[<h1></h1>

<p>偶然发现两个的设计思路是一致的（个人理解，欢迎指正）。这里简要分析一下：</p>

<p>Python的类成员，也就是直接定义在类里的变量（实例成员是用self.x直接声明的），而类方法就是用@classmethod说明的方法。</p>

<blockquote><p>Python还有一种@staticmethod，静态方法，其实设立所有的静态方法和变量的目的主要是用类名限制访问范围，编译的时候就直接被改名然后变成了全局变量。</p></blockquote>

<p>Js的原型（prototype）是js里最复杂的一部分了，有的人可能Jquery什么的用的很熟，但是对原型一无所知。最初设计Js的时候设计师没有考虑把它设计成一门完整的语言，后来决定引入面向对象的时候，就采用了原型链这种诡异的设计模式。具体的使用大家应该都熟悉。类名（实际是函数名）.prototype.x=…，这样就在类的原型上加入了一方法或成员。</p>

<blockquote><p>实际Js也有静态方法和静态变量，就是通过类名.x=…定义的，跟一切静态方法一致，也只是限制了范围，最终会改名并变成全局变量。</p></blockquote>

<p>我们只讨论类成员类方法，静态的不在我们考虑范围之内，这种类即对象的设计理念，主流语言里貌似只有Js，Python和Perl采用了，跟静态方法是完全不同的理念。</p>

<p>首先，我们要问为什么要引入类方法和类成员，它跟实例方法实际成员有什么不同呢?</p>

<p>这里我们要建立一个概念，在Python和Js里，类也是一种对象（实例）（我的世界观颠覆了）。类其实相当于一个模板，只不过大多数语言里，我们通过类实例化出一个一个对象，抛去静态的，这些对象是各不相同的（先考虑成员对象，方法都是共享的）。而Python和Js里，这些对象共同引用类模板里的对象（及方法）。类模板好比一个公共的祖先，从这个祖先衍生的实例都有相同的血缘（共同的prototype），但是各自有自己不同的部分。</p>

<p>不知道这么说是否清晰，我们举两个例子：</p>

<p>Python的[1]:</p>

<pre><code>class Demo:
    i = 0
    def __init__(self):
        self.j = 0
o1 = Demo()
o2 = Demo()

Demo.i = 10 #类成员的赋值
print o1.i #结果为10,说明在没有显式定义实例成员的时候，就会取类成员的值
print o2.i #结果为10,说明在没有显式定义实例成员的时候，就会取类成员的值

o1.i = 1 #会为o1对象创建实例成员。
o2.i = 2 #会为o2对象创建实例成员
o1.j = 11
o2.j = 12

print o1.i # 结果为1
print o2.i # 结果为2   这两个结果说明对i数据成员的赋值，每个对象都有自己的实例成员。
print Demo.i #结果为10说明，前边的赋值，并没有覆盖该类成员。
print o1.j # 结果为 11
print o2.j # 结果为 12 正常的实例成员访问。
</code></pre>

<p>结果很清晰，类成员大家共享，但是各自有各自不同的实例成员，类成员可以通过实例调用，这时候就存在了命名冲突了怎么办的问题，于是实例成员覆盖类成员，没有实例成员的时候才调用类成员，而通过类名调用类成员是最正统的方法了，毕竟Python里类也是对象，你把类名想象成一个直接被实例化了的原型对象，就好理解多了。</p>

<p>然后举一个Js的例子[2]：</p>

<pre><code>var BaseClass = function() {
this.method1 = function(){
       alert(' Defined by the "this" in the instance method');
 }
};
var instance1 = new BaseClass();
instance1.method1 = function(){
    alert(' Defined directly in the instance method');
}
BaseClass.prototype.method1 = function(){
    alert(' Defined by the prototype instance method ');
}
instance1.method1();//Defined directly in the instance method
</code></pre>

<blockquote><p>通过运行结果跟踪测试可以看出直接定义在实例上的变量的优先级要高于定义在“this”上的，而定义在“this”上的又高于 prototype定义的变量。即直接定义在实例上的变量会覆盖定义在“this”上和prototype定义的变量，定义在“this”上的会覆盖prototype定义的变量。</p></blockquote>

<p>这与Python的例子思想一致。原型相当于类模板，实例共享原型，通过实例名调用一个方法时，如果出现命名混淆，实例的方法也会覆盖原型的方法。同样，实例同名成员的改动并不会影响原型成员，验证如下。而且原型最正统的调用方法也是通过类名，而不是实例名。</p>

<pre><code>function ec(str) {
    document.write(str "");
}
var test= function(){
}
test.prototype.age = 11;
var t=new test();
var s=new test();

ec(t.age);
ec(s.age);

t.age=12;
s.age=13;

ec(t.age);
ec(s.age);
ec(test.prototype.age);
</code></pre>

<p>有了这种理解，阮一峰的三篇关于Js面向对象设计思想的文章也就不那么费解了。</p>

<p>最后，吐个槽：Python真是纯面向对象啊，纯的……</p>

<blockquote><p>参考文献：</p>

<p>[1] python中类中的静态数据成员和实例数据成员</p>

<p>（注：实际上是类数据成员而不是静态）</p>

<p>[2] javascript中静态方法、实例方法、内部方法和原型的一点见解</p>

<p>[3] 阮一峰，Javascript 面向对象编程（一）：封装</p>

<p>[4] 阮一峰，Javascript面向对象编程（二）：构造函数的继承</p>

<p>[5] 阮一峰，Javascript面向对象编程（三）：非构造函数的继承</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[各种排序算法的图形化演示]]></title>
    <link href="http://cxh.me/2011/04/08/visualization-of-all-kinds-of-sort-algorithm/"/>
    <updated>2011-04-08T00:00:00+08:00</updated>
    <id>http://cxh.me/2011/04/08/visualization-of-all-kinds-of-sort-algorithm</id>
    <content type="html"><![CDATA[<h1></h1>

<p>一个日本哥哥写的各种排序算法的图形化演示，非常不错，推荐一下。</p>

<p>Your browser does not support iframes.</p>

<p>(ps:话说那个bogo算法到底在做甚么??)</p>

<p>还有之前一直很火的一个视频：排序算法的声音，一起欣赏一下吧~~</p>
]]></content>
  </entry>
  
</feed>
