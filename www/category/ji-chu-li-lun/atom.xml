<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 基础理论 | CXH.ME]]></title>
  <link href="http://cxh.me/category/ji-chu-li-lun/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-04-03T19:35:15+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过父子关系构建话题树]]></title>
    <link href="http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation/"/>
    <updated>2015-07-18T11:35:00+08:00</updated>
    <id>http://cxh.me/2015/07/18/build-topic-tree-using-parent-relation</id>
    <content type="html"><![CDATA[<p>  一道题目，本来觉得挺简单的，后来卡在一个小问题上。mark一下：</p>

<p>  给定一个数据库表，存了所有话题的关系，形式是：parent->child，表示前面是后面话题的父话题。根据这个关系构建出话题树并打印。</p>

<pre><code>eg:
输入：
    a b
    c a
    d e
    e f
    r c
    r d
输出：
     r
       c
         a
           b
       d
         e
           f
题目隐含：
    1. DAG：有向无环
    2. 节点不重复
</code></pre>

<p>  直观看类似于Graphviz的算法，只不过保证了是棵树。C++实现上可以直接通过树来做，这里用了Python。</p>

<!--more-->


<p>  思路上先找到父节点，再找到子节点，如果都找到，那么移动子节点到父节点下形成一个新的成员，如果父节点没找到，让其成为root节点（加一个叫root的dummynode，反正是话题，我们保证这个话题是保留字）的子节点，如果子节点没找到，让其形成一个新的空节点。</p>

<p>  Python下数据结构类似于：</p>

<pre><code>ret = {
    "root": {
        "r": {
            "c": {
                "a":{
                    "b":{}
                    },
            },
            "d":{
                "e":{
                    "f":{}
                }
            }
        }
    }
}
</code></pre>

<p>  叶节点都保留了一个空的子节点集合。</p>

<p>  代码如下：</p>

<pre><code>default_indent = 2
filename='topic'

def print_result(tree, indent):
    """"""
    for key, value in tree.items():
       if key:
           print ' ' * indent, key
       if value:
           print_result(value, indent + default_indent)


def find_node(tree, element):
    """"""
    for key, value in tree.items():
        if key == element:
            return tree, tree[key]
        elif value:
            parent, child = find_node(value, element)
            if parent:
                return parent, child
    return None, None

def parse_file(ret, fp):
    """"""
    for pair in fp:
        pair = pair.strip("\n")
        if pair:
            parent, child = pair.split()
            _, parent_element = find_node(ret, parent)
            child_parent, child_element = find_node(ret, child)

            if parent_element == None:
                ret["root"][parent] = {}
                parent_element = ret["root"][parent]
            if child_element == None:
                child_element = {}

            parent_element[child] = child_element
            if child_parent:
                del child_parent[child]

if __name__ == '__main__':
    ret = {"root":{}}
    try:
        with open(filename, 'r') as fp:
            parse_file(ret, fp)
    except Exception:
        raise

    print_result(ret['root'], 0)
</code></pre>

<p>  之前出的错误是：</p>

<ol>
<li>python毕竟是引用计数，把一个节点变成另外一个节点的子节点的时候忘了remove旧的节点</li>
<li>深度优先搜索找节点的时候直接return find_node(xxx)了，这样的话深度完一个子节点，不会再继续本层循环了。这个也是大意了，随手一测这个find_node函数就没再看。</li>
</ol>


<p>  性能提升的办法主要是：</p>

<ol>
<li>hash一下所有的节点。把遍历查找的复杂度降下来</li>
<li>先排序（按照parent)，然后把reduce，这样会先把相同的部分生成一个集合，比如a:[b,c,d]这种。</li>
</ol>


<p><strong>事实上，这个题目可以直接用邻接表表示数据结构，然后DFS来打印就好了&hellip;</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[partition算法的落点讨论]]></title>
    <link href="http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis/"/>
    <updated>2015-04-20T21:27:00+08:00</updated>
    <id>http://cxh.me/2015/04/20/partition-algorith-quit-position-analysis</id>
    <content type="html"><![CDATA[<p>  首先这里的partition算法指的是快速排序中把数据分区的算法，算法接受一个数列和一个值，返回一个位置，这个位置之前的元素都小于等于输入值，之后的元素都大于等于输入值。</p>

<p>  算法如下：</p>

<p>  还有一种常见的形式：</p>

<p>  这里我们讨论下落点的情况，如果partition算法可以传入任何的value，而不是快排中那样从序列中随机获得一个值，那么结果就会有多重情况了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用google来验证一下Maclaurin展开式]]></title>
    <link href="http://cxh.me/2014/09/07/using-google-verify-maclaurin-series/"/>
    <updated>2014-09-07T15:35:00+08:00</updated>
    <id>http://cxh.me/2014/09/07/using-google-verify-maclaurin-series</id>
    <content type="html"><![CDATA[<p>  偶然发现google可以直接画出函数图像来，精准度极高，于是想起来用这个功能来看一下Maclaurin展开是如何随精度增加而逼近展开式的。从某种角度上讲，这是一个极好的拟合过程，相对于梯度下降的逐步拟合来讲，泰勒公式或者麦克劳林展开直接推导出了每一个拟合因子。</p>

<p>  泰勒级数的定义如下：</p>

<p>  <img class="center" src="/images/2014/taylor.png" title="&ldquo;Taylor公式&rdquo; &ldquo;Taylor公式&rdquo;" ></p>

<p>  不过这是带拉格朗日余项的形式。让基准值=0可以得到 Maclaurin 展开式，当然这也就意味着Maclaurin展开式在0附近的拟合是最精确的。定义如下：</p>

<p>  <img class="center" src="/images/2014/Maclaurin.png" title="&ldquo;Maclaurin展开式&rdquo; &ldquo;Maclaurin展开式&rdquo;" ></p>

<!--more-->


<p>  几个重要的Maclaurin展开如下：</p>

<p>  <img class="center" src="/images/2014/sinx.png">
  <img class="center" src="/images/2014/cosx.png" title="&ldquo;几个重要的Maclaurin展开&rdquo; &ldquo;几个重要的Maclaurin展开&rdquo;" ></p>

<p>  这里我们验证一下sinx的逼近随着级数的增加而增加的情况。这也对应于拟合过程拟合维度的增加，相对于一元的拟合，二元或者多元就是会精确一些，但是会带来过拟合的风险。</p>

<p>  首先是sinx的图像</p>

<p>  <img class="center" src="/images/2014/sin_x.png"></p>

<p>  一元函数拟合的时候，y=x</p>

<p>  <img class="center" src="/images/2014/x_1.png"></p>

<p>  二元拟合的时候，y=x-x<sup>3</sup>/3!</p>

<p>  <img class="center" src="/images/2014/x_2.png"></p>

<p>  三元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!</p>

<p>  <img class="center" src="/images/2014/x_3.png"></p>

<p>  四元拟合的时候，y=x-x<sup>3</sup>/3!+x<sup>5</sup>/5!-x<sup>7</sup>/7!</p>

<p>  <img class="center" src="/images/2014/x_4.png"></p>

<p>  合并起来的图像大致如此：</p>

<p>  <img class="center" src="/images/2014/combine.png"></p>

<p>  再高阶的图像就不画了，上面基本保证了坐标系缩放比例是一致的(sinx的图像由于y轴比例没有跟其他的x轴保持一样的缩放比例），可以看到随着拟合维度的升高，拟合曲线越来越逼近sinx，这也直观体现了Maclaurin展开式的意义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++变量的初始化方式]]></title>
    <link href="http://cxh.me/2012/04/09/ways-to-initialize-variables-in-cplusplus/"/>
    <updated>2012-04-09T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/04/09/ways-to-initialize-variables-in-cplusplus</id>
    <content type="html"><![CDATA[<h1></h1>

<p>  写这个问题是受微软今年实习生招聘的一道笔试题启发，上一篇博客好像提到了。之前还真没细想过这些事情。</p>

<p>  首先把需要初始化的成员变量分为几类：</p>

<blockquote><p>一般变量(int)</p>

<p>静态成员变量(static int)</p>

<p>常量(const int )</p>

<p>静态常量(static const int)</p></blockquote>

<p>  对应的初始化方式是：</p>

<blockquote><p>一般变量可以在初始化列表里或者构造函数里初始化，不能直接初始化或者类外初始化</p>

<p>静态成员变量必须在类外初始化</p>

<p>常量必须在初始化列表里初始化</p>

<p>静态常量必须只能在定义的时候初始化</p></blockquote>

<p>  举一个简单的例子</p>

<pre><code>#include 
using namespace std;
class Test
{
private:
    int a;
    static int b;
    const int c;
    static const int d=4;
public:
    Test():c(3)//,a(1)或者在初始化列表里初始化
    {
        a=1;
    }
};
int Test::b=2;
void main()
{
    Test t;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于const和指针的专题]]></title>
    <link href="http://cxh.me/2012/04/07/about-const-and-pointer/"/>
    <updated>2012-04-07T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/04/07/about-const-and-pointer</id>
    <content type="html"><![CDATA[<p>#</p>

<p>  const和指针的问题是笔试里经常出现的问题。这里综合一下各种不同的情况。</p>

<p>  首先是几种const与指针组合的区分，比如：</p>

<pre><code>int b = 500;
const int* a = &amp;b; [1]
int const *a = &amp;b; [2]
int* const a = &amp;b; [3]
const int* const a = &amp;b; [4]
</code></pre>

<p>  [1]和[2]其实是一样的，都是指向int型常量的指针，而[3]是int型常量指针，两者的区别是指向常量的指针本身可以指向别的，所指向的数据不能被修改，而常量指针本身不能被修改。[4]就不用说了，啥都甭想改。</p>

<p>  至于例子，可以举下面的一个例子（以[1]为例）。这里小小的牵扯了一点优先级的问题。</p>

<pre><code>#include
using namespace std;

int main(int argc,char* argv[])
{
int a=1;
const int *b=&amp;a;
*b ;//成立
(*b) ;//编译器错误
}
</code></pre>

<p>  那么我们能不能突破const去修改一个值呢？虽然这件事情本身并没有多大意义，但是还是可以做的。我们可以用const_cast来去掉一个const或者volatile限制。const_cast的作用主要分如下三种：</p>

<blockquote><p>转化一个常量指针为非常量指针</p>

<p>转化一个常量引用为非常量引用</p>

<p>转化一个常量对象为非常量对象</p></blockquote>

<p>  至于例子</p>

<p>  我们举如下一个例子：</p>

<pre><code>#include
using namespace std;

class Test
{
public:
const int a ;
Test(int b):a(b)
{

 }
};

 int main(int argc,char* argv[])
{
Test t(1);
//t.a=2;//出错
int b=const_cast(t.a);
int&amp; c=const_cast(t.a);
int* d=const_cast(&amp;t.a);
b=2;
c=3;
cout
</code></pre>
]]></content>
  </entry>
  
</feed>
