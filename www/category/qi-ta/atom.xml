<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 其他 | CXH.ME]]></title>
  <link href="http://cxh.me/category/qi-ta/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2016-03-28T23:29:27+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[刘鹏《移动时代的营销与变现》笔记]]></title>
    <link href="http://cxh.me/2016/03/28/notes-on-liupeng-report/"/>
    <updated>2016-03-28T23:13:00+08:00</updated>
    <id>http://cxh.me/2016/03/28/notes-on-liupeng-report</id>
    <content type="html"><![CDATA[<p>  上次见刘鹏老师可能还是搜狐实习的时候，后来刘鹏走了，峰扬走了，整个团队改做推荐系统，最后又回到效果广告，算是绕了一个圈吧。买了本计算广告，更多的是给自己一个念想，念念不忘必有回响么。</p>

<p>  主要记录几个知识点或者观点：</p>

<ol>
<li><p> 竞价的历史性作用、gd广告和竞价广告的诞生原因</p>

<pre><code>保量（guarantee delivery）广告相对于品牌广告（CPT），主要解决了流量浪费的问题，CPM的售卖方式相对增加了广告流量的利用率（比如按照性别的售卖，大致可以增加20-25%的收益）。然而保量广告相对来讲对流量的利用并不极致，大部分gd系统都面临超卖或者保守售卖的问题，可能会导致补量或者浪费，在线流量分配和优化也是个比较复杂的问题。所以才有了竞价广告，根据[Nash均衡][1]，广告价格是出价方博弈的结果。这样就可以让广告效益最大化，区分优质流量，同时长尾的流量也有变现的机会。

当然也就引入了程序化交易。程序化交易是工业化的结果，但是对于广告来讲，良莠不齐的广告对于场景融入是非常不利的。程序化交易在移动时代带来了更不好的用户体验。
</code></pre></li>
<li><p> 搜索广告的场景和精妙之处</p>

<pre><code>搜索广告实现了两点最精巧的地方：精确判断用户意图，跟媒体内容完美融入，所以历来是兵家必争之地。
</code></pre></li>
<li><p> 移动广告、gps定位、地理位置</p>

<pre><code>移动时代，广告不能照搬PC时代的经验。移动设备屏幕上广告的体验是很差的。移动时代对于用户意图的判断实际上是更精准了，比如可以通过GPS等判断用户所处的位置，推送更符合场景的广告。但是广告体验就更加困难了，这是有利有弊的地方。
</code></pre></li>
<li><p> O2O是潜在的广告市场</p>

<pre><code>O2O商家是之前几乎不可能成为广告主的一个群体。O2O广告有相当的地域要求，所以对Targeting的要求更高，相对PC时代，移动时代才是O2O广告能发力的地方。智能手机的普及提供了更精准的Targeting，使这部分人群有可能成为潜在广告主。
</code></pre></li>
</ol>


<h3>Bibliography:</h3>

<p>  [1] 怎样向非专业人士专业地解释「纳什均衡」？, <a href="https://www.zhihu.com/question/19804990">https://www.zhihu.com/question/19804990</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[go生成xml的时候特殊字符转义的问题]]></title>
    <link href="http://cxh.me/2016/03/18/go-xml-escape/"/>
    <updated>2016-03-18T17:43:00+08:00</updated>
    <id>http://cxh.me/2016/03/18/go-xml-escape</id>
    <content type="html"><![CDATA[<p>  最近在做http返回的时候发现go的xml生成（marshal）会把引号转义，如下：</p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;

    &lt;Part&gt;
      &lt;PartNumber&gt;1&lt;/PartNumber&gt;
      &lt;LastModified&gt;2016-03-18T08:24:25.000Z&lt;/LastModified&gt;
      &lt;ETag&gt;&amp;#34;0c78aef83f66abc1fa1e8477f296d394&amp;#34;&lt;/ETag&gt;
      &lt;Size&gt;12121&lt;/Size&gt;
    &lt;/Part&gt;     
</code></pre>

<p>  看了下源码，marshal函数的实现就会默认转义。这样就只能加一个Type，不直接用string，然后定义这个Type的marshl函数。上网搜了一下发现可以找个方法绕过去：struct的修饰可以指明当前的struct field不做转义，直接输出。</p>

<pre><code>    type Part struct {
         XMLName      xml.Name `xml:"Part"`
         PartNumber   int
         LastModified string
         ETag         string `xml:",innerxml"`
         Size         int64
    }
</code></pre>

<p>  这样可以直接在序列化的时候传自己拼成的ETag值。比如：</p>

<pre><code>     Part{PartNumber: 1,
         LastModified: S3TimeFormat(GetCurrentTime()),
         ETag:         `&lt;ETag&gt;"acbd18db4cc2f85cedef654fccc4a4d8"&lt;/ETag&gt;`,
         Size:         12121}
</code></pre>

<p>  输出结果满足要求：</p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;

    &lt;Part&gt;
      &lt;PartNumber&gt;1&lt;/PartNumber&gt;
      &lt;LastModified&gt;2016-03-18T08:32:39.000Z&lt;/LastModified&gt;&lt;ETag&gt;"acbd18db4cc2f85cedef654fccc4a4d8"&lt;/ETag&gt;
      &lt;Size&gt;12121&lt;/Size&gt;
    &lt;/Part&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins 安装配置]]></title>
    <link href="http://cxh.me/2015/04/23/jenkins-setup/"/>
    <updated>2015-04-23T13:57:00+08:00</updated>
    <id>http://cxh.me/2015/04/23/jenkins-setup</id>
    <content type="html"><![CDATA[<p>  首先介绍一下Jenkins，如果你熟悉自动化构建的话，那么肯定听说过hudson。Jenkins是hudson的开发者跟Oracle撕bi之后，另立门户的一个hudson分支。当然这么说似乎不太靠谱，目前hudson已经不维护了毕竟，而Jenkins的开发社区还是很活跃的，各种插件层出不穷。总的来说，如果你不是已经习惯了hudson并且有一个能用的副本，都应该迁移到Jenkins。</p>

<p>  下面说一下如何配置。</p>

<p>  Jenkins的安装非常简单，只需要从Jenkins的<a href="https://jenkins-ci.org/" title="Jenkins">主页</a>上下载最新的jenkins.war文件然后运行 java -jar jenkins.war。如果需要配置运行参数可以如下设置一些环境变量。</p>

<pre><code>JENKINS_ROOT=/home/harrychen/share/jenkins
export JENKINS_HOME=$JENKINS_ROOT/jenkins_home
java -jar $JENKINS_ROOT/jenkins.war --httpPort=8080 &gt;&gt;output.log 2&gt;&amp;1 &amp;
</code></pre>

<p>  打开对应url可以看到如下界面</p>

<!--more-->


<p>  <img class="img-polaroid center" src="/images/2015/jenkins.png"></p>

<p>  系统管理里面有一些需要配置的项，比如JDK：</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_jdk.png"></p>

<p>  GIT</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_git.png"></p>

<p>  MAVEN</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_maven.png"></p>

<p>  ssh-key</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_sshkey.png"></p>

<p>  ssh-server</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_sshserver.png"></p>

<p>  装一下slack的插件可以配置slack</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_slack.png"></p>

<p>  然后是建立项目的配置，Jenkins把每个自动发布的项目作为一个单独的配置，主要是如下几个：</p>

<p>  指定代码路径：</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_gitclone.png"></p>

<p>  部署前事件：</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_deploy_pre.png"></p>

<p>  部署后事件:</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_after_deploy.png"></p>

<p>  最后保证这些事件是在之前配置的ssh-server上执行的。</p>

<p>  <img class="img-polaroid center" src="/images/2015/jenkins_enent_server.png"></p>

<p>  细节请看<a href="http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf" title="Jenkins 入门">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[post-review编码问题]]></title>
    <link href="http://cxh.me/2015/04/22/post-review-encoding-problem/"/>
    <updated>2015-04-22T16:08:00+08:00</updated>
    <id>http://cxh.me/2015/04/22/post-review-encoding-problem</id>
    <content type="html"><![CDATA[<p>  windows下post-review遇到一个问题（不是我，不用windows）。python会报错：</p>

<pre><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position xxx: ordinal not in range(128)     
</code></pre>

<p>  又是编码的问题啊，我不想去看post-review的源码，所以还是改默认环境的源码好了。找到rbtools\utils\process.py，import sys后面加两行：</p>

<pre><code>reload(sys)
sys.setdefaultencoding("utf-8") 
</code></pre>

<p>  Ok.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReviewBoard客户端配置和代码review流程]]></title>
    <link href="http://cxh.me/2015/03/29/revreviewboard-specification/"/>
    <updated>2015-03-29T20:17:00+08:00</updated>
    <id>http://cxh.me/2015/03/29/revreviewboard-specification</id>
    <content type="html"><![CDATA[<h2>Postreview 客户端配置</h2>

<p>  reviewboard是群众喜闻乐见的代码review工具。本文主要涉及客户端配置和review流程，server端配置见<a href="http://cxh.me/2015/03/28/review-board-setup/" title="Reviewboard的安装">文档1</a>。</p>

<p>  首先安装python（必须的），之后安装post-review插件:</p>

<pre><code>pip:
    pip install --allow-external RBTools --allow-unverified RBTools RBTools
easy_install：
    easy_install -U RBTools
LinuxRPM:
    sudo yum install RBTools
直接安装：
    git clone git://github.com/reviewboard/rbtools.git
    cd rbtools
    python setup.py
</code></pre>

<p>  旧版的post-review有一个post-review的命令，新的只有rbt了，命令格式不太一样。</p>

<pre><code>post - Posts changes to Review Board
diff - Displays the diff that will be sent to Review Board
land - Lands a change in a local branch or on a review request
patch - Patches your tree with a change on a review request
setup-repo - Sets up RBTools to talk to your repository
</code></pre>

<p>  首先配置review board，HOME目录下简历.reviewboardrc如下：</p>

<pre><code>REVIEWBOARD_URL = 'http://10.16.10.74/'
  REPOSITORY = 'adrd-service'
</code></pre>

<p>  或者在代码目录执行rbt setup-repo，会生成上述文件。REPOSITORY原则上不配置也行。</p>

<h2>PostReview流程。</h2>

<p>　原则上git commit 之后，git push之前要提交post-review，保证代码修改相关人都知悉并ship修改才能提交。基本流程是：</p>

<pre><code>git add xx
git commit -m "message"
rbt post
</code></pre>

<p>  对同一个更改post之后如果要再次修改，可以：</p>

<pre><code>rbt post -r &lt;post_id&gt;
</code></pre>

<p>  post-id是每个post的url/r/后面的数字。post-review标题原则上按照如下规范：</p>

<pre><code>[repository_name][branch_name][NewFeature|BugFix|Refactor|Log] post-review title
</code></pre>

<p>  groups/people添加的人员原则上包括：</p>

<pre><code>1. 技术主管[mentor]
2. 合作者[partner]
2. 其他需要知悉修改的人[related]
</code></pre>

<p>  post-review旧版和svn的整合见<a href="http://cxh.me/2013/10/15/svn-vim-integration/" title="Svn Vim 整合方案">文档2</a>。
  post-review在svn和git同时托管的情况下处理冲突的方法见<a href="http://cxh.me/2013/10/11/post-review-conflict-under-git-svn/" title="Post-review在svn和git共同存在下的冲突问题">文档3</a>。
  一个post-review的vim插件见<a href="http://cxh.me/2014/06/21/ppost-review-plugin/" title="Post-review插件">文档4</a>。</p>

<h3>Bibliography:</h3>

<p>  [1] Reviewboard的安装, <a href="http://cxh.me/2015/03/28/review-board-setup/">http://cxh.me/2015/03/28/review-board-setup/</a></p>

<p>  [2] Svn Vim 整合方案, <a href="http://cxh.me/2013/10/15/svn-vim-integration/">http://cxh.me/2013/10/15/svn-vim-integration/</a></p>

<p>  [3] Post-review在svn和git共同存在下的冲突问题, <a href="http://cxh.me/2013/10/11/post-review-conflict-under-git-svn/">http://cxh.me/2013/10/11/post-review-conflict-under-git-svn/</a></p>

<p>  [4] Post-review插件, <a href="http://cxh.me/2014/06/21/ppost-review-plugin/">http://cxh.me/2014/06/21/ppost-review-plugin/</a></p>
]]></content>
  </entry>
  
</feed>
