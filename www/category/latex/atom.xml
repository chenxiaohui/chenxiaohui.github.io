<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Latex | CXH.ME]]></title>
  <link href="http://cxh.me/category/latex/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-07-15T14:01:51+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[简历生成器（基于moderncv+latex）]]></title>
    <link href="http://cxh.me/2015/06/26/resume-generator-using-latex-and-moderncv/"/>
    <updated>2015-06-26T15:47:00+08:00</updated>
    <id>http://cxh.me/2015/06/26/resume-generator-using-latex-and-moderncv</id>
    <content type="html"><![CDATA[<p>项目地址: <a href="https://github.com/chenxiaohui/resume">https://github.com/chenxiaohui/resume</a></p>

<h1>说明</h1>

<p>通过文本文件生成简历tex的generator。最终生成pdf还是要靠Latex+Moderncv，环境请自行配置。</p>

<ul>
<li>windows下：<a href="http://www.ctex.org/HomePage">http://www.ctex.org/HomePage</a></li>
<li>Linux下：<a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></li>
<li>Mac下：<a href="https://tug.org/mactex/">https://tug.org/mactex/</a></li>
</ul>


<p>需要的包都通过sudo tlmgr install package来安装。字体主要使用了Times New Roman（西文）和 Kaiti SC（中文）。可根据喜好换。</p>

<h1>模板配置</h1>

<p>config.tex 定义了公共头文件，包括包含的宏包，版面的布置和字体语言。</p>

<p>xxtemplate.tex定义了模板。模板语法比较简单，不给出严谨的语法定义了，主要如下两点：</p>

<ol>
<li>%xxx% 表示一个变量，将来会从cv文件中查找对应名字的变量，找到之后替换这个%xxx%</li>
<li><p>%for=>xx% %endfor%表示一个循环，xx是section的name，将来会从cv文件中找到对应的section，然后parse section下的每个单独的项目，用结果替换for循环中的内容</p>

<ol>
<li>for循环中{0}{1}..表示一个for循环变量，cv中section下的条目会被分割成多个变量，顺序依次是0，1，2..，渲染的时候会对应的替换上述{0}{1}变量。如果数量不匹配会报错。</li>
</ol>
</li>
<li><p>如上语法部分关键字可以配置，在config.py中。可以酌情修改。</p></li>
</ol>


<p>xx.cv包含了简历内容，格式上参考了ini文件格式，但是略有不同。</p>

<ol>
<li>[section name]顶一个了一个section，对应简历中一个部分。section name的显示名称是在template里面写好的。这里的name只是给程序使用的，可以跟显示名称一致也可以不同。</li>
<li>不包含在某个section下的条目通过 key = value的方式定义。不能跨行，程序parse的时候只找第一个等号，后面有空格等符号都不影响。</li>
<li>section下的条目每条可以包含多个字段，字段之间默认用竖线（|）分割（可修改）。字段的数量需要跟模板中对应section下for循环体中变量的数量一致。</li>
</ol>


<p>程序中给出了几个实例，分别是英文、中文简历的template和cv文件，供参考。</p>

<h1>使用</h1>

<p>写好对应的cv和模板之后，make就行。open命令可能在mac之外的系统不能使用，建议注掉。</p>

<p>make distclean清空所有文件包括pdf</p>

<p>make again 是为了生成页码，xelatex跑第一遍的时候页码是乱码。</p>

<p>gen.py 文件格式如下：</p>

<pre><code>./gen.py &lt;template-file&gt; &lt;cvfile&gt; &lt;output-file&gt;
</code></pre>

<h1>参考文献:</h1>

<blockquote><p>[1] http moderncv 的笔记（支持中文）, <a href="http://www.xiangsun.org/tex/notes-on-moderncv">http://www.xiangsun.org/tex/notes-on-moderncv</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直接从markdown生成各种电子书]]></title>
    <link href="http://cxh.me/2014/06/21/generate-several-types-using-pandoc/"/>
    <updated>2014-06-21T21:23:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/generate-several-types-using-pandoc</id>
    <content type="html"><![CDATA[<p>  有时候我们需要把编辑的markdown转成各种格式，这不失为一种写书的方式。借助pandoc这把瑞士军刀，我们可以实现一个脚本编译各种格式的功能，代码如下：</p>

<pre><code>#!/usr/bin/python
#coding=utf-8
#Filename:build.py
import glob,os,sys,shutil

cmd_template={'html':"pandoc %s -o output/html/%s.html --template=default.html",
              'pdf':'pandoc -N --toc --template=default.latex --latex-engine=xelatex %s -o output/pdf/%s.pdf',
              'beamer': 'pandoc -N -t beamer --toc --template=default.beamer --latex-engine=xelatex %s -o output/beamer/%s.pdf',
              'epub': 'pandoc %s -o output/epub/%s.epub'
             }

if __name__ == '__main__':
    if len(sys.argv) &gt; 2:
        print 'Usage: build.py [pdf|html|epub|beamer]'
    else:
        out_type = 'html' if len(sys.argv) == 1 else sys.argv[1]
        assert(out_type in cmd_template)

    os.system('cat *.md &gt; swift_book.mkd')
    cmd = [os.system(cmd_template[out_type] %(path, os.path.splitext(path)[0])) for path in glob.glob("*.md")]
    cmd += [os.system(cmd_template[out_type] %('swift_book.mkd', 'swift_book'))]
    print cmd

    if out_type == 'html':
        try:
            shutil.rmtree('output/html/pic')
        except Exception , e:
            pass
        shutil.copytree("pic",'output/html/pic')
</code></pre>

<!--more-->


<p>  为此你需要<a href="http://johnmacfarlane.net/pandoc/installing.html" title="pandoc">安装一下pandoc</a>，需要pdf支持的话还需要<a href="https://www.tug.org/texlive/" title="texlive">装一下texlive</a>，用法如下：</p>

<pre><code>build.py [pdf|html|epub|beamer]

需要如下的目录结构：

    output  - beamer
            - pdf
            - epub
            - html
                - pic
</code></pre>

<p>   另外，脚本会拼一份合集在目录下，所以需要markdown文件有序，比如9.md会拼在10.md后面，所以需要9.md改名为09.md。</p>

<p>  一个使用的例子可以看<a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese" title="The-Swift-Programming-Language-in-Chinese">这里</a>。那些template都是模板文件，可以参考上面例子里的。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] The-Swift-Programming-Language-in-Chinese, <a href="https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese">https://github.com/letsswift/The-Swift-Programming-Language-in-Chinese</a></p>

<p>[2] pandoc, <a href="http://johnmacfarlane.net/pandoc/">http://johnmacfarlane.net/pandoc/</a></p>

<p>[3] pandoc, <a href="http://johnmacfarlane.net/pandoc/installing.html">http://johnmacfarlane.net/pandoc/installing.html</a></p>

<p>[4] texlive, <a href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决Latex中Itemize距离过大的问题]]></title>
    <link href="http://cxh.me/2012/03/16/solve-the-problem-of-too-large-space-between-itemize-in-Latex/"/>
    <updated>2012-03-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/03/16/solve-the-problem-of-too-large-space-between-itemize-in-Latex</id>
    <content type="html"><![CDATA[<p>  默认的itemize存在行距过大的问题，大概是如下的样子：</p>

<p><img src="http://www.roybit.com/wp-content/uploads/2012/03/image_thumb2.png" title="image" alt="image" /></p>

<p>  用paralist包可以减少行距，代码如下</p>

<blockquote><p>\usepackage{paralist}
\let\itemize</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两种可行的Latex中文生成方式(GBK/UTF8)]]></title>
    <link href="http://cxh.me/2012/03/15/two-ways-to-generate-chinese-in-Latex/"/>
    <updated>2012-03-15T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/03/15/two-ways-to-generate-chinese-in-Latex</id>
    <content type="html"><![CDATA[<h1></h1>

<p>  本来想总结一下Latex里各种中文排版支持，但是发现太乱了，CCT，CJK，CTEX神马的，还有GBK和UTF8下的不同编码方式，再加上XeLatex这样来搅局的……所以最后决定只给出一种可行的排版方式，测试环境是Windows CTex2.8。</p>

<p>  ps:每天忍辱负重的在Windows下用Vim和Latex……</p>

<p>  第一种是gbk编码下的编译方式</p>

<pre><code>REM taskkill /im AcroRd32.exe
pdflatex %1
bibtex %1
pdflatex %1
gbk2uni %1.out
pdflatex %1
start %1.pdf
</code></pre>

<p>  其中第一句的目的是结束掉当前的PDF文档，但是它会随机选择一个Acrobat Reader进程结束，所以给注掉了。从代码里可以看出，需要执行多遍pdflatex，同时穿插bibtex生成参考文件，gbk2uni的作用是将gbk转成unicode，这个命令是cct里的，请确保你的环境变量中有cct的bin目录。</p>

<p>  测试article代码如下：</p>

<pre><code>\documentclass{article}
\usepackage{CJK}
\usepackage{cite}
ewcommand{\upcite}[1]{ extsuperscript{ extsuperscript{
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Latex中使用visio的矢量图(转载+修改）]]></title>
    <link href="http://cxh.me/2012/03/14/using-visio-vector-diagram-in-Latex/"/>
    <updated>2012-03-14T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/03/14/using-visio-vector-diagram-in-Latex</id>
    <content type="html"><![CDATA[<h1></h1>

<p>  我们知道，visio用来画流程图等专业图很方便，而Latex的专业排版效果是Word所不能比的，而Visio不支持导入eps和dvi格式的矢量图，而导出jpeg毕竟有质量损失，那么怎么才能在Latex中直接使用visio导出的矢量图呢？</p>

<p>1. Visio可以保存为wmf，emf等矢量图形格式（word的默认插图格式），再转换为eps格式（可使用TpX，由本论坛得知早期版本貌似可直接保存eps）插入LaTeX。可转换后的eps图片格式不稳定，图形易错位；另外Visio使用Windows字体，转换后的eps图形只引用而不包含字体，插入LaTex后由于找不到对应字体，中文（或mathtype公式，特殊符号）会乱码。
2. 用ps虚拟打印的方式虽然可以解决格式和乱码问题，但中文字符（或其他不支持的内容）会按位图处理，得不到完美的矢量图形。</p>

<p>  经过探索，将visio保存为pdf格式是最完美的解决方式，因为pdf文件保存了所有格式和字体信息。借助pdfcrop和ebb程序，调用graphicx宏包插入pdf格式图片，能够得到完美的visio矢量图形。</p>

<p>注：
1.导入的代码依然可以使用标准的fig标签，例如：
egin{figure}</p>
]]></content>
  </entry>
  
</feed>
