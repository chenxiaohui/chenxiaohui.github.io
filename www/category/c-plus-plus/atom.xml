<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-10-29T21:32:26+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[虚函数模板和模板类中的虚函数]]></title>
    <link href="http://cxh.me/2014/10/29/cpp-virtual-template-function/"/>
    <updated>2014-10-29T21:05:00+08:00</updated>
    <id>http://cxh.me/2014/10/29/cpp-virtual-template-function</id>
    <content type="html"><![CDATA[<p>  自从知道了C++不支持虚函数模板之后就觉得相关的一概不支持，今天写程序的时候想把基类做成模板，然后继承基类。以为也不支持，写了一下才发现支持的，无论是非模板类继承一个特化之后的模板还是模板类继承包含虚函数的模板基类都是没问题的。从实现上看，反正使用的时候都会特化的，特化之后虚函数表指针是固定的。不存在像函数模板这种类生成的时候无法确定虚函数表的情况。</p>

<p>  例子如下：</p>

<!--more-->


<pre><code>enum SessionType
{
  ROSession,
  RWSession,
  RPSession
};
class BaseTransCtx
{
  public:
    BaseTransCtx (){}
    virtual ~BaseTransCtx (){}
};
template&lt;typename Type&gt;
class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
typedef ISessionCtxFactory&lt;SessionType&gt; SessionMgr;
class TransSessionMgr: public SessionMgr
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    BaseTransCtx *alloc(const SessionType type)
    {
      return NULL;
    }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
int main(int argc, const char *argv[])
{
  TransSessionMgr trans;
  BaseTransCtx* ctx = trans.alloc(RWSession);
  trans.free(ctx);
  return 0;
}
</code></pre>

<p>  模板类继承虚基类也可以。</p>

<pre><code>template&lt;typename Type&gt;
class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
template&lt;typename Type&gt;
class TransSessionMgr: public ISessionCtxFactory&lt;Type&gt;
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    BaseTransCtx *alloc(const Type type)
    {
      return NULL;
    }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
</code></pre>

<p>  但是这样就不行了</p>

<pre><code>class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    template&lt;typename Type&gt;
      virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
class TransSessionMgr: public ISessionCtxFactory
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    template&lt;typename Type&gt;
      BaseTransCtx *alloc(const Type type)
      {
        return NULL;
      }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[澄清几个关于C++继承的问题]]></title>
    <link href="http://cxh.me/2014/10/28/cpp-derive-problems/"/>
    <updated>2014-10-28T15:56:00+08:00</updated>
    <id>http://cxh.me/2014/10/28/cpp-derive-problems</id>
    <content type="html"><![CDATA[<p>  之前讨论编码规范的时候遇到过一个问题，继承的类覆盖基类的虚函数，不写virtual关键字是否依然有覆盖（override)的效果。是个基础问题，但是大家的理解好像都不一样。验证如下：</p>

<pre><code>#include &lt;stdio.h&gt;
class Base
{
  public:
    Base (){}
    virtual ~Base (){}
    virtual void print() {printf("Base\n");}
};

class Middle : public Base
{
  public:
    Middle(){}
    virtual ~Middle(){}
    void print() {printf("Middle\n");}
};

class Derived : public Middle
{
  public:
    Derived(){}
    virtual ~Derived(){}
    void print() {printf("Derived\n");}
};

int main(int argc, const char *argv[])
{
  Base * p = NULL;
  Base b;
  Middle m;
  Derived d;
  p = &amp; b;
  p-&gt;print();
  p = &amp; m;
  p-&gt;print();
  p = &amp; d;
  p-&gt;print();
  return 0;
}
</code></pre>

<!--more-->


<p>  结果是</p>

<pre><code>Base
Middle
Derived
</code></pre>

<p>  可见只要定义了virtual关键字，在整个继承体系中这个函数都会成为虚函数。第二个问题是作为一个中间类（Middle)不想覆盖基类的虚函数，默认的情况下有什么影响。猜想应该就默认用了基类的虚函数。不影响后面的继承关系。注释掉Middle的print函数实现。结果如下：</p>

<pre><code>Base
Base
Derived
</code></pre>

<p>  跟预想一致。水文一篇，可忽略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[析构函数和成员析构的先后顺序]]></title>
    <link href="http://cxh.me/2014/10/22/destruct-and-member-destruct/"/>
    <updated>2014-10-22T17:57:00+08:00</updated>
    <id>http://cxh.me/2014/10/22/destruct-and-member-destruct</id>
    <content type="html"><![CDATA[<p>  肖总问到这个问题，写了个程序验证：</p>

<pre><code>class Member
{
 public:
   Member (){}
   virtual ~Member (){printf("member destruct\n");}
};
class Base
{
  public:
    Base (){}
    virtual ~Base (){ printf("destruct\n");}
  private:
    Member member_;
};
int main(int argc, const char *argv[])
{
  Base c;
  return 0;
}
</code></pre>

<p>  结果是：</p>

<pre><code>  destruct
  member destruct
</code></pre>

<p>  可见析构的时候先调用析构函数，最后析构成员对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《改善C++程序的150个建议》勘误]]></title>
    <link href="http://cxh.me/2014/09/06/error-in-cpp-150-notes/"/>
    <updated>2014-09-06T11:41:00+08:00</updated>
    <id>http://cxh.me/2014/09/06/error-in-cpp-150-notes</id>
    <content type="html"><![CDATA[<p>  翻了一下编写高质量代码：改善C++程序的150个建议，感觉一般，主要是能下到pdf。看到两个错误。</p>

<p>  第一个错误是内存池的那里，内部类使用了外部类的成员变量，这是C++啊，不是java，内部类默认不持有外部类指针。</p>

<pre><code>class MemPool
{
  public:
    MemPool (int nItemSize, int nMemBlockSize = 2048):
      m_nItemSize(nItemSize),
      m_nMemBlockSize(nMemBlockSize),
      m_pMemBlockHeader(NULL),
      m_pFreeNodeHeader(NULL)
    {}
    virtual ~MemPool (){}
    void * Alloc();
    void Free();
  private:
    /* data */
    const int m_nMemBlockSize;
    const int m_nItemSize;
    struct _FreeNode
    {
      _FreeNode* pPrev;
      char data[m_nItemSize - sizeof(_FreeNode*)];
    };
    struct _MemBlock
    {
      _MemBlock * pPrev;
      _FreeNode data[m_nMemBlockSize/m_nItemSize];
    };
    _MemBlock* m_pMemBlockHeader;
    _FreeNode* m_pFreeNodeHeader;
};
</code></pre>

<p>  第二个错误是作者强调nocopyable基类是需要私有继承的，其实不需要，public继承足够了，public继承又不会把基类的private成员继承下来。</p>

<pre><code>class nocopyable
{
  public:
    nocopyable (){}
    virtual ~nocopyable (){}

  private:
    /* data */
    nocopyable (const nocopyable&amp;);
    nocopyable&amp; operator=(const nocopyable&amp;);
};
class Base : public nocopyable
</code></pre>

<p>  太tm不严谨了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++的限制拷贝]]></title>
    <link href="http://cxh.me/2014/08/24/no-copy-restrict/"/>
    <updated>2014-08-24T12:44:00+08:00</updated>
    <id>http://cxh.me/2014/08/24/no-copy-restrict</id>
    <content type="html"><![CDATA[<p>  如果需要禁止一个类的拷贝（多鉴于RAII的资源类），按习惯我们会把拷贝构造函数和赋值运算符重载设置为私有的。比如：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base (){}

  private:
    Base(const Base&amp; b)
    Base &amp; operator=(const Base&amp; b)
};

int main(int argc, const char *argv[])
{
  Base b(1);//ok
  Base c=1;//error[1]
  Base d=c;//error
  c = d;//error
  return 0;
}
</code></pre>

<p>  但是问题在于[1]这里没有道理被屏蔽掉，应该会被优化成Base c(1)。如下代码可以证明：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base ()
    {
    }
    Base(const Base&amp; b)
    {
      cout&lt;&lt;"copy consturct" &lt;&lt;endl;
    }
};

int main(int argc, const char *argv[])
{
  Base c=1;
  return 0;
}
</code></pre>

<p>  运行结果：</p>

<pre><code>construct
</code></pre>

<p>  后来我试了一下才发现，首先这个优化是编译器层面的，所以不同的编译器处理应该是不一样的，虽然我们见到的编译器应该都支持。其次这个优化不是语法检查前做的，也就意味着，在<strong>构造函数没有被声明为explicit的时候</strong>，语法检查会把这个认为是先做了类型转换，然后调用拷贝构造函数，也就是如下：</p>

<pre><code>Base c = Base(1);
</code></pre>

<p>  这就在编译的时候报错了。</p>
]]></content>
  </entry>
  
</feed>
