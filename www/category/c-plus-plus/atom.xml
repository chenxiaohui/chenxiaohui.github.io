<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-10-20T15:37:52+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《改善C++程序的150个建议》勘误]]></title>
    <link href="http://cxh.me/2014/09/06/error-in-cpp-150-notes/"/>
    <updated>2014-09-06T11:41:00+08:00</updated>
    <id>http://cxh.me/2014/09/06/error-in-cpp-150-notes</id>
    <content type="html"><![CDATA[<p>  翻了一下编写高质量代码：改善C++程序的150个建议，感觉一般，主要是能下到pdf。看到两个错误。</p>

<p>  第一个错误是内存池的那里，内部类使用了外部类的成员变量，这是C++啊，不是java，内部类默认不持有外部类指针。</p>

<pre><code>class MemPool
{
  public:
    MemPool (int nItemSize, int nMemBlockSize = 2048):
      m_nItemSize(nItemSize),
      m_nMemBlockSize(nMemBlockSize),
      m_pMemBlockHeader(NULL),
      m_pFreeNodeHeader(NULL)
    {}
    virtual ~MemPool (){}
    void * Alloc();
    void Free();
  private:
    /* data */
    const int m_nMemBlockSize;
    const int m_nItemSize;
    struct _FreeNode
    {
      _FreeNode* pPrev;
      char data[m_nItemSize - sizeof(_FreeNode*)];
    };
    struct _MemBlock
    {
      _MemBlock * pPrev;
      _FreeNode data[m_nMemBlockSize/m_nItemSize];
    };
    _MemBlock* m_pMemBlockHeader;
    _FreeNode* m_pFreeNodeHeader;
};
</code></pre>

<p>  第二个错误是作者强调nocopyable基类是需要私有继承的，其实不需要，public继承足够了，public继承又不会把基类的private成员继承下来。</p>

<pre><code>class nocopyable
{
  public:
    nocopyable (){}
    virtual ~nocopyable (){}

  private:
    /* data */
    nocopyable (const nocopyable&amp;);
    nocopyable&amp; operator=(const nocopyable&amp;);
};
class Base : public nocopyable
</code></pre>

<p>  太tm不严谨了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++的限制拷贝]]></title>
    <link href="http://cxh.me/2014/08/24/no-copy-restrict/"/>
    <updated>2014-08-24T12:44:00+08:00</updated>
    <id>http://cxh.me/2014/08/24/no-copy-restrict</id>
    <content type="html"><![CDATA[<p>  如果需要禁止一个类的拷贝（多鉴于RAII的资源类），按习惯我们会把拷贝构造函数和赋值运算符重载设置为私有的。比如：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base (){}

  private:
    Base(const Base&amp; b)
    Base &amp; operator=(const Base&amp; b)
};

int main(int argc, const char *argv[])
{
  Base b(1);//ok
  Base c=1;//error[1]
  Base d=c;//error
  c = d;//error
  return 0;
}
</code></pre>

<p>  但是问题在于[1]这里没有道理被屏蔽掉，应该会被优化成Base c(1)。如下代码可以证明：</p>

<pre><code>class Base
{
  public:
    Base (int a)
    {
      cout &lt;&lt;"construct"&lt;&lt;endl;
    }
    virtual ~Base ()
    {
    }
    Base(const Base&amp; b)
    {
      cout&lt;&lt;"copy consturct" &lt;&lt;endl;
    }
};

int main(int argc, const char *argv[])
{
  Base c=1;
  return 0;
}
</code></pre>

<p>  运行结果：</p>

<pre><code>construct
</code></pre>

<p>  后来我试了一下才发现，首先这个优化是编译器层面的，所以不同的编译器处理应该是不一样的，虽然我们见到的编译器应该都支持。其次这个优化不是语法检查前做的，也就意味着，在<strong>构造函数没有被声明为explicit的时候</strong>，语法检查会把这个认为是先做了类型转换，然后调用拷贝构造函数，也就是如下：</p>

<pre><code>Base c = Base(1);
</code></pre>

<p>  这就在编译的时候报错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c/c++的不定参数]]></title>
    <link href="http://cxh.me/2014/07/17/c-variable-argument/"/>
    <updated>2014-07-17T14:42:00+08:00</updated>
    <id>http://cxh.me/2014/07/17/c-variable-argument</id>
    <content type="html"><![CDATA[<p>  c/c++可以通过va_arg等宏实现不定参数。一个例子如下(c++)：</p>

<pre><code>void ar_cnt(int cnt,...);
int main(int argc, char* argv[])
{
    ar_cnt(4,1,2,3,4);
    return 0; 
}
void ar_cnt(int cnt,...)
{
    int arg_cnt = cnt;
    va_list arg_ptr;
    va_start(arg_ptr, cnt);
    for(int i=0; i &lt; cnt;i++)
    {
        int value=va_arg(arg_ptr,int);
        printf("posation %d=%d\n", value, i+1);
    }
    va_end(arg_ptr);
}
</code></pre>

<p>  其实原理是比较简单的，依赖于编译器对函数调用的压栈顺序，但是目测现有的调用方式压栈都是从右向左，所以va_start定位第一个参数的位置，va_arg每次在之前的位置上加一个偏移值，从而得到每个传入参数。这就是说va_start要求传入不定参数的函数不能只传入一个&hellip;，至少要有一个固定的参数，用来获取栈指针位置。</p>

<!--more-->


<p>  调用方式这个东西好像只有在VC里才探讨，不太清楚gcc这里的处理是怎么样的，vc下主要分了如下几种：</p>

<ul>
<li><p>STDCALL/PASCAL/WINAPI/CALLBACK</p>

<ol>
<li>参数从右向左压入堆栈</li>
<li>函数自身修改堆栈</li>
<li>函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li>
</ol>
</li>
<li><p>CDECL</p>

<ol>
<li>调用约定的参数压栈顺序是和stdcall是一样的，参数由右向左压入堆栈。</li>
<li>调用者负责清理堆栈。</li>
<li>由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。</li>
</ol>
</li>
<li><p>FASTCALL</p>

<ol>
<li>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</li>
<li>被调用函数清理堆栈</li>
<li>函数名修改规则同stdcall</li>
</ol>
</li>
<li><p>THISCALL</p>

<ol>
<li>参数从右向左入栈</li>
<li>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li>
</ol>
</li>
<li><p>NAKEDCALL</p>

<ol>
<li>这是一个很少见的调用约定，一般程序设计者建议不要使用。</li>
<li>编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果</li>
<li>这一般用于实模式驱动程序设计</li>
</ol>
</li>
</ul>


<h3>参考文献:</h3>

<blockquote><p>[1] cdecl、stdcall、fastcall函数调用约定区别 , <a href="http://blog.csdn.net/fly2k5/article/details/544112">http://blog.csdn.net/fly2k5/article/details/544112</a></p>

<p>[2] 函数调用的区别：<em>cdecl以及</em>stdcall, <a href="http://www.cppblog.com/kenny/archive/2011/04/19/144539.html">http://www.cppblog.com/kenny/archive/2011/04/19/144539.html</a></p>

<p>[3] 透析C语言可变参数问题, <a href="http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html">http://www.cnblogs.com/wangyonghui/archive/2010/07/12/1776068.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java/c++变量作用域的一点小区别]]></title>
    <link href="http://cxh.me/2014/07/17/java-c-plus-plus-variable-scope-diff/"/>
    <updated>2014-07-17T11:16:00+08:00</updated>
    <id>http://cxh.me/2014/07/17/java-c-plus-plus-variable-scope-diff</id>
    <content type="html"><![CDATA[<p>  偶然遇到一个问题，java里面这么写是有问题的</p>

<pre><code>int x = 1;
    {
        int x = 2;
    }
</code></pre>

<p>  作为一个写了多年C++的人，不能忍啊。java子域里的变量看样子不会覆盖父域。但是这样是没问题的，可见子域的生命周期还是局限于子域里面。</p>

<pre><code>    {
        int x = 2;
    }
int x = 1;
</code></pre>

<p>  C++里面这样是没问题的</p>

<pre><code>  int x = 1 ;
  {
    int x  = 2;
  }
</code></pre>

<p>  相对于脚本语言，这种限制似乎就宽多了。这样都可以。</p>

<pre><code>for i in range(1,10):
    pass
print i
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[命名空间和友元冲突]]></title>
    <link href="http://cxh.me/2014/07/10/namespace-conflicts-with-friend/"/>
    <updated>2014-07-10T19:09:00+08:00</updated>
    <id>http://cxh.me/2014/07/10/namespace-conflicts-with-friend</id>
    <content type="html"><![CDATA[<p>  今天遇到一个问题，需要跨namespace定义友元，这种情况比较常见的是测试类需要访问源码类，gtest据说有个FRIEND_TEST宏，以前用过好像有问题。这里我们直接用友元:</p>

<pre><code>namespace oceanbase
{
    namespace election
    {
        class ObElectionServer : public ObSingleServer
        {
            friend class ObElectionTester;
            ...
        }
    }
}
namespace oceanbase
{
  namespace tests
  {
    namespace election
    {
        class ObElectionTester : public ObElectionServer
        {
            ...
        }
    }
}
</code></pre>

<p>  这样是肯定不行的，这等于告诉ObElectionServer在自己的namespace下找ObElectionTester。改成如下：</p>

<!--more-->


<pre><code>namespace oceanbase
{
    namespace election
    {
        class ObElectionServer : public ObSingleServer
        {
            friend class oceanbase::tests::election::ObElectionTester;
            ...
        }
    }
}
</code></pre>

<p>  这样也不行，ObElectionServer不知道ObElectionTester是个包含namespace的类名。所以我们需要前向声明一下类。</p>

<pre><code>namespace oceanbase
{
  namespace tests
  {
    namespace election
    {
      class ObElectionTester;
    }
  }
  namespace election
  {
    class ObElectionServer : public ObSingleServer
    {
        friend class oceanbase::tests::election::ObElectionTester;
        ....
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
