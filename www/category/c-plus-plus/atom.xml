<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-07-13T16:13:30+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[命名空间和友元冲突]]></title>
    <link href="http://cxh.me/2014/07/10/namespace-conflicts-with-friend/"/>
    <updated>2014-07-10T19:09:00+08:00</updated>
    <id>http://cxh.me/2014/07/10/namespace-conflicts-with-friend</id>
    <content type="html"><![CDATA[<p>  今天遇到一个问题，需要跨namespace定义友元，这种情况比较常见的是测试类需要访问源码类，gtest据说有个FRIEND_TEST宏，以前用过好像有问题。这里我们直接用友元:</p>

<pre><code>namespace oceanbase
{
    namespace election
    {
        class ObElectionServer : public ObSingleServer
        {
            friend class ObElectionTester;
            ...
        }
    }
}
namespace oceanbase
{
  namespace tests
  {
    namespace election
    {
        class ObElectionTester : public ObElectionServer
        {
            ...
        }
    }
}
</code></pre>

<p>  这样是肯定不行的，这等于告诉ObElectionServer在自己的namespace下找ObElectionTester。改成如下：</p>

<!--more-->


<pre><code>namespace oceanbase
{
    namespace election
    {
        class ObElectionServer : public ObSingleServer
        {
            friend class oceanbase::tests::election::ObElectionTester;
            ...
        }
    }
}
</code></pre>

<p>  这样也不行，ObElectionServer不知道ObElectionTester是个包含namespace的类名。所以我们需要前向声明一下类。</p>

<pre><code>namespace oceanbase
{
  namespace tests
  {
    namespace election
    {
      class ObElectionTester;
    }
  }
  namespace election
  {
    class ObElectionServer : public ObSingleServer
    {
        friend class oceanbase::tests::election::ObElectionTester;
        ....
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于备份文件管理]]></title>
    <link href="http://cxh.me/2014/07/04/backup-file-management/"/>
    <updated>2014-07-04T11:20:00+08:00</updated>
    <id>http://cxh.me/2014/07/04/backup-file-management</id>
    <content type="html"><![CDATA[<p>  最近在写一个备份的工作，备份线程每次会把需要备份的数据写到文件，同时需要保存一定数量的旧文件。</p>

<p>  首先为了写失败的时候不会损坏之前的旧备份文件，我们需要写一个临时文件然后覆盖回去。同时，为了保存旧文件，需要每次写一个不同的文件，同时维护一个当前的最新文件，然后删除超过了一定期限的文件，假定临时文件名是file.bin.2014xxxx，最新文件名是file.bin，有如下三个方法：</p>

<ol>
<li> 每次写临时文件，同时写一个内容一样的file.bin。造成空间浪费。</li>
<li> 每次写临时文件，同时更新软链接file.bin。不兼容非linux系统。</li>
<li> 写manifest，文件内容是当前最新文件名。比较麻烦。</li>
</ol>


<p>  最后还是按2方案实现的，代码如下：</p>

<!--more-->


<pre><code>int overwrite_tmp_file(const char * filename, const int64_t version)
{
  char tmp_path[OB_MAX_FILE_NAME_LENGTH] ={'\0'};
  int ret = OB_SUCCESS;
  if (filename == NULL)
  {
    ret = OB_INVALID_ARGUMENT;
  }
  else
  {
    char time_str[OB_MAX_TIME_STR_LENGTH] = {'\0'};
    tbsys::CTimeUtil::timeToStr(ObTimeUtility::extract_second(version), time_str);
    int len = snprintf(tmp_path, sizeof(tmp_path), "%s.%s", filename, time_str);
    if (0 &gt; len || len &gt;= static_cast&lt;int32_t&gt;(sizeof(tmp_path)))
    {
      ret = OB_ERR_UNEXPECTED;
      TBSYS_LOG(WARN, "No file name specified!");
    }
    else
    {
      struct stat buf;
      if (0 == lstat(filename, &amp;buf))
      {
        if (0 != ::unlink(filename))
        {
          TBSYS_LOG(WARN, "fail to remove old file, msg: [%s]", strerror(errno));
          ret = OB_ERR_SYS;
        }
      }
      if (OB_SUCCESS == ret)
      {
        if (0 != ::symlink(basename(tmp_path), filename))
        {
          TBSYS_LOG(WARN, "fail to link backup file, msg: [%s]", strerror(errno));
          ret = OB_ERR_SYS;
        }
        else if (OB_SUCCESS != clean_old_files(filename))//do not need to return error
        {
          TBSYS_LOG(WARN, "failed to remove old files");
        }
      }
    }
  }
  return ret;
}


const static int64_t KEEP_FILE_RANGE = 3600 * 24 * 7;//7d,unit:s

int clean_old_files(const char * filename)
{
  int ret = OB_SUCCESS;
  if (filename == NULL)
  {
    ret = OB_INVALID_ARGUMENT;
  }
  else
  {
    char tmp_path[OB_MAX_FILE_NAME_LENGTH] ={'\0'};
    glob_t globbuf;
    globbuf.gl_offs = 0;
    int len = snprintf(tmp_path, sizeof(tmp_path), "%s.*", filename);
    if (len &lt; 0 || len &gt;= static_cast&lt;int32_t&gt;(sizeof(tmp_path)))
    {
      ret = OB_ERR_UNEXPECTED;
    }
    else if (0 != glob(tmp_path, GLOB_DOOFFS, NULL, &amp;globbuf))
    {
      ret = OB_ERR_SYS;
    }
    else
    {
      int64_t cur_time = ObTimeUtility::extract_second(tbsys::CTimeUtil::getTime());
      for(unsigned int i = 0; i &lt; globbuf.gl_pathc; ++i)
      {
        int64_t version = tbsys::CTimeUtil::strToTime(globbuf.gl_pathv[i] + strlen(filename) + 1);
        if (cur_time - version &gt; KEEP_FILE_RANGE)
        {
          //delete file
          if (0 != unlink(globbuf.gl_pathv[i]))
          {
            TBSYS_LOG(WARN, "fail to remove old file, msg: [%s]", strerror(errno));
          }
        }
      }
    }
    globfree(&amp;globbuf);
  }
  return ret;
}
</code></pre>

<p>  需要注意的大概只有软连接文件属性获取是lstat而不是stat。另外，由于子文件夹的存在，建立软链接的symlink参数需要指定相对路径，也就是说，如果我们要让etc目录下的file.bin指向file.bin.2014xxxx，需要：</p>

<pre><code>ln -s file.bin etc/file.bin.2014xxx
</code></pre>

<p>  而不是</p>

<pre><code>ln -s etc/file.bin etc/file.bin.2014xxx  
</code></pre>

<p>  上面会导致链接文件指向etc/etc/file.bin.2014xxx而失效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NVI的应用-虚函数模板]]></title>
    <link href="http://cxh.me/2014/07/01/nvi-usage-of-virtual-template/"/>
    <updated>2014-07-01T14:52:00+08:00</updated>
    <id>http://cxh.me/2014/07/01/nvi-usage-of-virtual-template</id>
    <content type="html"><![CDATA[<p>  我们有时候需要把一个模板函数实现为虚函数，但是C++不支持模板虚函数（至少目前是），所以需要一些方法绕过去。以下是郁白师兄提供的解决方案，确实比较巧妙，之前没想过NVI（NonVirtual Interface）能解决这个问题。</p>

<pre><code>class IAllocator
{
  public:
    virtual ~IAllocator() {};
    virtual void *alloc(const int64_t size) = 0;
};
template &lt;class T&gt;
class TAllocator : public IAllocator
{
  public:
    TAllocator(T &amp;allocator) : allocator_(allocator) {};
    void *alloc(const int64_t size) {return allocator_.alloc(size);};
  private:
    T &amp;allocator_;
};

class Base
{
  public:
    virtual ~Base() {};
  public:
    template &lt;class Allocator&gt;
    void get_number(Allocator &amp;allocator)
    {
      TAllocator&lt;Allocator&gt; ta(allocator);
      this-&gt;get_number_(ta);
    };
  private:
    virtual void get_number_(IAllocator &amp;allocator) = 0;
};

class Sub1 : public Base
{
  private:
    void get_number_(IAllocator &amp;allocator)
    {
      allocator.alloc(1);
      fprintf(stdout, "sub1::get_number_ invoked\n");
    };
};

class Sub2 : public Base
{
  private:
    void get_number_(IAllocator &amp;allocator)
    {
      allocator.alloc(1);
      fprintf(stdout, "sub2::get_number_ invoked\n");
    };
};

class PA
{
  public:
    void *alloc(const int64_t sz)
    {
      fprintf(stdout, "pa::alloc sz=%ld\n", sz);
      return NULL;
    };
};

int main()
{
  Sub1 s1;
  Sub2 s2;
  PA pa;

  s1.get_number(pa);
  s2.get_number(pa);
}
</code></pre>

<p>  主要思想是把模板特化，特化之后的函数实现虚函数，把模板遵循的规则转化到继承体系，让一个实例化的模板参数遵循Interface的接口要求。所以TAllocator这个Wrapper至关重要。</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 【C++程序设计技巧】NVI（Non-Virtual Interface ）, <a href="http://www.cnblogs.com/gnuhpc/archive/2012/01/17/2324836.html">http://www.cnblogs.com/gnuhpc/archive/2012/01/17/2324836.html</a></p>

<p>[2] 纯虚函数能为private吗？, <a href="http://www.cppblog.com/zhuweisky/archive/2005/09/14/269.html">http://www.cppblog.com/zhuweisky/archive/2005/09/14/269.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个关于宏的问题]]></title>
    <link href="http://cxh.me/2014/06/26/a-macro-problem/"/>
    <updated>2014-06-26T10:53:00+08:00</updated>
    <id>http://cxh.me/2014/06/26/a-macro-problem</id>
    <content type="html"><![CDATA[<p>  写了一段代码，我想实现宏里面拼接一个变量然后取得这个变量的值的效果，但是没有成功：</p>

<pre><code>#define OB_FIRST_ROOT_TABLE_TID 21
#define OB_INVALID_ID INT_MAX
const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";

struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};


#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from "#table_name)
#define TABLE_BACKUP(table_prefix)\
TABLE_BACKUP_(table_prefix, table_prefix##_TABLE_NAME)

TableBackupSQL table_backup_list_[] =
{
  TABLE_BACKUP(OB_FIRST_ROOT_TABLE)
};


int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/sizeof(TableBackupSQL); i++)
  {
    TableBackupSQL&amp; desc = table_backup_list_[i];
    printf("%d, %s, %s\n", desc.table_id_, desc.table_name_, desc.sql_);
  }
}
</code></pre>

<p>  期望的结果是</p>

<pre><code>21, __first_root_table, select * from __first_root_table
</code></pre>

<p>  实际的结果是</p>

<pre><code>21, __first_root_table, select * from OB_FIRST_ROOT_TABLE_TABLE_NAME
</code></pre>

<!--more-->


<p>  拼出来的OB_FIRST_ROOT_TABLE_TABLE_NAME没有被替换，当然有很多方法绕开。我试图两次展开宏但是没有成功，这个跟<a href="http://blog.csdn.net/maray/article/details/11096459" title="介绍一个C++奇巧淫技">这里</a>说的问题毕竟不是一个。不知道C++11里面有没有解决方法。</p>

<p>  另外，我才发现一个struct直接赋值是C++11才允许的。比如：</p>

<pre><code>TableBackupSQL table_backup_list_[] =
{
  {21, "__first_root_table", "select * from __first_root_table"}
};
</code></pre>

<p>  不加-std=c++0x或者 -std=gnu++0x的时候会报错。c语言支持。</p>

<p>  后来发现我遗忘了一个事实，宏替换是发生在预编译期的，这时候都没有做语法词法分析，程序不知道一个变量应该如何替换，所以变量实际上没有被替换成值，这跟函数定义是不一样的。比如：</p>

<pre><code>#define wrap(value) value
int a  = 1;
int b = wrap(a);
</code></pre>

<p>  我们用gcc打印展开之后的结果如下：</p>

<pre><code>int a = 1;
int b = a;
</code></pre>

<p>  这里是不会展开成 int b = 1;的。而连接符#的作用也只是把宏替换后的字面值加上引号，比如：</p>

<pre><code>#define wrap(value) #value
int a  = 1;
const char * b = wrap(a);
</code></pre>

<p>  展开结果是：</p>

<pre><code>int a = 1;
const char * b = "a";
</code></pre>

<p>  而连接符##的作用就更简单了，就是提供一个标示宏传入参数的作用，比如</p>

<pre><code>#define wrap(value) a##value
int ab = 2;
int b = wrap(b);
</code></pre>

<p>  如果不写##就变成了avalue，无法区分输入参数，如果写a(value)就会替换成a(b),如果写a value就会替换成a b，所以想替换成ab只能用##。</p>

<p>  至于上面那个问题，如果我们table的名字都是宏定义的字符串，那就好办多了：</p>

<pre><code>const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";
#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from " table_name)
</code></pre>

<p>  感谢郁白师兄的指导。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本文件和二进制文件读写]]></title>
    <link href="http://cxh.me/2014/06/21/bin-txt-file-read-write/"/>
    <updated>2014-06-21T12:28:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/bin-txt-file-read-write</id>
    <content type="html"><![CDATA[<p>  探究这个的起因是我在序列化一个数据结构，用二进制写到文件之后用vim打开发现后面居然多了一个值。</p>

<p><img class="img-polaroid center" src="/images/2014/binfile.png" title="&ldquo;用vim显示二进制文件&rdquo; &ldquo;用vim显示二进制文件&rdquo;" ></p>

<p>  所以总结一下文件的两种不同写入方式。(当然上面是vim里面xxd显示的问题)</p>

<p>  我们用如下代码测试:</p>

<pre><code>int main(int argc, const char *argv[])
{
  FILE * fp  = fopen("output.txt", "w");
  fputc(10, fp);
  fputc(13, fp);
  fputc('\n', fp);
  fclose(fp);

  fp  = fopen("output.bin", "wb");
  int32_t length[] ={0x0a, 0x12345678};
  fwrite(&amp;length, sizeof(int32_t), 2, fp);
  fclose(fp);
  return 0;
}
</code></pre>

<!--more-->


<p><strong>windows下</strong></p>

<p>文本文件写入：</p>

<pre><code>0000000: 0d0a 0d0d 0a                             .....
</code></pre>

<p>二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>linux下：</strong></p>

<p>  文本方式写入</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入：</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>mac下</strong></p>

<p>  文本方式写入：</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p>  解释几个问题：</p>

<h3>回车符的转义</h3>

<p>  windows下写文本文件的时候换行符会被替换成回车换行(0d0a), 直接写0a(10)也是一样的. Linux和mac下不会,二进制文件不care这些.</p>

<h3>文件结尾判断</h3>

<p>  详见这里：<a href="http://blog.csdn.net/bingqing07/article/details/5785080">http://blog.csdn.net/bingqing07/article/details/5785080</a></p>

<h3>UTF-8 BOＭ</h3>

<p>  转载：</p>

<blockquote><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。
所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。
BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。
「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</p></blockquote>
]]></content>
  </entry>
  
</feed>
