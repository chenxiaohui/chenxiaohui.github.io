<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2013-10-14T21:25:20+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记]]></title>
    <link href="http://cxh.me/2013/09/02/cplusplus-primer-book-review/"/>
    <updated>2013-09-02T12:55:00+08:00</updated>
    <id>http://cxh.me/2013/09/02/cplusplus-primer-book-review</id>
    <content type="html"><![CDATA[<h1></h1>

<p>今天遇到一个c 的问题，上网查了查，发现答案的出处其实就是C Primer，想想这本经典的书其实没怎么细度过，很多细节其实模棱两可，所以决定每天读一点，务必求细致，不为速度，写点读书笔记权当是打卡了。</p>

<ol>
<li> 关于初始化变量和未初始化变量</li>
</ol>


<blockquote><p>这里有个很蛋疼的例子，VC我没试过，gcc下有匪夷所思的输出</p></blockquote>

<pre><code>int a;
int b;
int c;
printf("a=%d  b=%d  c=%dn", a, b, c);
</code></pre>

<p>2.块注释不能嵌套</p>

<p>3.两种初始化方式</p>

<pre><code>int ival(1024);//直接初始化
int ival=1024; //复制初始化
</code></pre>

<blockquote><p>c 中初始化不是赋值，初始化指创建变量并赋值，赋值则是擦去对象当前值并用新值代替</p>

<p>初始化语句中前面定义的变量可以用来初始化后面的值，所以如下语句是合法的</p></blockquote>

<pre><code>double salary=9999.99,wage(salary 0.01);
</code></pre>

<p>4.const作用域也不能出文件</p>

<p>5.const引用是指向const对象的引用，是一种语法规则限制。另外const引用可以初始化为不同类型的对象或右值，例如：</p>

<pre><code>double dval=3.14;
const int &amp;ri=dval;//编译器会转换代码为：int temp=dval;const int &amp;ri=temp;

const int &amp;r=42;
const int &amp;r2=r i;
</code></pre>

<p>6.string的连接： 操作符左右操作数必须至少有一个是string类型的，但是鉴于 操作符是从左到右求值的，所以这种是合法的：</p>

<pre><code>string s1="b";
string s2="a" s1 "c";
</code></pre>

<p>6.还有一件事情:大写字母的ascii码值小于小写字母，切记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐两个STL学习资源]]></title>
    <link href="http://cxh.me/2012/10/16/recommand-two-stl-learning-resource/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/16/recommand-two-stl-learning-resource</id>
    <content type="html"><![CDATA[<h1></h1>

<p>本来想自己写一点的，后来觉得见识颇浅，所以直接贴别人的了。两篇文章其实都是说algorithm多于stl的数据结构，不过这也可能是很多人学习的时候忽视的，而且把通用算法用到数组上的方法确实挺方便。</p>

<blockquote><p>1: <a href="http://www.lslnet.com/linux/books/resource/stl.html">http://www.lslnet.com/linux/books/resource/stl.html</a> STL 简介，标准模板库</p>

<p>2: <a href="http://net.pku.edu.cn/~yhf/UsingSTL.htm">http://net.pku.edu.cn/~yhf/UsingSTL.htm</a> 三十分钟掌握STL</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二维字符串数组的问题]]></title>
    <link href="http://cxh.me/2012/10/16/problems-of-two-dimension-string-array/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/16/problems-of-two-dimension-string-array</id>
    <content type="html"><![CDATA[<h1></h1>

<p>随手写了个字符串的程序，才发现自己好像对字符串数组的理解一直似懂非懂。</p>

<p>先举一个int二维数组简单的例子：</p>

<pre><code>void foo(int (*p)[3],int n)
{
    for(int i=0;i
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[变长数组的问题]]></title>
    <link href="http://cxh.me/2012/10/08/problems-about-length-variable-array/"/>
    <updated>2012-10-08T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/08/problems-about-length-variable-array</id>
    <content type="html"><![CDATA[<h1></h1>

<p>今天在gcc里写代码，偶然发现好像下标可以用变量（非const），比如：</p>

<pre><code>int n=0;
scanf("%d",&amp;n);
int a[n];//当然这里一定要有合法性判断
</code></pre>

<p>这个理念太颠覆了，从学c语言的时候就被灌输说数组长度是不可变的，想用可变长度的话，要么malloc一块内存，要么用vector这种动态表。后来试了试发现vc里是直接无法通过编译的。查到如下一段说明：</p>

<blockquote><p>在C99中新加入了对变长数组的支持，即数组的长度可以由某个非const变量来定义。可变数组的空间大小直到程序运行时才能确定，因此只有程序在运行时才能为程序分配空间。在gcc编译器程序会在运行时根据实际指定的大小(变量当前的值)调节esp的值，为数组在栈上分配适当大小的空间。由于要在运行时才能为数组分配空间，在开始分配空间之前空间的大小是不确定的，因此分配空间的起始地址也是不确定的(例如要在栈上分配两个可变长数组的情况下)。为了在以后的代码中对可变长数组的内容进行引用操作，程序必须通过某种方式获取可变长数组的地址。在gcc编译器中会在相对于ebp固定的偏移量的栈上分配的一个固定大小的区域（称为内情向量）来记录可变长数组的信息，如数组的开始地址等。后继代码通过内情向量中的起始地址访问可变长数组。</p>

<p>因为数组依靠在程序运行时动态的调整esp来分配空间，所以这种类型的数组只能够定义在栈内，不能够定义在数据段上(全局数组，静态数组)。</p></blockquote>

<p>看来gcc才是王道啊。</p>
]]></content>
  </entry>
  
</feed>
