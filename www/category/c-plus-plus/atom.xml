<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-28T18:28:09+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个关于宏的问题]]></title>
    <link href="http://cxh.me/2014/06/26/a-macro-problem/"/>
    <updated>2014-06-26T10:53:00+08:00</updated>
    <id>http://cxh.me/2014/06/26/a-macro-problem</id>
    <content type="html"><![CDATA[<p>  写了一段代码，我想实现宏里面拼接一个变量然后取得这个变量的值的效果，但是没有成功：</p>

<pre><code>#define OB_FIRST_ROOT_TABLE_TID 21
#define OB_INVALID_ID INT_MAX
const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";

struct TableBackupSQL
{
  uint64_t table_id_;
  const char* sql_;
  const char * table_name_;
  TableBackupSQL()
  {
    sql_ = NULL;
    table_name_ = NULL;
    table_id_ = OB_INVALID_ID;
  }
  TableBackupSQL(uint64_t table_id, const char* table_name, const char* sql)
  {
    sql_ = sql;
    table_name_ = table_name;
    table_id_ = table_id;
  }
};


#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from "#table_name)
#define TABLE_BACKUP(table_prefix)\
TABLE_BACKUP_(table_prefix, table_prefix##_TABLE_NAME)

TableBackupSQL table_backup_list_[] =
{
  TABLE_BACKUP(OB_FIRST_ROOT_TABLE)
};


int main(void)
{
  for (int i = 0; i &lt; sizeof(table_backup_list_)/sizeof(TableBackupSQL); i++)
  {
    TableBackupSQL&amp; desc = table_backup_list_[i];
    printf("%d, %s, %s\n", desc.table_id_, desc.table_name_, desc.sql_);
  }
}
</code></pre>

<p>  期望的结果是</p>

<pre><code>21, __first_root_table, select * from __first_root_table
</code></pre>

<p>  实际的结果是</p>

<pre><code>21, __first_root_table, select * from OB_FIRST_ROOT_TABLE_TABLE_NAME
</code></pre>

<!--more-->


<p>  拼出来的OB_FIRST_ROOT_TABLE_TABLE_NAME没有被替换，当然有很多方法绕开。我试图两次展开宏但是没有成功，这个跟<a href="http://blog.csdn.net/maray/article/details/11096459" title="介绍一个C++奇巧淫技">这里</a>说的问题毕竟不是一个。不知道C++11里面有没有解决方法。</p>

<p>  另外，我才发现一个struct直接赋值是C++11才允许的。比如：</p>

<pre><code>TableBackupSQL table_backup_list_[] =
{
  {21, "__first_root_table", "select * from __first_root_table"}
};
</code></pre>

<p>  不加-std=c++0x或者 -std=gnu++0x的时候会报错。c语言支持。</p>

<p>  后来发现我遗忘了一个事实，宏替换是发生在预编译期的，这时候都没有做语法词法分析，程序不知道一个变量应该如何替换，所以变量实际上没有被替换成值，这跟函数定义是不一样的。比如：</p>

<pre><code>#define wrap(value) value
int a  = 1;
int b = wrap(a);
</code></pre>

<p>  我们用gcc打印展开之后的结果如下：</p>

<pre><code>int a = 1;
int b = a;
</code></pre>

<p>  这里是不会展开成 int b = 1;的。而连接符#的作用也只是把宏替换后的字面值加上引号，比如：</p>

<pre><code>#define wrap(value) #value
int a  = 1;
const char * b = wrap(a);
</code></pre>

<p>  展开结果是：</p>

<pre><code>int a = 1;
const char * b = "a";
</code></pre>

<p>  而连接符##的作用就更简单了，就是提供一个标示宏传入参数的作用，比如</p>

<pre><code>#define wrap(value) a##value
int ab = 2;
int b = wrap(b);
</code></pre>

<p>  如果不写##就变成了avalue，无法区分输入参数，如果写a(value)就会替换成a(b),如果写a value就会替换成a b，所以想替换成ab只能用##。</p>

<p>  至于上面那个问题，如果我们table的名字都是宏定义的字符串，那就好办多了：</p>

<pre><code>const char* OB_FIRST_ROOT_TABLE_TABLE_NAME  =  "__first_root_table";
#define TABLE_BACKUP_(table_prefix, table_name)\
TableBackupSQL(table_prefix##_TID, table_prefix##_TABLE_NAME, "select * from " table_name)
</code></pre>

<p>  感谢郁白师兄的指导。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本文件和二进制文件读写]]></title>
    <link href="http://cxh.me/2014/06/21/bin-txt-file-read-write/"/>
    <updated>2014-06-21T12:28:00+08:00</updated>
    <id>http://cxh.me/2014/06/21/bin-txt-file-read-write</id>
    <content type="html"><![CDATA[<p>  探究这个的起因是我在序列化一个数据结构，用二进制写到文件之后用vim打开发现后面居然多了一个值。</p>

<p><img class="img-polaroid center" src="/images/2014/binfile.png" title="&ldquo;用vim显示二进制文件&rdquo; &ldquo;用vim显示二进制文件&rdquo;" ></p>

<p>  所以总结一下文件的两种不同写入方式。(当然上面是vim里面xxd显示的问题)</p>

<p>  我们用如下代码测试:</p>

<pre><code>int main(int argc, const char *argv[])
{
  FILE * fp  = fopen("output.txt", "w");
  fputc(10, fp);
  fputc(13, fp);
  fputc('\n', fp);
  fclose(fp);

  fp  = fopen("output.bin", "wb");
  int32_t length[] ={0x0a, 0x12345678};
  fwrite(&amp;length, sizeof(int32_t), 2, fp);
  fclose(fp);
  return 0;
}
</code></pre>

<!--more-->


<p><strong>windows下</strong></p>

<p>文本文件写入：</p>

<pre><code>0000000: 0d0a 0d0d 0a                             .....
</code></pre>

<p>二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>linux下：</strong></p>

<p>  文本方式写入</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入：</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p><strong>mac下</strong></p>

<p>  文本方式写入：</p>

<pre><code>0000000: 0a0d 0a                                  ...
</code></pre>

<p>  二进制写入</p>

<pre><code>0000000: 0a00 0000 7856 3412                      ....xV4.
</code></pre>

<p>  解释几个问题：</p>

<h3>回车符的转义</h3>

<p>  windows下写文本文件的时候换行符会被替换成回车换行(0d0a), 直接写0a(10)也是一样的. Linux和mac下不会,二进制文件不care这些.</p>

<h3>文件结尾判断</h3>

<p>  详见这里：<a href="http://blog.csdn.net/bingqing07/article/details/5785080">http://blog.csdn.net/bingqing07/article/details/5785080</a></p>

<h3>UTF-8 BOＭ</h3>

<p>  转载：</p>

<blockquote><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。
所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。
BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。
「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[总结STL的通用算法基本形式]]></title>
    <link href="http://cxh.me/2014/06/19/stl-algorithm-signature/"/>
    <updated>2014-06-19T09:58:00+08:00</updated>
    <id>http://cxh.me/2014/06/19/stl-algorithm-signature</id>
    <content type="html"><![CDATA[<p>stl的通用算法基本有如下四种形式：</p>

<ol>
<li>alg(beg, end, params)：使用源输入作为输出</li>
<li>alg(beg, end, dest, params) ：使用dest作为输出，需要保证有足够的空间，所以往往使用inserter</li>
<li>alg(beg, end, beg2, other params)：beg2作为输出，假定beg2开始的范围至少跟beg和end指定的范围一样大。</li>
<li>alg(beg, end, beg2, end2, params)：beg2 end2作为输出</li>
</ol>


<p>举例：</p>

<p>第一种比如：</p>

<pre><code>find(beg, end, search_value);
sort(beg, end);
accumulate(beg, end, original_value);
fill(beg, end, value); //特殊的：fill_n(begin, count, n)
replace(beg, end, value, replace_value);
unique(beg, end);
count(beg, end, value);
stable_sort(beg, end);
reverse(beg, end);
</code></pre>

<p>第二种比如：</p>

<pre><code>copy(beg, end, back_inserter(vector));
</code></pre>

<p>第三种比如：</p>

<pre><code>replace_copy(beg, end, beg2, value, replace_value);
unique_copy(beg, end, beg2);
reverse_copy(beg, end, beg2);
</code></pre>

<p>第四种比如：</p>

<pre><code>find_first_of(beg, end, beg2, end2);
</code></pre>

<p>另外，有的算法支持谓词，比如</p>

<pre><code>sort(beg, end, comp)
find_if(beg, end, comp)
count_if(beg, end, comp)
</code></pre>

<p>有的算法有copy和非copy版，比如</p>

<pre><code>replace(beg, end, value, replace_value);
unique(beg, end);

replace_copy(beg, end, beg2, value, replace_value);
unique_copy(beg, end, beg2);    
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c/c++ 文件/流读取函数总结]]></title>
    <link href="http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function/"/>
    <updated>2014-06-16T20:00:00+08:00</updated>
    <id>http://cxh.me/2014/06/16/c-cpp-file-stream-operation-function</id>
    <content type="html"><![CDATA[<h3>针对文本文件的，  c++主要有如下几种吧</h3>

<ol>
<li><p>getline： 实现上，输入istream流，需要支持特定traits的迭代器。从流里面每次一行读入string，遇到delim结束。</p>

<pre><code>   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str, _CharT __delim);

   template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;
     inline basic_istream&lt;_CharT,_Traits&gt;&amp;
     getline(basic_istream&lt;_CharT, _Traits&gt;&amp; __is,
         basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __str);
</code></pre></li>
</ol>


<!--more-->


<ol>
<li><p>stream.get/put：分为如下几种类型。</p>

<ol>
<li>不接收参数的直接返回结果</li>
<li>接收一个char类型的参数</li>
<li>接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</li>
<li>put直接输入一个字符</li>
<li><p>get 系的函数都不会ignore delim分隔符的，读到行尾需要手动ignore回车</p>

<pre><code>   int_type 
   get(void);

   __istream_type&amp; 
   get(char_type&amp; __c);

   __istream_type&amp; 
   get(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   get(char_type* __s, streamsize __n)

   __istream_type&amp;
   get(__streambuf_type&amp; __sb, char_type __delim);

   inline __istream_type&amp;
   get(__streambuf_type&amp; __sb)

   // Unformatted output:
   __ostream_type&amp; 
   put(char_type __c);
</code></pre></li>
</ol>
</li>
<li><p>stream.getline()：接收一个缓冲区和缓冲区大小，读取结果直到遇到delim，默认回车符</p>

<pre><code>   __istream_type&amp; 
   getline(char_type* __s, streamsize __n, char_type __delim);

   inline __istream_type&amp; 
   getline(char_type* __s, streamsize __n)
</code></pre></li>
<li><p>stream.read/stream.write()： 二进制操作，读写一段数据。</p>

<pre><code>   __istream_type&amp; 
   read(char_type* __s, streamsize __n);

   streamsize 
   readsome(char_type* __s, streamsize __n);

   __ostream_type&amp; 
   write(const char_type* __s, streamsize __n);
</code></pre></li>
<li><p>输入输出运算</p></li>
</ol>


<h3>c大概有如下几个：</h3>

<ol>
<li> fgetc/fputc</li>
<li> fgets/fputs</li>
<li> fscanf/fprintf</li>
<li><p> fread/fwrite</p>

<pre><code>__STDIO_INLINE _IO_ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
</code></pre></li>
</ol>


<p>  另外，stdio.h里也有getline的实现，传入一个FILE指针。需要注意的是传入的char **指针是会被申请内存并赋值的。所以需要自己释放。</p>

<p>  这里就不详述了，详见：
  <a href="http://zhaoyuqiang.blog.51cto.com/6328846/1296902">http://zhaoyuqiang.blog.51cto.com/6328846/1296902</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一个实际中遇到的覆盖问题]]></title>
    <link href="http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus/"/>
    <updated>2014-06-10T19:32:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个继承结构如下：</p>

<pre><code>ObServerSchemaService : init_core_schema(const ObSchemaManagerV2 &amp;schema)
         |
ObRootSchemaSerivice : init_core_schema()
</code></pre>

<p>  基类的init_core_schema接收一个核心表的schema，而这个schema往往是从rootserver传过来的，所以下面的子类RootSchemaService不需要传参，直接自己生成就好了。</p>

<p>  问题是如果在ObRootSchemaService的对象上想要调用ObServerSchemaService的init_core_schema函数会报错。因为命名空间上Root的会覆盖Server的，哪怕只是同名的数据成员也会隐藏基类的成员函数。比如：</p>

<pre><code>struct TableSchema
{
  const static int version_ = 1;
  int mem_version()
  {
    return version_;
  }
};

struct ExTableSchema: TableSchema
{
  int mem_version;
};
int main(void)
{
  ExTableSchema schema;
  schema.mem_version();
}
</code></pre>

<p>  解决方法很简单，直接指明命名空间就行了</p>

<pre><code>schema.TableSchema::mem_version();
</code></pre>
]]></content>
  </entry>
  
</feed>
