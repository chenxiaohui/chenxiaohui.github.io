<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-05-25T14:40:55+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective C++ 读书笔记]]></title>
    <link href="http://cxh.me/2013/11/23/effective-notes/"/>
    <updated>2013-11-23T16:41:00+08:00</updated>
    <id>http://cxh.me/2013/11/23/effective-notes</id>
    <content type="html"><![CDATA[<p>  Effective前面有几节是说构造析构赋值过程中基类和派生类的调用关系的，做了一个综合一点的例子，来验证一下这个问题。代码如下，话说贴代码是在是很没溜的做法，尤其是如果在出版的书中看到的话，这种行为基本属于骗稿费的&hellip;</p>

<!-- more -->


<p>  <strong>object.h</strong></p>

<pre><code>#ifndef OCEANBASE_OBJECT_H_
#define OCEANBASE_OBJECT_H_

#include "base_object.h"
class Object: public BaseObject
{
  public:
    Object ();
    Object (int magic);
    Object (const Object &amp; obj);
    virtual ~Object ();
    virtual void print_info();
    Object&amp; operator= (const Object&amp; obj);
    const int &amp; get_magic() const;
    const int &amp; get_magic();
  private:
    /* data */
    int magic_;
};

#endif //OCEANBASE_OBJECT_H_
</code></pre>

<p>  <strong>object.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "object.h"

Object::Object():magic_(0)
{
  printf("construct in derived \n");
}

Object::Object (int magic):magic_(magic), BaseObject(magic)
{
  printf("construct in derived with magic\n");
}

Object::Object (const Object &amp; obj)
  : BaseObject(obj)
{
  printf("copy construct in derived\n");
  magic_ = obj.magic_;
}

Object::~Object()
{
  printf("destructor in derived\n");
}

const int &amp; Object::get_magic() const
{
  printf("const\n");
  return magic_;
}

const int &amp; Object::get_magic()
{
  printf("non const\n");
  return magic_;
}

Object&amp; Object::operator= (const Object&amp; obj)
{
  printf("operator = in derived\n");
  //BaseObject::operator =(obj);
  magic_ = obj.magic_;
}

void Object::print_info()
{
  BaseObject::print_info();
  printf("derived:magic_%d\n", magic_);
}
</code></pre>

<p>  <strong>base_object.h</strong></p>

<pre><code>#ifndef OCEANBASE_BASE_OBJECT_H_
#define OCEANBASE_BASE_OBJECT_H_
class BaseObject
{
  public:
    BaseObject ();
    BaseObject (int base_magic);
    BaseObject (const BaseObject &amp;obj);
    virtual ~BaseObject ();
    //BaseObject &amp; operator= (const BaseObject &amp; obj);
    virtual void print_info();
  private:
    /* data */
    int base_magic_;
};

#endif //OCEANBASE_BASE_OBJECT_H_
</code></pre>

<p>  <strong>base_object.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "base_object.h"
BaseObject::BaseObject():base_magic_(0)
{
  printf("construct in base\n");
}

BaseObject::BaseObject(int base_magic):base_magic_(base_magic)
{
  printf("construct in base with magic\n");
}

BaseObject::BaseObject (const BaseObject &amp;obj)
{
  printf("copy construct in base\n");
  base_magic_ = obj.base_magic_;
}

BaseObject::~BaseObject()
{
  printf("destructor in base\n");
}

//BaseObject &amp; BaseObject::operator= (const BaseObject &amp; obj)
//{
  //printf("operator = in base\n");
  //base_magic_ =  obj.base_magic_;
//}

void BaseObject::print_info()
{
  printf("base_object: base_magic_%d\n", base_magic_);
}
</code></pre>

<p>  <strong>main.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "object.h"
int main(int argc, const char *argv[])
{
  printf("\n");
  printf("obj1\n");
  Object obj1(1);

  printf("\n");
  printf("obj2\n");
  Object obj2(2);

  printf("\n");
  obj2=obj1;

  printf("\n");
  printf("obj1.print_info()\n");
  obj1.print_info();

  printf("\n");
  printf("obj2.print_info()\n");
  obj2.print_info();

  printf("\n");
  return 0;
}
</code></pre>

<p>  <strong>Makefile</strong></p>

<pre><code>objects= main.o object.o base_object.o
outfile= out
flag= -g
cc= g++

$(outfile):$(objects)
    $(cc) $(flag) -o $(outfile) $(objects)

object.o:object.h
base_object.o:base_object.h
main.o:object.h base_object.h


.PHONY:clean
clean:
    -rm -f $(outfile) $(objects)
</code></pre>

<p>执行结果是：</p>

<pre><code>obj1
construct in base with magic
construct in derived with magic

obj2
construct in base with magic
construct in derived with magic

operator = in derived

obj1.print_info()
base_object: base_magic_1
derived:magic_1

obj2.print_info()
base_object: base_magic_2
derived:magic_1

destructor in derived
destructor in base
destructor in derived
destructor in base
</code></pre>

<p>  可以自行调整并执行，主要说明几个问题而已：</p>

<ol>
<li> Object c2=c1;这种会被编译器优化成拷贝构造，中间不会有=运算符的调用。</li>
<li> 没有显式声明的时候编译器为类生成默认构造函数，没有显示指明的情况下派生类构造函数自动调用基类的默认构造函数，如果基类有需要初始化的一定要手动声明并调用带参构造函数。</li>
<li> 没有显式声明的时候编译器为类生成默认拷贝构造函数，没有指明的情况下拷贝构造的时候派生类不会调用基类的拷贝构造，只会调用基类的默认构造函数来内部的基类对象，所以需要自己调用基类的拷贝构造。</li>
<li> 编译器不会为=运算符自动生成重载，=运算符也不调用基类的=运算符重载，所以需要自己声明并调用，这也是书中强调的。</li>
<li> 没有=运算符重载的情况下遇到=操作，拷贝对象每个字段。</li>
</ol>


<p>  总结一下如下表：</p>

<p>   {% pandoc cpp_construct.md %}</p>

<p>  注：虽然应该是c++标准，但是还是限制一下编译器版本吧，在gcc4.4.6下验证通过（ob的编译器版本）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记]]></title>
    <link href="http://cxh.me/2013/09/02/cplusplus-primer-book-review/"/>
    <updated>2013-09-02T12:55:00+08:00</updated>
    <id>http://cxh.me/2013/09/02/cplusplus-primer-book-review</id>
    <content type="html"><![CDATA[<h1></h1>

<p>今天遇到一个c 的问题，上网查了查，发现答案的出处其实就是C Primer，想想这本经典的书其实没怎么细度过，很多细节其实模棱两可，所以决定每天读一点，务必求细致，不为速度，写点读书笔记权当是打卡了。</p>

<ol>
<li> 关于初始化变量和未初始化变量</li>
</ol>


<blockquote><p>这里有个很蛋疼的例子，VC我没试过，gcc下有匪夷所思的输出</p></blockquote>

<pre><code>int a;
int b;
int c;
printf("a=%d  b=%d  c=%dn", a, b, c);
</code></pre>

<p>2.块注释不能嵌套</p>

<p>3.两种初始化方式</p>

<pre><code>int ival(1024);//直接初始化
int ival=1024; //复制初始化
</code></pre>

<blockquote><p>c 中初始化不是赋值，初始化指创建变量并赋值，赋值则是擦去对象当前值并用新值代替</p>

<p>初始化语句中前面定义的变量可以用来初始化后面的值，所以如下语句是合法的</p></blockquote>

<pre><code>double salary=9999.99,wage(salary 0.01);
</code></pre>

<p>4.const作用域也不能出文件</p>

<p>5.const引用是指向const对象的引用，是一种语法规则限制。另外const引用可以初始化为不同类型的对象或右值，例如：</p>

<pre><code>double dval=3.14;
const int &amp;ri=dval;//编译器会转换代码为：int temp=dval;const int &amp;ri=temp;

const int &amp;r=42;
const int &amp;r2=r i;
</code></pre>

<p>6.string的连接： 操作符左右操作数必须至少有一个是string类型的，但是鉴于 操作符是从左到右求值的，所以这种是合法的：</p>

<pre><code>string s1="b";
string s2="a" s1 "c";
</code></pre>

<p>6.还有一件事情:大写字母的ascii码值小于小写字母，切记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐两个STL学习资源]]></title>
    <link href="http://cxh.me/2012/10/16/recommand-two-stl-learning-resource/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/16/recommand-two-stl-learning-resource</id>
    <content type="html"><![CDATA[<h1></h1>

<p>本来想自己写一点的，后来觉得见识颇浅，所以直接贴别人的了。两篇文章其实都是说algorithm多于stl的数据结构，不过这也可能是很多人学习的时候忽视的，而且把通用算法用到数组上的方法确实挺方便。</p>

<blockquote><p>1: <a href="http://www.lslnet.com/linux/books/resource/stl.html">http://www.lslnet.com/linux/books/resource/stl.html</a> STL 简介，标准模板库</p>

<p>2: <a href="http://net.pku.edu.cn/~yhf/UsingSTL.htm">http://net.pku.edu.cn/~yhf/UsingSTL.htm</a> 三十分钟掌握STL</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二维字符串数组的问题]]></title>
    <link href="http://cxh.me/2012/10/16/problems-of-two-dimension-string-array/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/16/problems-of-two-dimension-string-array</id>
    <content type="html"><![CDATA[<h1></h1>

<p>随手写了个字符串的程序，才发现自己好像对字符串数组的理解一直似懂非懂。</p>

<p>先举一个int二维数组简单的例子：</p>

<pre><code>void foo(int (*p)[3],int n)
{
    for(int i=0;i
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[变长数组的问题]]></title>
    <link href="http://cxh.me/2012/10/08/problems-about-length-variable-array/"/>
    <updated>2012-10-08T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/08/problems-about-length-variable-array</id>
    <content type="html"><![CDATA[<h1></h1>

<p>今天在gcc里写代码，偶然发现好像下标可以用变量（非const），比如：</p>

<pre><code>int n=0;
scanf("%d",&amp;n);
int a[n];//当然这里一定要有合法性判断
</code></pre>

<p>这个理念太颠覆了，从学c语言的时候就被灌输说数组长度是不可变的，想用可变长度的话，要么malloc一块内存，要么用vector这种动态表。后来试了试发现vc里是直接无法通过编译的。查到如下一段说明：</p>

<blockquote><p>在C99中新加入了对变长数组的支持，即数组的长度可以由某个非const变量来定义。可变数组的空间大小直到程序运行时才能确定，因此只有程序在运行时才能为程序分配空间。在gcc编译器程序会在运行时根据实际指定的大小(变量当前的值)调节esp的值，为数组在栈上分配适当大小的空间。由于要在运行时才能为数组分配空间，在开始分配空间之前空间的大小是不确定的，因此分配空间的起始地址也是不确定的(例如要在栈上分配两个可变长数组的情况下)。为了在以后的代码中对可变长数组的内容进行引用操作，程序必须通过某种方式获取可变长数组的地址。在gcc编译器中会在相对于ebp固定的偏移量的栈上分配的一个固定大小的区域（称为内情向量）来记录可变长数组的信息，如数组的开始地址等。后继代码通过内情向量中的起始地址访问可变长数组。</p>

<p>因为数组依靠在程序运行时动态的调整esp来分配空间，所以这种类型的数组只能够定义在栈内，不能够定义在数据段上(全局数组，静态数组)。</p></blockquote>

<p>看来gcc才是王道啊。</p>
]]></content>
  </entry>
  
</feed>
