<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2014-06-15T12:21:58+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记一个实际中遇到的覆盖问题]]></title>
    <link href="http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus/"/>
    <updated>2014-06-10T19:32:00+08:00</updated>
    <id>http://cxh.me/2014/06/10/an-overwrite-problem-in-cplusplus</id>
    <content type="html"><![CDATA[<p>  工作中遇到一个继承结构如下：</p>

<pre><code>ObServerSchemaService : init_core_schema(const ObSchemaManagerV2 &amp;schema)
         |
ObRootSchemaSerivice : init_core_schema()
</code></pre>

<p>  基类的init_core_schema接收一个核心表的schema，而这个schema往往是从rootserver传过来的，所以下面的子类RootSchemaService不需要传参，直接自己生成就好了。</p>

<p>  问题是如果在ObRootSchemaService的对象上想要调用ObServerSchemaService的init_core_schema函数会报错。因为命名空间上Root的会覆盖Server的，哪怕只是同名的数据成员也会隐藏基类的成员函数。比如：</p>

<pre><code>struct TableSchema
{
  const static int version_ = 1;
  int mem_version()
  {
    return version_;
  }
};

struct ExTableSchema: TableSchema
{
  int mem_version;
};
int main(void)
{
  ExTableSchema schema;
  schema.mem_version();
}
</code></pre>

<p>  解决方法很简单，直接指明命名空间就行了</p>

<pre><code>schema.TableSchema::mem_version();
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective C++ 读书笔记]]></title>
    <link href="http://cxh.me/2013/11/23/effective-notes/"/>
    <updated>2013-11-23T16:41:00+08:00</updated>
    <id>http://cxh.me/2013/11/23/effective-notes</id>
    <content type="html"><![CDATA[<p>  Effective前面有几节是说构造析构赋值过程中基类和派生类的调用关系的，做了一个综合一点的例子，来验证一下这个问题。代码如下，话说贴代码是在是很没溜的做法，尤其是如果在出版的书中看到的话，这种行为基本属于骗稿费的&hellip;</p>

<!-- more -->


<p>  <strong>object.h</strong></p>

<pre><code>#ifndef OCEANBASE_OBJECT_H_
#define OCEANBASE_OBJECT_H_

#include "base_object.h"
class Object: public BaseObject
{
  public:
    Object ();
    Object (int magic);
    Object (const Object &amp; obj);
    virtual ~Object ();
    virtual void print_info();
    Object&amp; operator= (const Object&amp; obj);
    const int &amp; get_magic() const;
    const int &amp; get_magic();
  private:
    /* data */
    int magic_;
};

#endif //OCEANBASE_OBJECT_H_
</code></pre>

<p>  <strong>object.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "object.h"

Object::Object():magic_(0)
{
  printf("construct in derived \n");
}

Object::Object (int magic):magic_(magic), BaseObject(magic)
{
  printf("construct in derived with magic\n");
}

Object::Object (const Object &amp; obj)
  : BaseObject(obj)
{
  printf("copy construct in derived\n");
  magic_ = obj.magic_;
}

Object::~Object()
{
  printf("destructor in derived\n");
}

const int &amp; Object::get_magic() const
{
  printf("const\n");
  return magic_;
}

const int &amp; Object::get_magic()
{
  printf("non const\n");
  return magic_;
}

Object&amp; Object::operator= (const Object&amp; obj)
{
  printf("operator = in derived\n");
  //BaseObject::operator =(obj);
  magic_ = obj.magic_;
}

void Object::print_info()
{
  BaseObject::print_info();
  printf("derived:magic_%d\n", magic_);
}
</code></pre>

<p>  <strong>base_object.h</strong></p>

<pre><code>#ifndef OCEANBASE_BASE_OBJECT_H_
#define OCEANBASE_BASE_OBJECT_H_
class BaseObject
{
  public:
    BaseObject ();
    BaseObject (int base_magic);
    BaseObject (const BaseObject &amp;obj);
    virtual ~BaseObject ();
    //BaseObject &amp; operator= (const BaseObject &amp; obj);
    virtual void print_info();
  private:
    /* data */
    int base_magic_;
};

#endif //OCEANBASE_BASE_OBJECT_H_
</code></pre>

<p>  <strong>base_object.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "base_object.h"
BaseObject::BaseObject():base_magic_(0)
{
  printf("construct in base\n");
}

BaseObject::BaseObject(int base_magic):base_magic_(base_magic)
{
  printf("construct in base with magic\n");
}

BaseObject::BaseObject (const BaseObject &amp;obj)
{
  printf("copy construct in base\n");
  base_magic_ = obj.base_magic_;
}

BaseObject::~BaseObject()
{
  printf("destructor in base\n");
}

//BaseObject &amp; BaseObject::operator= (const BaseObject &amp; obj)
//{
  //printf("operator = in base\n");
  //base_magic_ =  obj.base_magic_;
//}

void BaseObject::print_info()
{
  printf("base_object: base_magic_%d\n", base_magic_);
}
</code></pre>

<p>  <strong>main.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include "object.h"
int main(int argc, const char *argv[])
{
  printf("\n");
  printf("obj1\n");
  Object obj1(1);

  printf("\n");
  printf("obj2\n");
  Object obj2(2);

  printf("\n");
  obj2=obj1;

  printf("\n");
  printf("obj1.print_info()\n");
  obj1.print_info();

  printf("\n");
  printf("obj2.print_info()\n");
  obj2.print_info();

  printf("\n");
  return 0;
}
</code></pre>

<p>  <strong>Makefile</strong></p>

<pre><code>objects= main.o object.o base_object.o
outfile= out
flag= -g
cc= g++

$(outfile):$(objects)
    $(cc) $(flag) -o $(outfile) $(objects)

object.o:object.h
base_object.o:base_object.h
main.o:object.h base_object.h


.PHONY:clean
clean:
    -rm -f $(outfile) $(objects)
</code></pre>

<p>执行结果是：</p>

<pre><code>obj1
construct in base with magic
construct in derived with magic

obj2
construct in base with magic
construct in derived with magic

operator = in derived

obj1.print_info()
base_object: base_magic_1
derived:magic_1

obj2.print_info()
base_object: base_magic_2
derived:magic_1

destructor in derived
destructor in base
destructor in derived
destructor in base
</code></pre>

<p>  可以自行调整并执行，主要说明几个问题而已：</p>

<ol>
<li> Object c2=c1;这种会被编译器优化成拷贝构造，中间不会有=运算符的调用。</li>
<li> 没有显式声明的时候编译器为类生成默认构造函数，没有显示指明的情况下派生类构造函数自动调用基类的默认构造函数，如果基类有需要初始化的一定要手动声明并调用带参构造函数。</li>
<li> 没有显式声明的时候编译器为类生成默认拷贝构造函数，没有指明的情况下拷贝构造的时候派生类不会调用基类的拷贝构造，只会调用基类的默认构造函数来内部的基类对象，所以需要自己调用基类的拷贝构造。</li>
<li> 编译器不会为=运算符自动生成重载，=运算符也不调用基类的=运算符重载，所以需要自己声明并调用，这也是书中强调的。</li>
<li> 没有=运算符重载的情况下遇到=操作，拷贝对象每个字段。</li>
</ol>


<p>  总结一下如下表：</p>

<p>   <table>
<caption>表1 总结下对象生成类的函数的编译器行为</caption>
<thead>
<tr class="header">
<th align="center">函数</th>
<th align="center">没有声明的情况下是否自动生成</th>
<th align="center">是否默认调用基类的对应函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">构造函数</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr class="even">
<td align="center">拷贝构造</td>
<td align="center">是</td>
<td align="center">否,调用基类默认构造函数构造基类对象</td>
</tr>
<tr class="odd">
<td align="center">等号运算符重载</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody>
</table>
</p>

<p>  注：虽然应该是c++标准，但是还是限制一下编译器版本吧，在gcc4.4.6下验证通过（ob的编译器版本）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记]]></title>
    <link href="http://cxh.me/2013/09/02/cplusplus-primer-book-review/"/>
    <updated>2013-09-02T12:55:00+08:00</updated>
    <id>http://cxh.me/2013/09/02/cplusplus-primer-book-review</id>
    <content type="html"><![CDATA[<h1></h1>

<p>今天遇到一个c 的问题，上网查了查，发现答案的出处其实就是C Primer，想想这本经典的书其实没怎么细度过，很多细节其实模棱两可，所以决定每天读一点，务必求细致，不为速度，写点读书笔记权当是打卡了。</p>

<ol>
<li> 关于初始化变量和未初始化变量</li>
</ol>


<blockquote><p>这里有个很蛋疼的例子，VC我没试过，gcc下有匪夷所思的输出</p></blockquote>

<pre><code>int a;
int b;
int c;
printf("a=%d  b=%d  c=%dn", a, b, c);
</code></pre>

<p>2.块注释不能嵌套</p>

<p>3.两种初始化方式</p>

<pre><code>int ival(1024);//直接初始化
int ival=1024; //复制初始化
</code></pre>

<blockquote><p>c 中初始化不是赋值，初始化指创建变量并赋值，赋值则是擦去对象当前值并用新值代替</p>

<p>初始化语句中前面定义的变量可以用来初始化后面的值，所以如下语句是合法的</p></blockquote>

<pre><code>double salary=9999.99,wage(salary 0.01);
</code></pre>

<p>4.const作用域也不能出文件</p>

<p>5.const引用是指向const对象的引用，是一种语法规则限制。另外const引用可以初始化为不同类型的对象或右值，例如：</p>

<pre><code>double dval=3.14;
const int &amp;ri=dval;//编译器会转换代码为：int temp=dval;const int &amp;ri=temp;

const int &amp;r=42;
const int &amp;r2=r i;
</code></pre>

<p>6.string的连接： 操作符左右操作数必须至少有一个是string类型的，但是鉴于 操作符是从左到右求值的，所以这种是合法的：</p>

<pre><code>string s1="b";
string s2="a" s1 "c";
</code></pre>

<p>6.还有一件事情:大写字母的ascii码值小于小写字母，切记</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐两个STL学习资源]]></title>
    <link href="http://cxh.me/2012/10/16/recommand-two-stl-learning-resource/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/16/recommand-two-stl-learning-resource</id>
    <content type="html"><![CDATA[<h1></h1>

<p>本来想自己写一点的，后来觉得见识颇浅，所以直接贴别人的了。两篇文章其实都是说algorithm多于stl的数据结构，不过这也可能是很多人学习的时候忽视的，而且把通用算法用到数组上的方法确实挺方便。</p>

<blockquote><p>1: <a href="http://www.lslnet.com/linux/books/resource/stl.html">http://www.lslnet.com/linux/books/resource/stl.html</a> STL 简介，标准模板库</p>

<p>2: <a href="http://net.pku.edu.cn/~yhf/UsingSTL.htm">http://net.pku.edu.cn/~yhf/UsingSTL.htm</a> 三十分钟掌握STL</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二维字符串数组的问题]]></title>
    <link href="http://cxh.me/2012/10/16/problems-of-two-dimension-string-array/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://cxh.me/2012/10/16/problems-of-two-dimension-string-array</id>
    <content type="html"><![CDATA[<h1></h1>

<p>随手写了个字符串的程序，才发现自己好像对字符串数组的理解一直似懂非懂。</p>

<p>先举一个int二维数组简单的例子：</p>

<pre><code>void foo(int (*p)[3],int n)
{
    for(int i=0;i
</code></pre>
]]></content>
  </entry>
  
</feed>
