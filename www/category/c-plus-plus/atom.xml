<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | CXH.ME]]></title>
  <link href="http://cxh.me/category/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://cxh.me/"/>
  <updated>2015-07-18T11:58:39+08:00</updated>
  <id>http://cxh.me/</id>
  <author>
    <name><![CDATA[Harry Chen]]></name>
    <email><![CDATA[sdqxcxh@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Log4cxx安装]]></title>
    <link href="http://cxh.me/2015/03/16/log4cxx-setup/"/>
    <updated>2015-03-16T11:49:00+08:00</updated>
    <id>http://cxh.me/2015/03/16/log4cxx-setup</id>
    <content type="html"><![CDATA[<p>  apache经典的项目，java下有log4j，c++下的实现是log4cxx，安装见<a href="http://www.codelast.com/?p=3211" title="[原创]    log4cxx在Linux下的安装、使用">参考文献</a>.</p>

<p>  主要有个编译问题，大概是C库和C++库的问题，把出错的地方的头文件都补上就行了。</p>

<ol>
<li>console.cpp ： #include &lt;string.h> #include &lt;stdio.h></li>
<li>socketoutputstream.cpp : #include &lt;string.h></li>
<li>inputstreamreader.cpp: #include &lt;string.h></li>
</ol>


<h3>Bibliography:</h3>

<blockquote><p>[1] [原创]  log4cxx在Linux下的安装、使用, <a href="http://www.codelast.com/?p=3211">http://www.codelast.com/?p=3211</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gcc命令行参数总结]]></title>
    <link href="http://cxh.me/2015/02/04/gc-gcc-parameters-summary/"/>
    <updated>2015-02-04T11:36:00+08:00</updated>
    <id>http://cxh.me/2015/02/04/gc-gcc-parameters-summary</id>
    <content type="html"><![CDATA[<p>   总结一下混乱的GCC命令行参数，帮助写Makefile:</p>

<ol>
<li><p>编译阶段</p>

<ol>
<li>预编译E->生成汇编S(ccl)&ndash;>生成机器码c(as)&ndash;>链接生成目标程序(ld)</li>
</ol>
</li>
<li><p>输出类型：</p>

<ol>
<li>-E 只执行到预编译</li>
<li>-S 只执行到汇编阶段。生成汇编代码。</li>
<li>-c 只执行到编译。输出目标文件。</li>
<li>空。生成链接目标代码。</li>
<li>-o 指定输出文件名。</li>
</ol>
</li>
<li><p>输入类型：</p>

<ol>
<li><p>每个阶段可以接受之前阶段的中间结果（可跨越）。比如：</p>

<pre><code> gcc -E hello.c -o hello.i
 gcc -S hello.i -o hello.s
 顺序可以换：
 gcc -c -o hello.o hello.c
</code></pre></li>
</ol>
</li>
<li><p>优化调试相关</p>

<ol>
<li>-g 生成调试信息</li>
<li>-s 去掉调试和符号信息</li>
<li>-O[1|2|3..] 编译优化</li>
<li>-W[all] 开启额外警告</li>
</ol>
</li>
<li><p>链接相关：</p>

<ol>
<li>-l, 指定所使用到的函数库</li>
<li>-L, 指定函数库所在的文件夹。</li>
<li>-I, 指定头文件所在的文件夹</li>
</ol>
</li>
</ol>


<h3>Bibliography:</h3>

<blockquote><p>[1] Linux平台gcc和动态共享库的基础知识, <a href="http://robbinfan.com/blog/9/gcc-linker-basic-usage">http://robbinfan.com/blog/9/gcc-linker-basic-usage</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About random shuffle in cplusplus]]></title>
    <link href="http://cxh.me/2015/02/01/random-shuffle/"/>
    <updated>2015-02-01T19:14:00+08:00</updated>
    <id>http://cxh.me/2015/02/01/random-shuffle</id>
    <content type="html"><![CDATA[<p>   Actually I just want to memorize the usage of STL function random_shuffle. It takes two or threes arguments, the begin iterator, end iterator and a generator. What makes it interesting is the optional third parameter. Random_shuffle will pass the index to generator and takes the output as index to place current element while shuffling. Here is an example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
const int POKER_NUM = 52; //52 pocker cards
void print_poker(int PokerNum)
{
    cout &lt;&lt; PokerNum &lt;&lt; " ";
}

class MyRand
{
public:
    int operator()(int index)
    {
        return rand() % PockerNum;
    }
};

int main()
{
    srand( (unsigned)time(NULL) ); //rand seed
    vector&lt;int&gt; poker; 
    //initialize
    for (int num = 0; num &lt; POKER_NUM; ++num)
    {
        poker.push_back(num+1);
    }

    //with default random_shuffle
    random_shuffle(poker.begin(), poker.end());
    for_each(poker.begin(), poker.end(), print_poker);
    cout &lt;&lt; endl;

    //use custom random_shuffle
    random_shuffle(poker.begin(), poker.end(), MyRand());
    copy(poker.begin(), poker.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
}
</code></pre>

<p>  I copy it from <a href="http://blog.csdn.net/aheroofeast/article/details/3907192" title="random_shuffle算法小例子">here</a>. While I found a mistake in it. The result isn&rsquo;t really random. The pseudo-code of above is :</p>

<pre><code>for i in 0..n
    exchange a[i] and a[random(0..n)]
</code></pre>

<p>  We assume a method can generate a sequence(a[0]..[n]) randomly, which means each sequence appears with the probability 1/n!. Take certain sequence a[0']&hellip;a[n'] as an example: a[0'] appears with the probability 1/n, so a[1'] should appear with the probability 1/(n-1), etc. The algorithm above find a[1'] in the whole candidates, makes the probability 1/n actually. The right algorithm is like this:</p>

<pre><code>for i in 0..n
    exchange a[i] and a[random(i..n)]
</code></pre>

<p>  With a little change in the code:</p>

<pre><code>class MyRand
{
public:
    int operator()(int index)
    {
        return rand() % (PockerNum - index) + index;
    }
};
</code></pre>

<h3>Bibliography:</h3>

<blockquote><p>[1] random_shuffle算法小例子, <a href="http://blog.csdn.net/aheroofeast/article/details/3907192">http://blog.csdn.net/aheroofeast/article/details/3907192</a></p>

<p>[2]   &ldquo;Algorithms, <a href="http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY">http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协变返回类型]]></title>
    <link href="http://cxh.me/2015/01/27/convariant-return-type/"/>
    <updated>2015-01-27T15:48:00+08:00</updated>
    <id>http://cxh.me/2015/01/27/convariant-return-type</id>
    <content type="html"><![CDATA[<p>  协变返回类型（Convariant Return Type）是指override的函数，返回值有继承关系（子类函数返回类型是父类返回类型的子类）。例子如下：</p>

<!--more-->


<pre><code>class Base
{
  public:
    Base (){}
    virtual void print(){
      printf("Base");
    }
};

class Derived : public Base
{
  public:
    Derived(){}
    virtual ~Derived (){}
    void print(){
      printf("Derived");
    }
};

class TestBase
{
  public:
    TestBase (){}
    virtual Base* getObject(){
      return new Base();
    }
};

class TestDerived : public TestBase
{
  public:
    TestDerived (){}
    virtual ~TestDerived (){}
    Derived* getObject(){
      printf("invoke here\n");
      return new Derived;
    }
};

int main(int argc, const char *argv[])
{
  TestBase * base = new TestDerived();
  Base* b = base-&gt;getObject();
  b-&gt;print();
  return 0;
}

结果：
invoke here
Derived
</code></pre>

<p>  java同理，只不过验证起来比较容易。直接打印对象就行。</p>

<pre><code>public class BaseClass {
}
public class DerivedClass extends BaseClass{
}

public class TestBase {
    public BaseClass getObject(){
        return new BaseClass();
    }
}

public class TestDerived extends TestBase{
    public DerivedClass getObject(){
        return new DerivedClass();
    }
    public static void main(String[] args) {
        TestBase base = new TestDerived();
        System.out.println(base.getObject());
    }
}

返回值：
test.server.others.DerivedClass@5d1eb50b
</code></pre>

<p>  这里想验证的其实是返回引用是可以的。返回对象是不行的。java只有返回引用，所以都可以。可自行验证。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚函数模板和模板类中的虚函数]]></title>
    <link href="http://cxh.me/2014/10/29/cpp-virtual-template-function/"/>
    <updated>2014-10-29T21:05:00+08:00</updated>
    <id>http://cxh.me/2014/10/29/cpp-virtual-template-function</id>
    <content type="html"><![CDATA[<p>  自从知道了C++不支持虚函数模板之后就觉得相关的一概不支持，今天写程序的时候想把基类做成模板，然后继承基类。以为也不支持，写了一下才发现支持的，无论是非模板类继承一个特化之后的模板还是模板类继承包含虚函数的模板基类都是没问题的。从实现上看，反正使用的时候都会特化的，特化之后虚函数表指针是固定的。不存在像函数模板这种类生成的时候无法确定虚函数表的情况。</p>

<p>  例子如下：</p>

<!--more-->


<pre><code>enum SessionType
{
  ROSession,
  RWSession,
  RPSession
};
class BaseTransCtx
{
  public:
    BaseTransCtx (){}
    virtual ~BaseTransCtx (){}
};
template&lt;typename Type&gt;
class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
typedef ISessionCtxFactory&lt;SessionType&gt; SessionMgr;
class TransSessionMgr: public SessionMgr
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    BaseTransCtx *alloc(const SessionType type)
    {
      return NULL;
    }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
int main(int argc, const char *argv[])
{
  TransSessionMgr trans;
  BaseTransCtx* ctx = trans.alloc(RWSession);
  trans.free(ctx);
  return 0;
}
</code></pre>

<p>  模板类继承虚基类也可以。</p>

<pre><code>template&lt;typename Type&gt;
class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
template&lt;typename Type&gt;
class TransSessionMgr: public ISessionCtxFactory&lt;Type&gt;
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    BaseTransCtx *alloc(const Type type)
    {
      return NULL;
    }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
</code></pre>

<p>  但是这样就不行了</p>

<pre><code>class ISessionCtxFactory
{
  public:
    ISessionCtxFactory(){};
    ~ISessionCtxFactory() {};
  public:
    template&lt;typename Type&gt;
      virtual BaseTransCtx *alloc(const Type type) = 0;
    virtual void free(BaseTransCtx *ptr) = 0;
};
class TransSessionMgr: public ISessionCtxFactory
{
  public:
    TransSessionMgr (){}
    virtual ~TransSessionMgr (){}

    template&lt;typename Type&gt;
      BaseTransCtx *alloc(const Type type)
      {
        return NULL;
      }

    void free(BaseTransCtx *ptr)
    {
      if (ptr != NULL)
      {
        delete ptr;
      }
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
